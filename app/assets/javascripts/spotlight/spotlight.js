(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('leaflet'), require('clipboard'), require('blacklight-frontend')) :
  typeof define === 'function' && define.amd ? define(['leaflet', 'clipboard', 'blacklight-frontend'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Spotlight = factory(global.L, global.Clipboard, global.Blacklight));
})(this, (function (require$$0, Clipboard, Blacklight) { 'use strict';

  // Includes an unreleased RTL support pull request: https://github.com/ganlanyuan/tiny-slider/pull/658
  // Includes "export default tns" at the end of the file for spotlight/user/browse_group_categories.js
  var tns = (function (){
  var win = window;

  var raf = win.requestAnimationFrame
    || win.webkitRequestAnimationFrame
    || win.mozRequestAnimationFrame
    || win.msRequestAnimationFrame
    || function(cb) { return setTimeout(cb, 16); };

  var win$1 = window;

  var caf = win$1.cancelAnimationFrame
    || win$1.mozCancelAnimationFrame
    || function(id){ clearTimeout(id); };

  function extend() {
    var obj, name, copy,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length;

    for (; i < length; i++) {
      if ((obj = arguments[i]) !== null) {
        for (name in obj) {
          copy = obj[name];

          if (target === copy) {
            continue;
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  }

  function checkStorageValue (value) {
    return ['true', 'false'].indexOf(value) >= 0 ? JSON.parse(value) : value;
  }

  function setLocalStorage(storage, key, value, access) {
    if (access) {
      try { storage.setItem(key, value); } catch (e) {}
    }
    return value;
  }

  function getSlideId() {
    var id = window.tnsId;
    window.tnsId = !id ? 1 : id + 1;
    
    return 'tns' + window.tnsId;
  }

  function getBody () {
    var doc = document,
        body = doc.body;

    if (!body) {
      body = doc.createElement('body');
      body.fake = true;
    }

    return body;
  }

  var docElement = document.documentElement;

  function setFakeBody (body) {
    var docOverflow = '';
    if (body.fake) {
      docOverflow = docElement.style.overflow;
      //avoid crashing IE8, if background image is used
      body.style.background = '';
      //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible
      body.style.overflow = docElement.style.overflow = 'hidden';
      docElement.appendChild(body);
    }

    return docOverflow;
  }

  function resetFakeBody (body, docOverflow) {
    if (body.fake) {
      body.remove();
      docElement.style.overflow = docOverflow;
      // Trigger layout so kinetic scrolling isn't disabled in iOS6+
      // eslint-disable-next-line
      docElement.offsetHeight;
    }
  }

  // get css-calc 

  function calc() {
    var doc = document, 
        body = getBody(),
        docOverflow = setFakeBody(body),
        div = doc.createElement('div'), 
        result = false;

    body.appendChild(div);
    try {
      var str = '(10px * 10)',
          vals = ['calc' + str, '-moz-calc' + str, '-webkit-calc' + str],
          val;
      for (var i = 0; i < 3; i++) {
        val = vals[i];
        div.style.width = val;
        if (div.offsetWidth === 100) { 
          result = val.replace(str, ''); 
          break;
        }
      }
    } catch (e) {}
    
    body.fake ? resetFakeBody(body, docOverflow) : div.remove();

    return result;
  }

  // get subpixel support value

  function percentageLayout() {
    // check subpixel layout supporting
    var doc = document,
        body = getBody(),
        docOverflow = setFakeBody(body),
        wrapper = doc.createElement('div'),
        outer = doc.createElement('div'),
        str = '',
        count = 70,
        perPage = 3,
        supported = false;

    wrapper.className = "tns-t-subp2";
    outer.className = "tns-t-ct";

    for (var i = 0; i < count; i++) {
      str += '<div></div>';
    }

    outer.innerHTML = str;
    wrapper.appendChild(outer);
    body.appendChild(wrapper);

    supported = Math.abs(wrapper.getBoundingClientRect().left - outer.children[count - perPage].getBoundingClientRect().left) < 2;

    body.fake ? resetFakeBody(body, docOverflow) : wrapper.remove();

    return supported;
  }

  function mediaquerySupport () {
    if (window.matchMedia || window.msMatchMedia) {
      return true;
    }
    
    var doc = document,
        body = getBody(),
        docOverflow = setFakeBody(body),
        div = doc.createElement('div'),
        style = doc.createElement('style'),
        rule = '@media all and (min-width:1px){.tns-mq-test{position:absolute}}',
        position;

    style.type = 'text/css';
    div.className = 'tns-mq-test';

    body.appendChild(style);
    body.appendChild(div);

    if (style.styleSheet) {
      style.styleSheet.cssText = rule;
    } else {
      style.appendChild(doc.createTextNode(rule));
    }

    position = window.getComputedStyle ? window.getComputedStyle(div).position : div.currentStyle['position'];

    body.fake ? resetFakeBody(body, docOverflow) : div.remove();

    return position === "absolute";
  }

  // create and append style sheet
  function createStyleSheet (media, nonce) {
    // Create the <style> tag
    var style = document.createElement("style");

    // Add nonce attribute for Content Security Policy
    if (nonce) { style.setAttribute("nonce", nonce); }

    // WebKit hack :(
    // style.appendChild(document.createTextNode(""));

    // Add the <style> element to the page
    document.querySelector('head').appendChild(style);

    return style.sheet ? style.sheet : style.styleSheet;
  }

  // cross browsers addRule method
  function addCSSRule(sheet, selector, rules, index) {
    // return raf(function() {
      'insertRule' in sheet ?
        sheet.insertRule(selector + '{' + rules + '}', index) :
        sheet.addRule(selector, rules, index);
    // });
  }

  // cross browsers addRule method
  function removeCSSRule(sheet, index) {
    // return raf(function() {
      'deleteRule' in sheet ?
        sheet.deleteRule(index) :
        sheet.removeRule(index);
    // });
  }

  function getCssRulesLength(sheet) {
    var rule = ('insertRule' in sheet) ? sheet.cssRules : sheet.rules;
    return rule.length;
  }

  function toDegree (y, x) {
    return Math.atan2(y, x) * (180 / Math.PI);
  }

  function getTouchDirection(angle, range) {
    var direction = false,
        gap = Math.abs(90 - Math.abs(angle));
        
    if (gap >= 90 - range) {
      direction = 'horizontal';
    } else if (gap <= range) {
      direction = 'vertical';
    }

    return direction;
  }

  // https://toddmotto.com/ditch-the-array-foreach-call-nodelist-hack/
  function forEach (arr, callback, scope) {
    for (var i = 0, l = arr.length; i < l; i++) {
      callback.call(scope, arr[i], i);
    }
  }

  var classListSupport = 'classList' in document.createElement('_');

  var hasClass = classListSupport ?
      function (el, str) { return el.classList.contains(str); } :
      function (el, str) { return el.className.indexOf(str) >= 0; };

  var addClass = classListSupport ?
      function (el, str) {
        if (!hasClass(el,  str)) { el.classList.add(str); }
      } :
      function (el, str) {
        if (!hasClass(el,  str)) { el.className += ' ' + str; }
      };

  var removeClass = classListSupport ?
      function (el, str) {
        if (hasClass(el,  str)) { el.classList.remove(str); }
      } :
      function (el, str) {
        if (hasClass(el, str)) { el.className = el.className.replace(str, ''); }
      };

  function hasAttr(el, attr) {
    return el.hasAttribute(attr);
  }

  function getAttr(el, attr) {
    return el.getAttribute(attr);
  }

  function isNodeList(el) {
    // Only NodeList has the "item()" function
    return typeof el.item !== "undefined"; 
  }

  function setAttrs(els, attrs) {
    els = (isNodeList(els) || els instanceof Array) ? els : [els];
    if (Object.prototype.toString.call(attrs) !== '[object Object]') { return; }

    for (var i = els.length; i--;) {
      for(var key in attrs) {
        els[i].setAttribute(key, attrs[key]);
      }
    }
  }

  function removeAttrs(els, attrs) {
    els = (isNodeList(els) || els instanceof Array) ? els : [els];
    attrs = (attrs instanceof Array) ? attrs : [attrs];

    var attrLength = attrs.length;
    for (var i = els.length; i--;) {
      for (var j = attrLength; j--;) {
        els[i].removeAttribute(attrs[j]);
      }
    }
  }

  function arrayFromNodeList (nl) {
    var arr = [];
    for (var i = 0, l = nl.length; i < l; i++) {
      arr.push(nl[i]);
    }
    return arr;
  }

  function hideElement(el, forceHide) {
    if (el.style.display !== 'none') { el.style.display = 'none'; }
  }

  function showElement(el, forceHide) {
    if (el.style.display === 'none') { el.style.display = ''; }
  }

  function isVisible(el) {
    return window.getComputedStyle(el).display !== 'none';
  }

  function whichProperty(props){
    if (typeof props === 'string') {
      var arr = [props],
          Props = props.charAt(0).toUpperCase() + props.substr(1),
          prefixes = ['Webkit', 'Moz', 'ms', 'O'];
          
      prefixes.forEach(function(prefix) {
        if (prefix !== 'ms' || props === 'transform') {
          arr.push(prefix + Props);
        }
      });

      props = arr;
    }

    var el = document.createElement('fakeelement');
        props.length;
    for(var i = 0; i < props.length; i++){
      var prop = props[i];
      if( el.style[prop] !== undefined ){ return prop; }
    }

    return false; // explicit for ie9-
  }

  function has3DTransforms(tf){
    if (!tf) { return false; }
    if (!window.getComputedStyle) { return false; }
    
    var doc = document,
        body = getBody(),
        docOverflow = setFakeBody(body),
        el = doc.createElement('p'),
        has3d,
        cssTF = tf.length > 9 ? '-' + tf.slice(0, -9).toLowerCase() + '-' : '';

    cssTF += 'transform';

    // Add it to the body to get the computed style
    body.insertBefore(el, null);

    el.style[tf] = 'translate3d(1px,1px,1px)';
    has3d = window.getComputedStyle(el).getPropertyValue(cssTF);

    body.fake ? resetFakeBody(body, docOverflow) : el.remove();

    return (has3d !== undefined && has3d.length > 0 && has3d !== "none");
  }

  // get transitionend, animationend based on transitionDuration
  // @propin: string
  // @propOut: string, first-letter uppercase
  // Usage: getEndProperty('WebkitTransitionDuration', 'Transition') => webkitTransitionEnd
  function getEndProperty(propIn, propOut) {
    var endProp = false;
    if (/^Webkit/.test(propIn)) {
      endProp = 'webkit' + propOut + 'End';
    } else if (/^O/.test(propIn)) {
      endProp = 'o' + propOut + 'End';
    } else if (propIn) {
      endProp = propOut.toLowerCase() + 'end';
    }
    return endProp;
  }

  // Test via a getter in the options object to see if the passive property is accessed
  var supportsPassive = false;
  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e) {}
  var passiveOption = supportsPassive ? { passive: true } : false;

  function addEvents(el, obj, preventScrolling) {
    for (var prop in obj) {
      var option = ['touchstart', 'touchmove'].indexOf(prop) >= 0 && !preventScrolling ? passiveOption : false;
      el.addEventListener(prop, obj[prop], option);
    }
  }

  function removeEvents(el, obj) {
    for (var prop in obj) {
      var option = ['touchstart', 'touchmove'].indexOf(prop) >= 0 ? passiveOption : false;
      el.removeEventListener(prop, obj[prop], option);
    }
  }

  function Events() {
    return {
      topics: {},
      on: function (eventName, fn) {
        this.topics[eventName] = this.topics[eventName] || [];
        this.topics[eventName].push(fn);
      },
      off: function(eventName, fn) {
        if (this.topics[eventName]) {
          for (var i = 0; i < this.topics[eventName].length; i++) {
            if (this.topics[eventName][i] === fn) {
              this.topics[eventName].splice(i, 1);
              break;
            }
          }
        }
      },
      emit: function (eventName, data) {
        data.type = eventName;
        if (this.topics[eventName]) {
          this.topics[eventName].forEach(function(fn) {
            fn(data, eventName);
          });
        }
      }
    };
  }

  function jsTransform(element, attr, prefix, postfix, to, duration, callback) {
    var tick = Math.min(duration, 10),
        unit = (to.indexOf('%') >= 0) ? '%' : 'px',
        to = to.replace(unit, ''),
        from = Number(element.style[attr].replace(prefix, '').replace(postfix, '').replace(unit, '')),
        positionTick = (to - from) / duration * tick;

    setTimeout(moveElement, tick);
    function moveElement() {
      duration -= tick;
      from += positionTick;
      element.style[attr] = prefix + from + unit + postfix;
      if (duration > 0) { 
        setTimeout(moveElement, tick); 
      } else {
        callback();
      }
    }
  }

  // Object.keys
  if (!Object.keys) {
    Object.keys = function(object) {
      var keys = [];
      for (var name in object) {
        if (Object.prototype.hasOwnProperty.call(object, name)) {
          keys.push(name);
        }
      }
      return keys;
    };
  }

  // ChildNode.remove
  if(!("remove" in Element.prototype)){
    Element.prototype.remove = function(){
      if(this.parentNode) {
        this.parentNode.removeChild(this);
      }
    };
  }

  var tns = function(options) {
    options = extend({
      container: '.slider',
      mode: 'carousel',
      axis: 'horizontal',
      items: 1,
      gutter: 0,
      edgePadding: 0,
      fixedWidth: false,
      autoWidth: false,
      viewportMax: false,
      slideBy: 1,
      center: false,
      controls: true,
      controlsPosition: 'top',
      controlsText: ['prev', 'next'],
      controlsContainer: false,
      prevButton: false,
      nextButton: false,
      nav: true,
      navPosition: 'top',
      navContainer: false,
      navAsThumbnails: false,
      arrowKeys: false,
      speed: 300,
      autoplay: false,
      autoplayPosition: 'top',
      autoplayTimeout: 5000,
      autoplayDirection: 'forward',
      autoplayText: ['start', 'stop'],
      autoplayHoverPause: false,
      autoplayButton: false,
      autoplayButtonOutput: true,
      autoplayResetOnVisibility: true,
      animateIn: 'tns-fadeIn',
      animateOut: 'tns-fadeOut',
      animateNormal: 'tns-normal',
      animateDelay: false,
      loop: true,
      rewind: false,
      autoHeight: false,
      responsive: false,
      lazyload: false,
      lazyloadSelector: '.tns-lazy-img',
      touch: true,
      mouseDrag: false,
      swipeAngle: 15,
      nested: false,
      preventActionWhenRunning: false,
      preventScrollOnTouch: false,
      freezable: true,
      onInit: false,
      useLocalStorage: true,
      textDirection: 'ltr',
      nonce: false
    }, options || {});

    var doc = document,
        win = window,
        KEYS = {
          ENTER: 13,
          SPACE: 32,
          LEFT: 37,
          RIGHT: 39
        },
        tnsStorage = {},
        localStorageAccess = options.useLocalStorage;

    if (localStorageAccess) {
      // check browser version and local storage access
      var browserInfo = navigator.userAgent;
      var uid = new Date;

      try {
        tnsStorage = win.localStorage;
        if (tnsStorage) {
          tnsStorage.setItem(uid, uid);
          localStorageAccess = tnsStorage.getItem(uid) == uid;
          tnsStorage.removeItem(uid);
        } else {
          localStorageAccess = false;
        }
        if (!localStorageAccess) { tnsStorage = {}; }
      } catch(e) {
        localStorageAccess = false;
      }

      if (localStorageAccess) {
        // remove storage when browser version changes
        if (tnsStorage['tnsApp'] && tnsStorage['tnsApp'] !== browserInfo) {
          ['tC', 'tPL', 'tMQ', 'tTf', 't3D', 'tTDu', 'tTDe', 'tADu', 'tADe', 'tTE', 'tAE'].forEach(function(item) { tnsStorage.removeItem(item); });
        }
        // update browserInfo
        localStorage['tnsApp'] = browserInfo;
      }
    }

    var CALC = tnsStorage['tC'] ? checkStorageValue(tnsStorage['tC']) : setLocalStorage(tnsStorage, 'tC', calc(), localStorageAccess),
        PERCENTAGELAYOUT = tnsStorage['tPL'] ? checkStorageValue(tnsStorage['tPL']) : setLocalStorage(tnsStorage, 'tPL', percentageLayout(), localStorageAccess),
        CSSMQ = tnsStorage['tMQ'] ? checkStorageValue(tnsStorage['tMQ']) : setLocalStorage(tnsStorage, 'tMQ', mediaquerySupport(), localStorageAccess),
        TRANSFORM = tnsStorage['tTf'] ? checkStorageValue(tnsStorage['tTf']) : setLocalStorage(tnsStorage, 'tTf', whichProperty('transform'), localStorageAccess),
        HAS3DTRANSFORMS = tnsStorage['t3D'] ? checkStorageValue(tnsStorage['t3D']) : setLocalStorage(tnsStorage, 't3D', has3DTransforms(TRANSFORM), localStorageAccess),
        TRANSITIONDURATION = tnsStorage['tTDu'] ? checkStorageValue(tnsStorage['tTDu']) : setLocalStorage(tnsStorage, 'tTDu', whichProperty('transitionDuration'), localStorageAccess),
        TRANSITIONDELAY = tnsStorage['tTDe'] ? checkStorageValue(tnsStorage['tTDe']) : setLocalStorage(tnsStorage, 'tTDe', whichProperty('transitionDelay'), localStorageAccess),
        ANIMATIONDURATION = tnsStorage['tADu'] ? checkStorageValue(tnsStorage['tADu']) : setLocalStorage(tnsStorage, 'tADu', whichProperty('animationDuration'), localStorageAccess),
        ANIMATIONDELAY = tnsStorage['tADe'] ? checkStorageValue(tnsStorage['tADe']) : setLocalStorage(tnsStorage, 'tADe', whichProperty('animationDelay'), localStorageAccess),
        TRANSITIONEND = tnsStorage['tTE'] ? checkStorageValue(tnsStorage['tTE']) : setLocalStorage(tnsStorage, 'tTE', getEndProperty(TRANSITIONDURATION, 'Transition'), localStorageAccess),
        ANIMATIONEND = tnsStorage['tAE'] ? checkStorageValue(tnsStorage['tAE']) : setLocalStorage(tnsStorage, 'tAE', getEndProperty(ANIMATIONDURATION, 'Animation'), localStorageAccess);

    // get element nodes from selectors
    var supportConsoleWarn = win.console && typeof win.console.warn === "function",
        tnsList = ['container', 'controlsContainer', 'prevButton', 'nextButton', 'navContainer', 'autoplayButton'],
        optionsElements = {};

    tnsList.forEach(function(item) {
      if (typeof options[item] === 'string') {
        var str = options[item],
            el = doc.querySelector(str);
        optionsElements[item] = str;

        if (el && el.nodeName) {
          options[item] = el;
        } else {
          if (supportConsoleWarn) { console.warn('Can\'t find', options[item]); }
          return;
        }
      }
    });

    // make sure at least 1 slide
    if (options.container.children.length < 1) {
      if (supportConsoleWarn) { console.warn('No slides found in', options.container); }
      return;
     }

    // update options
    var responsive = options.responsive,
        nested = options.nested,
        carousel = options.mode === 'carousel' ? true : false;

    if (responsive) {
      // apply responsive[0] to options and remove it
      if (0 in responsive) {
        options = extend(options, responsive[0]);
        delete responsive[0];
      }

      var responsiveTem = {};
      for (var key in responsive) {
        var val = responsive[key];
        // update responsive
        // from: 300: 2
        // to:
        //   300: {
        //     items: 2
        //   }
        val = typeof val === 'number' ? {items: val} : val;
        responsiveTem[key] = val;
      }
      responsive = responsiveTem;
      responsiveTem = null;
    }

    // update options
    function updateOptions (obj) {
      for (var key in obj) {
        if (!carousel) {
          if (key === 'slideBy') { obj[key] = 'page'; }
          if (key === 'edgePadding') { obj[key] = false; }
          if (key === 'autoHeight') { obj[key] = false; }
        }

        // update responsive options
        if (key === 'responsive') { updateOptions(obj[key]); }
      }
    }
    if (!carousel) { updateOptions(options); }


    // === define and set variables ===
    if (!carousel) {
      options.axis = 'horizontal';
      options.slideBy = 'page';
      options.edgePadding = false;

      var animateIn = options.animateIn,
          animateOut = options.animateOut,
          animateDelay = options.animateDelay,
          animateNormal = options.animateNormal;
    }

    var horizontal = options.axis === 'horizontal' ? true : false,
        outerWrapper = doc.createElement('div'),
        innerWrapper = doc.createElement('div'),
        middleWrapper,
        container = options.container,
        containerParent = container.parentNode,
        containerHTML = container.outerHTML,
        slideItems = container.children,
        slideCount = slideItems.length,
        breakpointZone,
        windowWidth = getWindowWidth(),
        isOn = false;
    if (responsive) { setBreakpointZone(); }
    if (carousel) { container.className += ' tns-vpfix'; }

    // fixedWidth: viewport > rightBoundary > indexMax
    var autoWidth = options.autoWidth,
        fixedWidth = getOption('fixedWidth'),
        edgePadding = getOption('edgePadding'),
        gutter = getOption('gutter'),
        viewport = getViewportWidth(),
        center = getOption('center'),
        items = !autoWidth ? Math.floor(getOption('items')) : 1,
        slideBy = getOption('slideBy'),
        viewportMax = options.viewportMax || options.fixedWidthViewportWidth,
        arrowKeys = getOption('arrowKeys'),
        speed = getOption('speed'),
        rewind = options.rewind,
        loop = rewind ? false : options.loop,
        autoHeight = getOption('autoHeight'),
        controls = getOption('controls'),
        controlsText = getOption('controlsText'),
        textDirection = getOption('textDirection'),
        nav = getOption('nav'),
        touch = getOption('touch'),
        mouseDrag = getOption('mouseDrag'),
        autoplay = getOption('autoplay'),
        autoplayTimeout = getOption('autoplayTimeout'),
        autoplayText = getOption('autoplayText'),
        autoplayHoverPause = getOption('autoplayHoverPause'),
        autoplayResetOnVisibility = getOption('autoplayResetOnVisibility'),
        sheet = createStyleSheet(null, getOption('nonce')),
        lazyload = options.lazyload,
        lazyloadSelector = options.lazyloadSelector,
        slidePositions, // collection of slide positions
        slideItemsOut = [],
        cloneCount = loop ? getCloneCountForLoop() : 0,
        slideCountNew = !carousel ? slideCount + cloneCount : slideCount + cloneCount * 2,
        hasRightDeadZone = (fixedWidth || autoWidth) && !loop ? true : false,
        rightBoundary = fixedWidth ? getRightBoundary() : null,
        updateIndexBeforeTransform = (!carousel || !loop) ? true : false,
        // transform
        transformAttr = horizontal ? 'left' : 'top',
        transformPrefix = '',
        transformPostfix = '',
        // index
        getIndexMax = (function () {
          if (fixedWidth) {
            return function() { return center && !loop ? slideCount - 1 : Math.ceil(- rightBoundary / (fixedWidth + gutter)); };
          } else if (autoWidth) {
            return function() {
              for (var i = 0; i < slideCountNew; i++) {
                if (slidePositions[i] >= - rightBoundary) { return i; }
              }
            };
          } else {
            return function() {
              if (center && carousel && !loop) {
                return slideCount - 1;
              } else {
                return loop || carousel ? Math.max(0, slideCountNew - Math.ceil(items)) : slideCountNew - 1;
              }
            };
          }
        })(),
        index = getStartIndex(getOption('startIndex')),
        indexCached = index;
        getCurrentSlide();
        var indexMin = 0,
        indexMax = !autoWidth ? getIndexMax() : null,
        preventActionWhenRunning = options.preventActionWhenRunning,
        swipeAngle = options.swipeAngle,
        moveDirectionExpected = swipeAngle ? '?' : true,
        running = false,
        onInit = options.onInit,
        events = new Events(),
        // id, class
        newContainerClasses = ' tns-slider tns-' + options.mode,
        slideId = container.id || getSlideId(),
        disable = getOption('disable'),
        disabled = false,
        freezable = options.freezable,
        freeze = freezable && !autoWidth ? getFreeze() : false,
        frozen = false,
        controlsEvents = {
          'click': onControlsClick,
          'keydown': onControlsKeydown
        },
        navEvents = {
          'click': onNavClick,
          'keydown': onNavKeydown
        },
        hoverEvents = {
          'mouseover': mouseoverPause,
          'mouseout': mouseoutRestart
        },
        visibilityEvent = {'visibilitychange': onVisibilityChange},
        docmentKeydownEvent = {'keydown': onDocumentKeydown},
        touchEvents = {
          'touchstart': onPanStart,
          'touchmove': onPanMove,
          'touchend': onPanEnd,
          'touchcancel': onPanEnd
        }, dragEvents = {
          'mousedown': onPanStart,
          'mousemove': onPanMove,
          'mouseup': onPanEnd,
          'mouseleave': onPanEnd
        },
        hasControls = hasOption('controls'),
        hasNav = hasOption('nav'),
        navAsThumbnails = autoWidth ? true : options.navAsThumbnails,
        hasAutoplay = hasOption('autoplay'),
        hasTouch = hasOption('touch'),
        hasMouseDrag = hasOption('mouseDrag'),
        slideActiveClass = 'tns-slide-active',
        slideClonedClass = 'tns-slide-cloned',
        imgCompleteClass = 'tns-complete',
        imgEvents = {
          'load': onImgLoaded,
          'error': onImgFailed
        },
        imgsComplete,
        liveregionCurrent,
        preventScroll = options.preventScrollOnTouch === 'force' ? true : false;

    // controls
    if (hasControls) {
      var controlsContainer = options.controlsContainer,
          controlsContainerHTML = options.controlsContainer ? options.controlsContainer.outerHTML : '',
          prevButton = options.prevButton,
          nextButton = options.nextButton,
          prevButtonHTML = options.prevButton ? options.prevButton.outerHTML : '',
          nextButtonHTML = options.nextButton ? options.nextButton.outerHTML : '',
          prevIsButton,
          nextIsButton;
    }

    // nav
    if (hasNav) {
      var navContainer = options.navContainer,
          navContainerHTML = options.navContainer ? options.navContainer.outerHTML : '',
          navItems,
          pages = autoWidth ? slideCount : getPages(),
          pagesCached = 0,
          navClicked = -1,
          navCurrentIndex = getCurrentNavIndex(),
          navCurrentIndexCached = navCurrentIndex,
          navActiveClass = 'tns-nav-active',
          navStr = 'Carousel Page ',
          navStrCurrent = ' (Current Slide)';
    }

    // autoplay
    if (hasAutoplay) {
      var autoplayDirection = options.autoplayDirection === 'forward' ? 1 : -1,
          autoplayButton = options.autoplayButton,
          autoplayButtonHTML = options.autoplayButton ? options.autoplayButton.outerHTML : '',
          autoplayHtmlStrings = ['<span class=\'tns-visually-hidden\'>', ' animation</span>'],
          autoplayTimer,
          animating,
          autoplayHoverPaused,
          autoplayUserPaused,
          autoplayVisibilityPaused;
    }

    if (hasTouch || hasMouseDrag) {
      var initPosition = {},
          lastPosition = {},
          translateInit,
          panStart = false,
          rafIndex,
          getDist = horizontal ?
            function(a, b) { return a.x - b.x; } :
            function(a, b) { return a.y - b.y; };
    }

    // disable slider when slidecount <= items
    if (!autoWidth) { resetVariblesWhenDisable(disable || freeze); }

    if (TRANSFORM) {
      transformAttr = TRANSFORM;
      transformPrefix = 'translate';

      if (HAS3DTRANSFORMS) {
        transformPrefix += horizontal ? '3d(' : '3d(0px, ';
        transformPostfix = horizontal ? ', 0px, 0px)' : ', 0px)';
      } else {
        transformPrefix += horizontal ? 'X(' : 'Y(';
        transformPostfix = ')';
      }

    }

    if (carousel) { container.className = container.className.replace('tns-vpfix', ''); }
    initStructure();
    initSheet();
    initSliderTransform();

    // === COMMON FUNCTIONS === //
    function resetVariblesWhenDisable (condition) {
      if (condition) {
        controls = nav = touch = mouseDrag = arrowKeys = autoplay = autoplayHoverPause = autoplayResetOnVisibility = false;
      }
    }

    function getCurrentSlide () {
      var tem = carousel ? index - cloneCount : index;
      while (tem < 0) { tem += slideCount; }
      return tem%slideCount + 1;
    }

    function getStartIndex (ind) {
      ind = ind ? Math.max(0, Math.min(loop ? slideCount - 1 : slideCount - items, ind)) : 0;
      return carousel ? ind + cloneCount : ind;
    }

    function getAbsIndex (i) {
      if (i == null) { i = index; }

      if (carousel) { i -= cloneCount; }
      while (i < 0) { i += slideCount; }

      return Math.floor(i%slideCount);
    }

    function getCurrentNavIndex () {
      var absIndex = getAbsIndex(),
          result;

      result = navAsThumbnails ? absIndex :
        fixedWidth || autoWidth ? Math.ceil((absIndex + 1) * pages / slideCount - 1) :
            Math.floor(absIndex / items);

      // set active nav to the last one when reaches the right edge
      if (!loop && carousel && index === indexMax) { result = pages - 1; }

      return result;
    }

    function getItemsMax () {
      // fixedWidth or autoWidth while viewportMax is not available
      if (autoWidth || (fixedWidth && !viewportMax)) {
        return slideCount - 1;
      // most cases
      } else {
        var str = fixedWidth ? 'fixedWidth' : 'items',
            arr = [];

        if (fixedWidth || options[str] < slideCount) { arr.push(options[str]); }

        if (responsive) {
          for (var bp in responsive) {
            var tem = responsive[bp][str];
            if (tem && (fixedWidth || tem < slideCount)) { arr.push(tem); }
          }
        }

        if (!arr.length) { arr.push(0); }

        return Math.ceil(fixedWidth ? viewportMax / Math.min.apply(null, arr) : Math.max.apply(null, arr));
      }
    }

    function getCloneCountForLoop () {
      var itemsMax = getItemsMax(),
          result = carousel ? Math.ceil((itemsMax * 5 - slideCount)/2) : (itemsMax * 4 - slideCount);
      result = Math.max(itemsMax, result);

      return hasOption('edgePadding') ? result + 1 : result;
    }

    function getWindowWidth () {
      return win.innerWidth || doc.documentElement.clientWidth || doc.body.clientWidth;
    }

    function getInsertPosition (pos) {
      return pos === 'top' ? 'afterbegin' : 'beforeend';
    }

    function getClientWidth (el) {
      if (el == null) { return; }
      var div = doc.createElement('div'), rect, width;
      el.appendChild(div);
      rect = div.getBoundingClientRect();
      width = rect.right - rect.left;
      div.remove();
      return width || getClientWidth(el.parentNode);
    }

    function getViewportWidth () {
      var gap = edgePadding ? edgePadding * 2 - gutter : 0;
      return getClientWidth(containerParent) - gap;
    }

    function hasOption (item) {
      if (options[item]) {
        return true;
      } else {
        if (responsive) {
          for (var bp in responsive) {
            if (responsive[bp][item]) { return true; }
          }
        }
        return false;
      }
    }

    // get option:
    // fixed width: viewport, fixedWidth, gutter => items
    // others: window width => all variables
    // all: items => slideBy
    function getOption (item, ww) {
      if (ww == null) { ww = windowWidth; }

      if (item === 'items' && fixedWidth) {
        return Math.floor((viewport + gutter) / (fixedWidth + gutter)) || 1;

      } else {
        var result = options[item];

        if (responsive) {
          for (var bp in responsive) {
            // bp: convert string to number
            if (ww >= parseInt(bp)) {
              if (item in responsive[bp]) { result = responsive[bp][item]; }
            }
          }
        }

        if (item === 'slideBy' && result === 'page') { result = getOption('items'); }
        if (!carousel && (item === 'slideBy' || item === 'items')) { result = Math.floor(result); }

        return result;
      }
    }

    function getSlideMarginLeft (i) {
      return CALC ?
        CALC + '(' + i * 100 + '% / ' + slideCountNew + ')' :
        i * 100 / slideCountNew + '%';
    }

    function getInnerWrapperStyles (edgePaddingTem, gutterTem, fixedWidthTem, speedTem, autoHeightBP) {
      var str = '';

      if (edgePaddingTem !== undefined) {
        var gap = edgePaddingTem;
        if (gutterTem) { gap -= gutterTem; }
        str = horizontal ?
          'margin: 0 ' + gap + 'px 0 ' + edgePaddingTem + 'px;' :
          'margin: ' + edgePaddingTem + 'px 0 ' + gap + 'px 0;';
      } else if (gutterTem && !fixedWidthTem) {
        var gutterTemUnit = '-' + gutterTem + 'px',
            dir = horizontal ? gutterTemUnit + ' 0 0' : '0 ' + gutterTemUnit + ' 0';
        str = 'margin: 0 ' + dir + ';';
      }

      if (!carousel && autoHeightBP && TRANSITIONDURATION && speedTem) { str += getTransitionDurationStyle(speedTem); }
      return str;
    }

    function getContainerWidth (fixedWidthTem, gutterTem, itemsTem) {
      if (fixedWidthTem) {
        return (fixedWidthTem + gutterTem) * slideCountNew + 'px';
      } else {
        return CALC ?
          CALC + '(' + slideCountNew * 100 + '% / ' + itemsTem + ')' :
          slideCountNew * 100 / itemsTem + '%';
      }
    }

    function getSlideWidthStyle (fixedWidthTem, gutterTem, itemsTem) {
      var width;

      if (fixedWidthTem) {
        width = (fixedWidthTem + gutterTem) + 'px';
      } else {
        if (!carousel) { itemsTem = Math.floor(itemsTem); }
        var dividend = carousel ? slideCountNew : itemsTem;
        width = CALC ?
          CALC + '(100% / ' + dividend + ')' :
          100 / dividend + '%';
      }

      width = 'width:' + width;

      // inner slider: overwrite outer slider styles
      return nested !== 'inner' ? width + ';' : width + ' !important;';
    }

    function getSlideGutterStyle (gutterTem) {
      var str = '';

      // gutter maybe interger || 0
      // so can't use 'if (gutter)'
      if (gutterTem !== false) {
        var prop = horizontal ? 'padding-' : 'margin-',
            dir = horizontal ? 'right' : 'bottom';
        str = prop +  dir + ': ' + gutterTem + 'px;';
      }

      return str;
    }

    function getCSSPrefix (name, num) {
      var prefix = name.substring(0, name.length - num).toLowerCase();
      if (prefix) { prefix = '-' + prefix + '-'; }

      return prefix;
    }

    function getTransitionDurationStyle (speed) {
      return getCSSPrefix(TRANSITIONDURATION, 18) + 'transition-duration:' + speed / 1000 + 's;';
    }

    function getAnimationDurationStyle (speed) {
      return getCSSPrefix(ANIMATIONDURATION, 17) + 'animation-duration:' + speed / 1000 + 's;';
    }

    function initStructure () {
      var classOuter = 'tns-outer',
          classInner = 'tns-inner';
          hasOption('gutter');

      outerWrapper.className = classOuter;
      innerWrapper.className = classInner;
      outerWrapper.id = slideId + '-ow';
      innerWrapper.id = slideId + '-iw';

      // set container properties
      if (container.id === '') { container.id = slideId; }
      newContainerClasses += PERCENTAGELAYOUT || autoWidth ? ' tns-subpixel' : ' tns-no-subpixel';
      newContainerClasses += CALC ? ' tns-calc' : ' tns-no-calc';
      if (autoWidth) { newContainerClasses += ' tns-autowidth'; }
      newContainerClasses += ' tns-' + options.axis;
      container.className += newContainerClasses;

      // add constrain layer for carousel
      if (carousel) {
        middleWrapper = doc.createElement('div');
        middleWrapper.id = slideId + '-mw';
        middleWrapper.className = 'tns-ovh';

        outerWrapper.appendChild(middleWrapper);
        middleWrapper.appendChild(innerWrapper);
      } else {
        outerWrapper.appendChild(innerWrapper);
      }

      if (autoHeight) {
        var wp = middleWrapper ? middleWrapper : innerWrapper;
        wp.className += ' tns-ah';
      }

      containerParent.insertBefore(outerWrapper, container);
      innerWrapper.appendChild(container);

      // add id, class, aria attributes
      // before clone slides
      forEach(slideItems, function(item, i) {
        addClass(item, 'tns-item');
        if (!item.id) { item.id = slideId + '-item' + i; }
        if (!carousel && animateNormal) { addClass(item, animateNormal); }
        setAttrs(item, {
          'aria-hidden': 'true',
          'tabindex': '-1'
        });
      });

      // ## clone slides
      // carousel: n + slides + n
      // gallery:      slides + n
      if (cloneCount) {
        var fragmentBefore = doc.createDocumentFragment(),
            fragmentAfter = doc.createDocumentFragment();

        for (var j = cloneCount; j--;) {
          var num = j%slideCount,
              cloneFirst = slideItems[num].cloneNode(true);
          addClass(cloneFirst, slideClonedClass);
          removeAttrs(cloneFirst, 'id');
          fragmentAfter.insertBefore(cloneFirst, fragmentAfter.firstChild);

          if (carousel) {
            var cloneLast = slideItems[slideCount - 1 - num].cloneNode(true);
            addClass(cloneLast, slideClonedClass);
            removeAttrs(cloneLast, 'id');
            fragmentBefore.appendChild(cloneLast);
          }
        }

        container.insertBefore(fragmentBefore, container.firstChild);
        container.appendChild(fragmentAfter);
        slideItems = container.children;
      }

    }

    function initSliderTransform () {
      // ## images loaded/failed
      if (hasOption('autoHeight') || autoWidth || !horizontal) {
        var imgs = container.querySelectorAll('img');

        // add img load event listener
        forEach(imgs, function(img) {
          var src = img.src;

          if (!lazyload) {
            // not data img
            if (src && src.indexOf('data:image') < 0) {
              img.src = '';
              addEvents(img, imgEvents);
              addClass(img, 'loading');

              img.src = src;
            // data img
            } else {
              imgLoaded(img);
            }
          }
        });

        // set imgsComplete
        raf(function(){ imgsLoadedCheck(arrayFromNodeList(imgs), function() { imgsComplete = true; }); });

        // reset imgs for auto height: check visible imgs only
        if (hasOption('autoHeight')) { imgs = getImageArray(index, Math.min(index + items - 1, slideCountNew - 1)); }

        lazyload ? initSliderTransformStyleCheck() : raf(function(){ imgsLoadedCheck(arrayFromNodeList(imgs), initSliderTransformStyleCheck); });

      } else {
        // set container transform property
        if (carousel) { doContainerTransformSilent(); }

        // update slider tools and events
        initTools();
        initEvents();
      }
    }

    function initSliderTransformStyleCheck () {
      if (autoWidth && slideCount > 1) {
        // check styles application
        var num = loop ? index : slideCount - 1;

        (function stylesApplicationCheck() {
          var left = slideItems[num].getBoundingClientRect().left;
          var right = slideItems[num - 1].getBoundingClientRect().right;

          (Math.abs(left - right) <= 1) ?
            initSliderTransformCore() :
            setTimeout(function(){ stylesApplicationCheck(); }, 16);
        })();

      } else {
        initSliderTransformCore();
      }
    }


    function initSliderTransformCore () {
      // run Fn()s which are rely on image loading
      if (!horizontal || autoWidth) {
        setSlidePositions();

        if (autoWidth) {
          rightBoundary = getRightBoundary();
          if (freezable) { freeze = getFreeze(); }
          indexMax = getIndexMax(); // <= slidePositions, rightBoundary <=
          resetVariblesWhenDisable(disable || freeze);
        } else {
          updateContentWrapperHeight();
        }
      }

      // set container transform property
      if (carousel) { doContainerTransformSilent(); }

      // update slider tools and events
      initTools();
      initEvents();
    }

    function initSheet () {
      // gallery:
      // set animation classes and left value for gallery slider
      if (!carousel) {
        for (var i = index, l = index + Math.min(slideCount, items); i < l; i++) {
          var item = slideItems[i];
          item.style.left = (i - index) * 100 / items + '%';
          addClass(item, animateIn);
          removeClass(item, animateNormal);
        }
      }

      // #### LAYOUT

      // ## INLINE-BLOCK VS FLOAT

      // ## PercentageLayout:
      // slides: inline-block
      // remove blank space between slides by set font-size: 0

      // ## Non PercentageLayout:
      // slides: float
      //         margin-right: -100%
      //         margin-left: ~

      // Resource: https://docs.google.com/spreadsheets/d/147up245wwTXeQYve3BRSAD4oVcvQmuGsFteJOeA5xNQ/edit?usp=sharing
      if (horizontal) {
        if (PERCENTAGELAYOUT || autoWidth) {
          addCSSRule(sheet, '#' + slideId + ' > .tns-item', 'font-size:' + win.getComputedStyle(slideItems[0]).fontSize + ';', getCssRulesLength(sheet));
          addCSSRule(sheet, '#' + slideId, 'font-size:0;', getCssRulesLength(sheet));
        } else if (carousel) {
          forEach(slideItems, function (slide, i) {
            slide.style.marginLeft = getSlideMarginLeft(i);
          });
        }
      }


      // ## BASIC STYLES
      if (CSSMQ) {
        // middle wrapper style
        if (TRANSITIONDURATION) {
          var str = middleWrapper && options.autoHeight ? getTransitionDurationStyle(options.speed) : '';
          addCSSRule(sheet, '#' + slideId + '-mw', str, getCssRulesLength(sheet));
        }

        // inner wrapper styles
        str = getInnerWrapperStyles(options.edgePadding, options.gutter, options.fixedWidth, options.speed, options.autoHeight);
        addCSSRule(sheet, '#' + slideId + '-iw', str, getCssRulesLength(sheet));

        // container styles
        if (carousel) {
          str = horizontal && !autoWidth ? 'width:' + getContainerWidth(options.fixedWidth, options.gutter, options.items) + ';' : '';
          if (TRANSITIONDURATION) { str += getTransitionDurationStyle(speed); }
          addCSSRule(sheet, '#' + slideId, str, getCssRulesLength(sheet));
        }

        // slide styles
        str = horizontal && !autoWidth ? getSlideWidthStyle(options.fixedWidth, options.gutter, options.items) : '';
        if (options.gutter) { str += getSlideGutterStyle(options.gutter); }
        // set gallery items transition-duration
        if (!carousel) {
          if (TRANSITIONDURATION) { str += getTransitionDurationStyle(speed); }
          if (ANIMATIONDURATION) { str += getAnimationDurationStyle(speed); }
        }
        if (str) { addCSSRule(sheet, '#' + slideId + ' > .tns-item', str, getCssRulesLength(sheet)); }

      // non CSS mediaqueries: IE8
      // ## update inner wrapper, container, slides if needed
      // set inline styles for inner wrapper & container
      // insert stylesheet (one line) for slides only (since slides are many)
      } else {
        // middle wrapper styles
        update_carousel_transition_duration();

        // inner wrapper styles
        innerWrapper.style.cssText = getInnerWrapperStyles(edgePadding, gutter, fixedWidth, autoHeight);

        // container styles
        if (carousel && horizontal && !autoWidth) {
          container.style.width = getContainerWidth(fixedWidth, gutter, items);
        }

        // slide styles
        var str = horizontal && !autoWidth ? getSlideWidthStyle(fixedWidth, gutter, items) : '';
        if (gutter) { str += getSlideGutterStyle(gutter); }

        // append to the last line
        if (str) { addCSSRule(sheet, '#' + slideId + ' > .tns-item', str, getCssRulesLength(sheet)); }
      }

      // ## MEDIAQUERIES
      if (responsive && CSSMQ) {
        for (var bp in responsive) {
          // bp: convert string to number
          bp = parseInt(bp);

          var opts = responsive[bp],
              str = '',
              middleWrapperStr = '',
              innerWrapperStr = '',
              containerStr = '',
              slideStr = '',
              itemsBP = !autoWidth ? getOption('items', bp) : null,
              fixedWidthBP = getOption('fixedWidth', bp),
              speedBP = getOption('speed', bp),
              edgePaddingBP = getOption('edgePadding', bp),
              autoHeightBP = getOption('autoHeight', bp),
              gutterBP = getOption('gutter', bp);

          // middle wrapper string
          if (TRANSITIONDURATION && middleWrapper && getOption('autoHeight', bp) && 'speed' in opts) {
            middleWrapperStr = '#' + slideId + '-mw{' + getTransitionDurationStyle(speedBP) + '}';
          }

          // inner wrapper string
          if ('edgePadding' in opts || 'gutter' in opts) {
            innerWrapperStr = '#' + slideId + '-iw{' + getInnerWrapperStyles(edgePaddingBP, gutterBP, fixedWidthBP, speedBP, autoHeightBP) + '}';
          }

          // container string
          if (carousel && horizontal && !autoWidth && ('fixedWidth' in opts || 'items' in opts || (fixedWidth && 'gutter' in opts))) {
            containerStr = 'width:' + getContainerWidth(fixedWidthBP, gutterBP, itemsBP) + ';';
          }
          if (TRANSITIONDURATION && 'speed' in opts) {
            containerStr += getTransitionDurationStyle(speedBP);
          }
          if (containerStr) {
            containerStr = '#' + slideId + '{' + containerStr + '}';
          }

          // slide string
          if ('fixedWidth' in opts || (fixedWidth && 'gutter' in opts) || !carousel && 'items' in opts) {
            slideStr += getSlideWidthStyle(fixedWidthBP, gutterBP, itemsBP);
          }
          if ('gutter' in opts) {
            slideStr += getSlideGutterStyle(gutterBP);
          }
          // set gallery items transition-duration
          if (!carousel && 'speed' in opts) {
            if (TRANSITIONDURATION) { slideStr += getTransitionDurationStyle(speedBP); }
            if (ANIMATIONDURATION) { slideStr += getAnimationDurationStyle(speedBP); }
          }
          if (slideStr) { slideStr = '#' + slideId + ' > .tns-item{' + slideStr + '}'; }

          // add up
          str = middleWrapperStr + innerWrapperStr + containerStr + slideStr;

          if (str) {
            sheet.insertRule('@media (min-width: ' + bp / 16 + 'em) {' + str + '}', sheet.cssRules.length);
          }
        }
      }
    }

    function initTools () {
      // == slides ==
      updateSlideStatus();

      // == live region ==
      outerWrapper.insertAdjacentHTML('afterbegin', '<div class="tns-liveregion tns-visually-hidden" aria-live="polite" aria-atomic="true">slide <span class="current">' + getLiveRegionStr() + '</span>  of ' + slideCount + '</div>');
      liveregionCurrent = outerWrapper.querySelector('.tns-liveregion .current');

      // == autoplayInit ==
      if (hasAutoplay) {
        var txt = autoplay ? 'stop' : 'start';
        if (autoplayButton) {
          setAttrs(autoplayButton, {'data-action': txt});
        } else if (options.autoplayButtonOutput) {
          outerWrapper.insertAdjacentHTML(getInsertPosition(options.autoplayPosition), '<button type="button" data-action="' + txt + '">' + autoplayHtmlStrings[0] + txt + autoplayHtmlStrings[1] + autoplayText[0] + '</button>');
          autoplayButton = outerWrapper.querySelector('[data-action]');
        }

        // add event
        if (autoplayButton) {
          addEvents(autoplayButton, {'click': toggleAutoplay});
        }

        if (autoplay) {
          startAutoplay();
          if (autoplayHoverPause) { addEvents(container, hoverEvents); }
          if (autoplayResetOnVisibility) { addEvents(container, visibilityEvent); }
        }
      }

      // == navInit ==
      if (hasNav) {
        // customized nav
        // will not hide the navs in case they're thumbnails
        if (navContainer) {
          setAttrs(navContainer, {'aria-label': 'Carousel Pagination'});
          navItems = navContainer.children;
          forEach(navItems, function(item, i) {
            setAttrs(item, {
              'data-nav': i,
              'tabindex': '-1',
              'aria-label': navStr + (i + 1),
              'aria-controls': slideId,
            });
          });

        // generated nav
        } else {
          var navHtml = '',
              hiddenStr = navAsThumbnails ? '' : 'style="display:none"';
          for (var i = 0; i < slideCount; i++) {
            // hide nav items by default
            navHtml += '<button type="button" data-nav="' + i +'" tabindex="-1" aria-controls="' + slideId + '" ' + hiddenStr + ' aria-label="' + navStr + (i + 1) +'"></button>';
          }
          navHtml = '<div class="tns-nav" aria-label="Carousel Pagination">' + navHtml + '</div>';
          outerWrapper.insertAdjacentHTML(getInsertPosition(options.navPosition), navHtml);

          navContainer = outerWrapper.querySelector('.tns-nav');
          navItems = navContainer.children;
        }

        updateNavVisibility();

        // add transition
        if (TRANSITIONDURATION) {
          var prefix = TRANSITIONDURATION.substring(0, TRANSITIONDURATION.length - 18).toLowerCase(),
              str = 'transition: all ' + speed / 1000 + 's';

          if (prefix) {
            str = '-' + prefix + '-' + str;
          }

          addCSSRule(sheet, '[aria-controls^=' + slideId + '-item]', str, getCssRulesLength(sheet));
        }

        setAttrs(navItems[navCurrentIndex], {'aria-label': navStr + (navCurrentIndex + 1) + navStrCurrent});
        removeAttrs(navItems[navCurrentIndex], 'tabindex');
        addClass(navItems[navCurrentIndex], navActiveClass);

        // add events
        addEvents(navContainer, navEvents);
      }



      // == controlsInit ==
      if (hasControls) {
        if (!controlsContainer && (!prevButton || !nextButton)) {
          outerWrapper.insertAdjacentHTML(getInsertPosition(options.controlsPosition), '<div class="tns-controls" aria-label="Carousel Navigation" tabindex="0"><button type="button" data-controls="prev" tabindex="-1" aria-controls="' + slideId +'">' + controlsText[0] + '</button><button type="button" data-controls="next" tabindex="-1" aria-controls="' + slideId +'">' + controlsText[1] + '</button></div>');

          controlsContainer = outerWrapper.querySelector('.tns-controls');
        }

        if (!prevButton || !nextButton) {
          prevButton = controlsContainer.children[0];
          nextButton = controlsContainer.children[1];
        }

        if (options.controlsContainer) {
          setAttrs(controlsContainer, {
            'aria-label': 'Carousel Navigation',
            'tabindex': '0'
          });
        }

        if (options.controlsContainer || (options.prevButton && options.nextButton)) {
          setAttrs([prevButton, nextButton], {
            'aria-controls': slideId,
            'tabindex': '-1',
          });
        }

        if (options.controlsContainer || (options.prevButton && options.nextButton)) {
          setAttrs(prevButton, {'data-controls' : 'prev'});
          setAttrs(nextButton, {'data-controls' : 'next'});
        }

        prevIsButton = isButton(prevButton);
        nextIsButton = isButton(nextButton);

        updateControlsStatus();

        // add events
        if (controlsContainer) {
          addEvents(controlsContainer, controlsEvents);
        } else {
          addEvents(prevButton, controlsEvents);
          addEvents(nextButton, controlsEvents);
        }
      }

      // hide tools if needed
      disableUI();
    }

    function initEvents () {
      // add events
      if (carousel && TRANSITIONEND) {
        var eve = {};
        eve[TRANSITIONEND] = onTransitionEnd;
        addEvents(container, eve);
      }

      if (touch) { addEvents(container, touchEvents, options.preventScrollOnTouch); }
      if (mouseDrag) { addEvents(container, dragEvents); }
      if (arrowKeys) { addEvents(doc, docmentKeydownEvent); }

      if (nested === 'inner') {
        events.on('outerResized', function () {
          resizeTasks();
          events.emit('innerLoaded', info());
        });
      } else if (responsive || fixedWidth || autoWidth || autoHeight || !horizontal) {
        addEvents(win, {'resize': onResize});
      }

      if (autoHeight) {
        if (nested === 'outer') {
          events.on('innerLoaded', doAutoHeight);
        } else if (!disable) { doAutoHeight(); }
      }

      doLazyLoad();
      if (disable) { disableSlider(); } else if (freeze) { freezeSlider(); }

      events.on('indexChanged', additionalUpdates);
      if (nested === 'inner') { events.emit('innerLoaded', info()); }
      if (typeof onInit === 'function') { onInit(info()); }
      isOn = true;
    }

    function destroy () {
      // sheet
      sheet.disabled = true;
      if (sheet.ownerNode) { sheet.ownerNode.remove(); }

      // remove win event listeners
      removeEvents(win, {'resize': onResize});

      // arrowKeys, controls, nav
      if (arrowKeys) { removeEvents(doc, docmentKeydownEvent); }
      if (controlsContainer) { removeEvents(controlsContainer, controlsEvents); }
      if (navContainer) { removeEvents(navContainer, navEvents); }

      // autoplay
      removeEvents(container, hoverEvents);
      removeEvents(container, visibilityEvent);
      if (autoplayButton) { removeEvents(autoplayButton, {'click': toggleAutoplay}); }
      if (autoplay) { clearInterval(autoplayTimer); }

      // container
      if (carousel && TRANSITIONEND) {
        var eve = {};
        eve[TRANSITIONEND] = onTransitionEnd;
        removeEvents(container, eve);
      }
      if (touch) { removeEvents(container, touchEvents); }
      if (mouseDrag) { removeEvents(container, dragEvents); }

      // cache Object values in options && reset HTML
      var htmlList = [containerHTML, controlsContainerHTML, prevButtonHTML, nextButtonHTML, navContainerHTML, autoplayButtonHTML];

      tnsList.forEach(function(item, i) {
        var el = item === 'container' ? outerWrapper : options[item];

        if (typeof el === 'object' && el) {
          var prevEl = el.previousElementSibling ? el.previousElementSibling : false,
              parentEl = el.parentNode;
          el.outerHTML = htmlList[i];
          options[item] = prevEl ? prevEl.nextElementSibling : parentEl.firstElementChild;
        }
      });


      // reset variables
      tnsList = animateIn = animateOut = animateDelay = animateNormal = horizontal = outerWrapper = innerWrapper = container = containerParent = containerHTML = slideItems = slideCount = breakpointZone = windowWidth = autoWidth = fixedWidth = edgePadding = gutter = viewport = items = slideBy = viewportMax = arrowKeys = speed = rewind = loop = autoHeight = sheet = lazyload = slidePositions = slideItemsOut = cloneCount = slideCountNew = hasRightDeadZone = rightBoundary = updateIndexBeforeTransform = transformAttr = transformPrefix = transformPostfix = getIndexMax = index = indexCached = indexMin = indexMax = swipeAngle = moveDirectionExpected = running = onInit = events = newContainerClasses = slideId = disable = disabled = freezable = freeze = frozen = controlsEvents = navEvents = hoverEvents = visibilityEvent = docmentKeydownEvent = touchEvents = dragEvents = hasControls = hasNav = navAsThumbnails = hasAutoplay = hasTouch = hasMouseDrag = slideActiveClass = imgCompleteClass = imgEvents = imgsComplete = controls = controlsText = controlsContainer = controlsContainerHTML = prevButton = nextButton = prevIsButton = nextIsButton = nav = navContainer = navContainerHTML = navItems = pages = pagesCached = navClicked = navCurrentIndex = navCurrentIndexCached = navActiveClass = navStr = navStrCurrent = autoplay = autoplayTimeout = autoplayDirection = autoplayText = autoplayHoverPause = autoplayButton = autoplayButtonHTML = autoplayResetOnVisibility = autoplayHtmlStrings = autoplayTimer = animating = autoplayHoverPaused = autoplayUserPaused = autoplayVisibilityPaused = initPosition = lastPosition = translateInit = panStart = rafIndex = getDist = touch = mouseDrag = null;
      // check variables
      // [animateIn, animateOut, animateDelay, animateNormal, horizontal, outerWrapper, innerWrapper, container, containerParent, containerHTML, slideItems, slideCount, breakpointZone, windowWidth, autoWidth, fixedWidth, edgePadding, gutter, viewport, items, slideBy, viewportMax, arrowKeys, speed, rewind, loop, autoHeight, sheet, lazyload, slidePositions, slideItemsOut, cloneCount, slideCountNew, hasRightDeadZone, rightBoundary, updateIndexBeforeTransform, transformAttr, transformPrefix, transformPostfix, getIndexMax, index, indexCached, indexMin, indexMax, resizeTimer, swipeAngle, moveDirectionExpected, running, onInit, events, newContainerClasses, slideId, disable, disabled, freezable, freeze, frozen, controlsEvents, navEvents, hoverEvents, visibilityEvent, docmentKeydownEvent, touchEvents, dragEvents, hasControls, hasNav, navAsThumbnails, hasAutoplay, hasTouch, hasMouseDrag, slideActiveClass, imgCompleteClass, imgEvents, imgsComplete, controls, controlsText, controlsContainer, controlsContainerHTML, prevButton, nextButton, prevIsButton, nextIsButton, nav, navContainer, navContainerHTML, navItems, pages, pagesCached, navClicked, navCurrentIndex, navCurrentIndexCached, navActiveClass, navStr, navStrCurrent, autoplay, autoplayTimeout, autoplayDirection, autoplayText, autoplayHoverPause, autoplayButton, autoplayButtonHTML, autoplayResetOnVisibility, autoplayHtmlStrings, autoplayTimer, animating, autoplayHoverPaused, autoplayUserPaused, autoplayVisibilityPaused, initPosition, lastPosition, translateInit, disX, disY, panStart, rafIndex, getDist, touch, mouseDrag ].forEach(function(item) { if (item !== null) { console.log(item); } });

      for (var a in this) {
        if (a !== 'rebuild') { this[a] = null; }
      }
      isOn = false;
    }

  // === ON RESIZE ===
    // responsive || fixedWidth || autoWidth || !horizontal
    function onResize (e) {
      raf(function(){ resizeTasks(getEvent(e)); });
    }

    function resizeTasks (e) {
      if (!isOn) { return; }
      if (nested === 'outer') { events.emit('outerResized', info(e)); }
      windowWidth = getWindowWidth();
      var bpChanged,
          breakpointZoneTem = breakpointZone,
          needContainerTransform = false;

      if (responsive) {
        setBreakpointZone();
        bpChanged = breakpointZoneTem !== breakpointZone;
        // if (hasRightDeadZone) { needContainerTransform = true; } // *?
        if (bpChanged) { events.emit('newBreakpointStart', info(e)); }
      }

      var indChanged,
          itemsChanged,
          itemsTem = items,
          disableTem = disable,
          freezeTem = freeze,
          arrowKeysTem = arrowKeys,
          controlsTem = controls,
          navTem = nav,
          touchTem = touch,
          mouseDragTem = mouseDrag,
          autoplayTem = autoplay,
          autoplayHoverPauseTem = autoplayHoverPause,
          autoplayResetOnVisibilityTem = autoplayResetOnVisibility,
          indexTem = index;

      if (bpChanged) {
        var fixedWidthTem = fixedWidth,
            autoHeightTem = autoHeight,
            controlsTextTem = controlsText,
            centerTem = center,
            autoplayTextTem = autoplayText;

        if (!CSSMQ) {
          var gutterTem = gutter,
              edgePaddingTem = edgePadding;
        }
      }

      // get option:
      // fixed width: viewport, fixedWidth, gutter => items
      // others: window width => all variables
      // all: items => slideBy
      arrowKeys = getOption('arrowKeys');
      controls = getOption('controls');
      nav = getOption('nav');
      touch = getOption('touch');
      center = getOption('center');
      mouseDrag = getOption('mouseDrag');
      autoplay = getOption('autoplay');
      autoplayHoverPause = getOption('autoplayHoverPause');
      autoplayResetOnVisibility = getOption('autoplayResetOnVisibility');

      if (bpChanged) {
        disable = getOption('disable');
        fixedWidth = getOption('fixedWidth');
        speed = getOption('speed');
        autoHeight = getOption('autoHeight');
        controlsText = getOption('controlsText');
        autoplayText = getOption('autoplayText');
        autoplayTimeout = getOption('autoplayTimeout');

        if (!CSSMQ) {
          edgePadding = getOption('edgePadding');
          gutter = getOption('gutter');
        }
      }
      // update options
      resetVariblesWhenDisable(disable);

      viewport = getViewportWidth(); // <= edgePadding, gutter
      if ((!horizontal || autoWidth) && !disable) {
        setSlidePositions();
        if (!horizontal) {
          updateContentWrapperHeight(); // <= setSlidePositions
          needContainerTransform = true;
        }
      }
      if (fixedWidth || autoWidth) {
        rightBoundary = getRightBoundary(); // autoWidth: <= viewport, slidePositions, gutter
                                            // fixedWidth: <= viewport, fixedWidth, gutter
        indexMax = getIndexMax(); // autoWidth: <= rightBoundary, slidePositions
                                  // fixedWidth: <= rightBoundary, fixedWidth, gutter
      }

      if (bpChanged || fixedWidth) {
        items = getOption('items');
        slideBy = getOption('slideBy');
        itemsChanged = items !== itemsTem;

        if (itemsChanged) {
          if (!fixedWidth && !autoWidth) { indexMax = getIndexMax(); } // <= items
          // check index before transform in case
          // slider reach the right edge then items become bigger
          updateIndex();
        }
      }

      if (bpChanged) {
        if (disable !== disableTem) {
          if (disable) {
            disableSlider();
          } else {
            enableSlider(); // <= slidePositions, rightBoundary, indexMax
          }
        }
      }

      if (freezable && (bpChanged || fixedWidth || autoWidth)) {
        freeze = getFreeze(); // <= autoWidth: slidePositions, gutter, viewport, rightBoundary
                              // <= fixedWidth: fixedWidth, gutter, rightBoundary
                              // <= others: items

        if (freeze !== freezeTem) {
          if (freeze) {
            doContainerTransform(getContainerTransformValue(getStartIndex(0)));
            freezeSlider();
          } else {
            unfreezeSlider();
            needContainerTransform = true;
          }
        }
      }

      resetVariblesWhenDisable(disable || freeze); // controls, nav, touch, mouseDrag, arrowKeys, autoplay, autoplayHoverPause, autoplayResetOnVisibility
      if (!autoplay) { autoplayHoverPause = autoplayResetOnVisibility = false; }

      if (arrowKeys !== arrowKeysTem) {
        arrowKeys ?
          addEvents(doc, docmentKeydownEvent) :
          removeEvents(doc, docmentKeydownEvent);
      }
      if (controls !== controlsTem) {
        if (controls) {
          if (controlsContainer) {
            showElement(controlsContainer);
          } else {
            if (prevButton) { showElement(prevButton); }
            if (nextButton) { showElement(nextButton); }
          }
        } else {
          if (controlsContainer) {
            hideElement(controlsContainer);
          } else {
            if (prevButton) { hideElement(prevButton); }
            if (nextButton) { hideElement(nextButton); }
          }
        }
      }
      if (nav !== navTem) {
        if (nav) {
          showElement(navContainer);
          updateNavVisibility();
        } else {
          hideElement(navContainer);
        }
      }
      if (touch !== touchTem) {
        touch ?
          addEvents(container, touchEvents, options.preventScrollOnTouch) :
          removeEvents(container, touchEvents);
      }
      if (mouseDrag !== mouseDragTem) {
        mouseDrag ?
          addEvents(container, dragEvents) :
          removeEvents(container, dragEvents);
      }
      if (autoplay !== autoplayTem) {
        if (autoplay) {
          if (autoplayButton) { showElement(autoplayButton); }
          if (!animating && !autoplayUserPaused) { startAutoplay(); }
        } else {
          if (autoplayButton) { hideElement(autoplayButton); }
          if (animating) { stopAutoplay(); }
        }
      }
      if (autoplayHoverPause !== autoplayHoverPauseTem) {
        autoplayHoverPause ?
          addEvents(container, hoverEvents) :
          removeEvents(container, hoverEvents);
      }
      if (autoplayResetOnVisibility !== autoplayResetOnVisibilityTem) {
        autoplayResetOnVisibility ?
          addEvents(doc, visibilityEvent) :
          removeEvents(doc, visibilityEvent);
      }

      if (bpChanged) {
        if (fixedWidth !== fixedWidthTem || center !== centerTem) { needContainerTransform = true; }

        if (autoHeight !== autoHeightTem) {
          if (!autoHeight) { innerWrapper.style.height = ''; }
        }

        if (controls && controlsText !== controlsTextTem) {
          prevButton.innerHTML = controlsText[0];
          nextButton.innerHTML = controlsText[1];
        }

        if (autoplayButton && autoplayText !== autoplayTextTem) {
          var i = autoplay ? 1 : 0,
              html = autoplayButton.innerHTML,
              len = html.length - autoplayTextTem[i].length;
          if (html.substring(len) === autoplayTextTem[i]) {
            autoplayButton.innerHTML = html.substring(0, len) + autoplayText[i];
          }
        }
      } else {
        if (center && (fixedWidth || autoWidth)) { needContainerTransform = true; }
      }

      if (itemsChanged || fixedWidth && !autoWidth) {
        pages = getPages();
        updateNavVisibility();
      }

      indChanged = index !== indexTem;
      if (indChanged) {
        events.emit('indexChanged', info());
        needContainerTransform = true;
      } else if (itemsChanged) {
        if (!indChanged) { additionalUpdates(); }
      } else if (fixedWidth || autoWidth) {
        doLazyLoad();
        updateSlideStatus();
        updateLiveRegion();
      }

      if (itemsChanged && !carousel) { updateGallerySlidePositions(); }

      if (!disable && !freeze) {
        // non-mediaqueries: IE8
        if (bpChanged && !CSSMQ) {
          // middle wrapper styles

          // inner wrapper styles
          if (edgePadding !== edgePaddingTem || gutter !== gutterTem) {
            innerWrapper.style.cssText = getInnerWrapperStyles(edgePadding, gutter, fixedWidth, speed, autoHeight);
          }

          if (horizontal) {
            // container styles
            if (carousel) {
              container.style.width = getContainerWidth(fixedWidth, gutter, items);
            }

            // slide styles
            var str = getSlideWidthStyle(fixedWidth, gutter, items) +
                      getSlideGutterStyle(gutter);

            // remove the last line and
            // add new styles
            removeCSSRule(sheet, getCssRulesLength(sheet) - 1);
            addCSSRule(sheet, '#' + slideId + ' > .tns-item', str, getCssRulesLength(sheet));
          }
        }

        // auto height
        if (autoHeight) { doAutoHeight(); }

        if (needContainerTransform) {
          doContainerTransformSilent();
          indexCached = index;
        }
      }

      if (bpChanged) { events.emit('newBreakpointEnd', info(e)); }
    }





    // === INITIALIZATION FUNCTIONS === //
    function getFreeze () {
      if (!fixedWidth && !autoWidth) {
        var a = center ? items - (items - 1) / 2 : items;
        return  slideCount <= a;
      }

      var width = fixedWidth ? (fixedWidth + gutter) * slideCount : slidePositions[slideCount],
          vp = edgePadding ? viewport + edgePadding * 2 : viewport + gutter;

      if (center) {
        vp -= fixedWidth ? (viewport - fixedWidth) / 2 : (viewport - (slidePositions[index + 1] - slidePositions[index] - gutter)) / 2;
      }

      return width <= vp;
    }

    function setBreakpointZone () {
      breakpointZone = 0;
      for (var bp in responsive) {
        bp = parseInt(bp); // convert string to number
        if (windowWidth >= bp) { breakpointZone = bp; }
      }
    }

    // (slideBy, indexMin, indexMax) => index
    var updateIndex = (function () {
      return loop ?
        carousel ?
          // loop + carousel
          function () {
            var leftEdge = indexMin,
                rightEdge = indexMax;

            leftEdge += slideBy;
            rightEdge -= slideBy;

            // adjust edges when has edge paddings
            // or fixed-width slider with extra space on the right side
            if (edgePadding) {
              leftEdge += 1;
              rightEdge -= 1;
            } else if (fixedWidth) {
              if ((viewport + gutter)%(fixedWidth + gutter)) { rightEdge -= 1; }
            }

            if (cloneCount) {
              if (index > rightEdge) {
                index -= slideCount;
              } else if (index < leftEdge) {
                index += slideCount;
              }
            }
          } :
          // loop + gallery
          function() {
            if (index > indexMax) {
              while (index >= indexMin + slideCount) { index -= slideCount; }
            } else if (index < indexMin) {
              while (index <= indexMax - slideCount) { index += slideCount; }
            }
          } :
        // non-loop
        function() {
          index = Math.max(indexMin, Math.min(indexMax, index));
        };
    })();

    function disableUI () {
      if (!autoplay && autoplayButton) { hideElement(autoplayButton); }
      if (!nav && navContainer) { hideElement(navContainer); }
      if (!controls) {
        if (controlsContainer) {
          hideElement(controlsContainer);
        } else {
          if (prevButton) { hideElement(prevButton); }
          if (nextButton) { hideElement(nextButton); }
        }
      }
    }

    function enableUI () {
      if (autoplay && autoplayButton) { showElement(autoplayButton); }
      if (nav && navContainer) { showElement(navContainer); }
      if (controls) {
        if (controlsContainer) {
          showElement(controlsContainer);
        } else {
          if (prevButton) { showElement(prevButton); }
          if (nextButton) { showElement(nextButton); }
        }
      }
    }

    function freezeSlider () {
      if (frozen) { return; }

      // remove edge padding from inner wrapper
      if (edgePadding) { innerWrapper.style.margin = '0px'; }

      // add class tns-transparent to cloned slides
      if (cloneCount) {
        var str = 'tns-transparent';
        for (var i = cloneCount; i--;) {
          if (carousel) { addClass(slideItems[i], str); }
          addClass(slideItems[slideCountNew - i - 1], str);
        }
      }

      // update tools
      disableUI();

      frozen = true;
    }

    function unfreezeSlider () {
      if (!frozen) { return; }

      // restore edge padding for inner wrapper
      // for mordern browsers
      if (edgePadding && CSSMQ) { innerWrapper.style.margin = ''; }

      // remove class tns-transparent to cloned slides
      if (cloneCount) {
        var str = 'tns-transparent';
        for (var i = cloneCount; i--;) {
          if (carousel) { removeClass(slideItems[i], str); }
          removeClass(slideItems[slideCountNew - i - 1], str);
        }
      }

      // update tools
      enableUI();

      frozen = false;
    }

    function disableSlider () {
      if (disabled) { return; }

      sheet.disabled = true;
      container.className = container.className.replace(newContainerClasses.substring(1), '');
      removeAttrs(container, ['style']);
      if (loop) {
        for (var j = cloneCount; j--;) {
          if (carousel) { hideElement(slideItems[j]); }
          hideElement(slideItems[slideCountNew - j - 1]);
        }
      }

      // vertical slider
      if (!horizontal || !carousel) { removeAttrs(innerWrapper, ['style']); }

      // gallery
      if (!carousel) {
        for (var i = index, l = index + slideCount; i < l; i++) {
          var item = slideItems[i];
          removeAttrs(item, ['style']);
          removeClass(item, animateIn);
          removeClass(item, animateNormal);
        }
      }

      // update tools
      disableUI();

      disabled = true;
    }

    function enableSlider () {
      if (!disabled) { return; }

      sheet.disabled = false;
      container.className += newContainerClasses;
      doContainerTransformSilent();

      if (loop) {
        for (var j = cloneCount; j--;) {
          if (carousel) { showElement(slideItems[j]); }
          showElement(slideItems[slideCountNew - j - 1]);
        }
      }

      // gallery
      if (!carousel) {
        for (var i = index, l = index + slideCount; i < l; i++) {
          var item = slideItems[i],
              classN = i < index + items ? animateIn : animateNormal;
          item.style.left = (i - index) * 100 / items + '%';
          addClass(item, classN);
        }
      }

      // update tools
      enableUI();

      disabled = false;
    }

    function updateLiveRegion () {
      var str = getLiveRegionStr();
      if (liveregionCurrent.innerHTML !== str) { liveregionCurrent.innerHTML = str; }
    }

    function getLiveRegionStr () {
      var arr = getVisibleSlideRange(),
          start = arr[0] + 1,
          end = arr[1] + 1;
      return start === end ? start + '' : start + ' to ' + end;
    }

    function getVisibleSlideRange (val) {
      if (val == null) { val = getContainerTransformValue(); }
      var start = index, end, rangestart, rangeend;

      // get range start, range end for autoWidth and fixedWidth
      if (center || edgePadding) {
        if (autoWidth || fixedWidth) {
          rangestart = - (parseFloat(val) + edgePadding);
          rangeend = rangestart + viewport + edgePadding * 2;
        }
      } else {
        if (autoWidth) {
          rangestart = slidePositions[index];
          rangeend = rangestart + viewport;
        }
      }

      // get start, end
      // - check auto width
      if (autoWidth) {
        slidePositions.forEach(function(point, i) {
          if (i < slideCountNew) {
            if ((center || edgePadding) && point <= rangestart + 0.5) { start = i; }
            if (rangeend - point >= 0.5) { end = i; }
          }
        });

      // - check percentage width, fixed width
      } else {

        if (fixedWidth) {
          var cell = fixedWidth + gutter;
          if (center || edgePadding) {
            start = Math.floor(rangestart/cell);
            end = Math.ceil(rangeend/cell - 1);
          } else {
            end = start + Math.ceil(viewport/cell) - 1;
          }

        } else {
          if (center || edgePadding) {
            var a = items - 1;
            if (center) {
              start -= a / 2;
              end = index + a / 2;
            } else {
              end = index + a;
            }

            if (edgePadding) {
              var b = edgePadding * items / viewport;
              start -= b;
              end += b;
            }

            start = Math.floor(start);
            end = Math.ceil(end);
          } else {
            end = start + items - 1;
          }
        }

        start = Math.max(start, 0);
        end = Math.min(end, slideCountNew - 1);
      }

      return [start, end];
    }

    function doLazyLoad () {
      if (lazyload && !disable) {
        var arg = getVisibleSlideRange();
        arg.push(lazyloadSelector);

        getImageArray.apply(null, arg).forEach(function (img) {
          if (!hasClass(img, imgCompleteClass)) {
            // stop propagation transitionend event to container
            var eve = {};
            eve[TRANSITIONEND] = function (e) { e.stopPropagation(); };
            addEvents(img, eve);

            addEvents(img, imgEvents);

            // update src
            img.src = getAttr(img, 'data-src');

            // update srcset
            var srcset = getAttr(img, 'data-srcset');
            if (srcset) { img.srcset = srcset; }

            addClass(img, 'loading');
          }
        });
      }
    }

    function onImgLoaded (e) {
      imgLoaded(getTarget(e));
    }

    function onImgFailed (e) {
      imgFailed(getTarget(e));
    }

    function imgLoaded (img) {
      addClass(img, 'loaded');
      imgCompleted(img);
    }

    function imgFailed (img) {
      addClass(img, 'failed');
      imgCompleted(img);
    }

    function imgCompleted (img) {
      addClass(img, imgCompleteClass);
      removeClass(img, 'loading');
      removeEvents(img, imgEvents);
    }

    function getImageArray (start, end, imgSelector) {
      var imgs = [];
      if (!imgSelector) { imgSelector = 'img'; }

      while (start <= end) {
        forEach(slideItems[start].querySelectorAll(imgSelector), function (img) { imgs.push(img); });
        start++;
      }

      return imgs;
    }

    // check if all visible images are loaded
    // and update container height if it's done
    function doAutoHeight () {
      var imgs = getImageArray.apply(null, getVisibleSlideRange());
      raf(function(){ imgsLoadedCheck(imgs, updateInnerWrapperHeight); });
    }

    function imgsLoadedCheck (imgs, cb) {
      // execute callback function if all images are complete
      if (imgsComplete) { return cb(); }

      // check image classes
      imgs.forEach(function (img, index) {
        if (!lazyload && img.complete) { imgCompleted(img); } // Check image.complete
        if (hasClass(img, imgCompleteClass)) { imgs.splice(index, 1); }
      });

      // execute callback function if selected images are all complete
      if (!imgs.length) { return cb(); }

      // otherwise execute this functiona again
      raf(function(){ imgsLoadedCheck(imgs, cb); });
    }

    function additionalUpdates () {
      doLazyLoad();
      updateSlideStatus();
      updateLiveRegion();
      updateControlsStatus();
      updateNavStatus();
    }


    function update_carousel_transition_duration () {
      if (carousel && autoHeight) {
        middleWrapper.style[TRANSITIONDURATION] = speed / 1000 + 's';
      }
    }

    function getMaxSlideHeight (slideStart, slideRange) {
      var heights = [];
      for (var i = slideStart, l = Math.min(slideStart + slideRange, slideCountNew); i < l; i++) {
        heights.push(slideItems[i].offsetHeight);
      }

      return Math.max.apply(null, heights);
    }

    // update inner wrapper height
    // 1. get the max-height of the visible slides
    // 2. set transitionDuration to speed
    // 3. update inner wrapper height to max-height
    // 4. set transitionDuration to 0s after transition done
    function updateInnerWrapperHeight () {
      var maxHeight = autoHeight ? getMaxSlideHeight(index, items) : getMaxSlideHeight(cloneCount, slideCount),
          wp = middleWrapper ? middleWrapper : innerWrapper;

      if (wp.style.height !== maxHeight) { wp.style.height = maxHeight + 'px'; }
    }

    // get the distance from the top edge of the first slide to each slide
    // (init) => slidePositions
    function setSlidePositions () {
      slidePositions = [0];
      var attr = horizontal ? 'left' : 'top',
          attr2 = horizontal ? 'right' : 'bottom',
          base = slideItems[0].getBoundingClientRect()[attr];

      forEach(slideItems, function(item, i) {
        // skip the first slide
        if (i) { slidePositions.push(item.getBoundingClientRect()[attr] - base); }
        // add the end edge
        if (i === slideCountNew - 1) { slidePositions.push(item.getBoundingClientRect()[attr2] - base); }
      });
    }

    // update slide
    function updateSlideStatus () {
      var range = getVisibleSlideRange(),
          start = range[0],
          end = range[1];

      forEach(slideItems, function(item, i) {
        // show slides
        if (i >= start && i <= end) {
          if (hasAttr(item, 'aria-hidden')) {
            removeAttrs(item, ['aria-hidden', 'tabindex']);
            addClass(item, slideActiveClass);
          }
        // hide slides
        } else {
          if (!hasAttr(item, 'aria-hidden')) {
            setAttrs(item, {
              'aria-hidden': 'true',
              'tabindex': '-1'
            });
            removeClass(item, slideActiveClass);
          }
        }
      });
    }

    // gallery: update slide position
    function updateGallerySlidePositions () {
      var l = index + Math.min(slideCount, items);
      for (var i = slideCountNew; i--;) {
        var item = slideItems[i];

        if (i >= index && i < l) {
          // add transitions to visible slides when adjusting their positions
          addClass(item, 'tns-moving');

          item.style.left = (i - index) * 100 / items + '%';
          addClass(item, animateIn);
          removeClass(item, animateNormal);
        } else if (item.style.left) {
          item.style.left = '';
          addClass(item, animateNormal);
          removeClass(item, animateIn);
        }

        // remove outlet animation
        removeClass(item, animateOut);
      }

      // removing '.tns-moving'
      setTimeout(function() {
        forEach(slideItems, function(el) {
          removeClass(el, 'tns-moving');
        });
      }, 300);
    }

    // set tabindex on Nav
    function updateNavStatus () {
      // get current nav
      if (nav) {
        navCurrentIndex = navClicked >= 0 ? navClicked : getCurrentNavIndex();
        navClicked = -1;

        if (navCurrentIndex !== navCurrentIndexCached) {
          var navPrev = navItems[navCurrentIndexCached],
              navCurrent = navItems[navCurrentIndex];

          setAttrs(navPrev, {
            'tabindex': '-1',
            'aria-label': navStr + (navCurrentIndexCached + 1)
          });
          removeClass(navPrev, navActiveClass);

          setAttrs(navCurrent, {'aria-label': navStr + (navCurrentIndex + 1) + navStrCurrent});
          removeAttrs(navCurrent, 'tabindex');
          addClass(navCurrent, navActiveClass);

          navCurrentIndexCached = navCurrentIndex;
        }
      }
    }

    function getLowerCaseNodeName (el) {
      return el.nodeName.toLowerCase();
    }

    function isButton (el) {
      return getLowerCaseNodeName(el) === 'button';
    }

    function isAriaDisabled (el) {
      return el.getAttribute('aria-disabled') === 'true';
    }

    function disEnableElement (isButton, el, val) {
      if (isButton) {
        el.disabled = val;
      } else {
        el.setAttribute('aria-disabled', val.toString());
      }
    }

    // set 'disabled' to true on controls when reach the edges
    function updateControlsStatus () {
      if (!controls || rewind || loop) { return; }

      var prevDisabled = (prevIsButton) ? prevButton.disabled : isAriaDisabled(prevButton),
          nextDisabled = (nextIsButton) ? nextButton.disabled : isAriaDisabled(nextButton),
          disablePrev = (index <= indexMin) ? true : false,
          disableNext = (!rewind && index >= indexMax) ? true : false;

      if (disablePrev && !prevDisabled) {
        disEnableElement(prevIsButton, prevButton, true);
      }
      if (!disablePrev && prevDisabled) {
        disEnableElement(prevIsButton, prevButton, false);
      }
      if (disableNext && !nextDisabled) {
        disEnableElement(nextIsButton, nextButton, true);
      }
      if (!disableNext && nextDisabled) {
        disEnableElement(nextIsButton, nextButton, false);
      }
    }

    // set duration
    function resetDuration (el, str) {
      if (TRANSITIONDURATION) { el.style[TRANSITIONDURATION] = str; }
    }

    function getSliderWidth () {
      return fixedWidth ? (fixedWidth + gutter) * slideCountNew : slidePositions[slideCountNew];
    }

    function getCenterGap (num) {
      if (num == null) { num = index; }

      var gap = edgePadding ? gutter : 0;
      return autoWidth ? ((viewport - gap) - (slidePositions[num + 1] - slidePositions[num] - gutter))/2 :
        fixedWidth ? (viewport - fixedWidth) / 2 :
          (items - 1) / 2;
    }

    function getRightBoundary () {
      var gap = edgePadding ? gutter : 0,
          result = (viewport + gap) - getSliderWidth();

      if (center && !loop) {
        result = fixedWidth ? - (fixedWidth + gutter) * (slideCountNew - 1) - getCenterGap() :
          getCenterGap(slideCountNew - 1) - slidePositions[slideCountNew - 1];
      }
      if (result > 0) { result = 0; }

      return result;
    }

    function getContainerTransformValue (num) {
      if (num == null) { num = index; }

      var val;
      if (horizontal && !autoWidth) {
        if (fixedWidth) {
          val = - (fixedWidth + gutter) * num;
          if (center) { val += getCenterGap(); }
        } else {
          var denominator = TRANSFORM ? slideCountNew : items;
          if (center) { num -= getCenterGap(); }
          val = - num * 100 / denominator;
        }
      } else {
        val = - slidePositions[num];
        if (center && autoWidth) {
          val += getCenterGap();
        }
      }

      if (hasRightDeadZone) { val = Math.max(val, rightBoundary); }

      val += (horizontal && !autoWidth && !fixedWidth) ? '%' : 'px';

      return val;
    }

    function doContainerTransformSilent (val) {
      resetDuration(container, '0s');
      doContainerTransform(val);
    }

    function doContainerTransform (val) {
      if (val == null) { val = getContainerTransformValue(); }
      if (textDirection === 'rtl' && val.charAt(0) === '-') {
        val = val.substr(1);
      }
      container.style[transformAttr] = transformPrefix + val + transformPostfix;
    }

    function animateSlide (number, classOut, classIn, isOut) {
      var l = number + items;
      if (!loop) { l = Math.min(l, slideCountNew); }

      for (var i = number; i < l; i++) {
          var item = slideItems[i];

        // set item positions
        if (!isOut) { item.style.left = (i - index) * 100 / items + '%'; }

        if (animateDelay && TRANSITIONDELAY) {
          item.style[TRANSITIONDELAY] = item.style[ANIMATIONDELAY] = animateDelay * (i - number) / 1000 + 's';
        }
        removeClass(item, classOut);
        addClass(item, classIn);

        if (isOut) { slideItemsOut.push(item); }
      }
    }

    // make transfer after click/drag:
    // 1. change 'transform' property for mordern browsers
    // 2. change 'left' property for legacy browsers
    var transformCore = (function () {
      return carousel ?
        function () {
          resetDuration(container, '');
          if (TRANSITIONDURATION || !speed) {
            // for morden browsers with non-zero duration or
            // zero duration for all browsers
            doContainerTransform();
            // run fallback function manually
            // when duration is 0 / container is hidden
            if (!speed || !isVisible(container)) { onTransitionEnd(); }

          } else {
            // for old browser with non-zero duration
            jsTransform(container, transformAttr, transformPrefix, transformPostfix, getContainerTransformValue(), speed, onTransitionEnd);
          }

          if (!horizontal) { updateContentWrapperHeight(); }
        } :
        function () {
          slideItemsOut = [];

          var eve = {};
          eve[TRANSITIONEND] = eve[ANIMATIONEND] = onTransitionEnd;
          removeEvents(slideItems[indexCached], eve);
          addEvents(slideItems[index], eve);

          animateSlide(indexCached, animateIn, animateOut, true);
          animateSlide(index, animateNormal, animateIn);

          // run fallback function manually
          // when transition or animation not supported / duration is 0
          if (!TRANSITIONEND || !ANIMATIONEND || !speed || !isVisible(container)) { onTransitionEnd(); }
        };
    })();

    function render (e, sliderMoved) {
      if (updateIndexBeforeTransform) { updateIndex(); }

      // render when slider was moved (touch or drag) even though index may not change
      if (index !== indexCached || sliderMoved) {
        // events
        events.emit('indexChanged', info());
        events.emit('transitionStart', info());
        if (autoHeight) { doAutoHeight(); }

        // pause autoplay when click or keydown from user
        if (animating && e && ['click', 'keydown'].indexOf(e.type) >= 0) { stopAutoplay(); }

        running = true;
        transformCore();
      }
    }

    /*
     * Transfer prefixed properties to the same format
     * CSS: -Webkit-Transform => webkittransform
     * JS: WebkitTransform => webkittransform
     * @param {string} str - property
     *
     */
    function strTrans (str) {
      return str.toLowerCase().replace(/-/g, '');
    }

    // AFTER TRANSFORM
    // Things need to be done after a transfer:
    // 1. check index
    // 2. add classes to visible slide
    // 3. disable controls buttons when reach the first/last slide in non-loop slider
    // 4. update nav status
    // 5. lazyload images
    // 6. update container height
    function onTransitionEnd (event) {
      // check running on gallery mode
      // make sure trantionend/animationend events run only once
      if (carousel || running) {
        events.emit('transitionEnd', info(event));

        if (!carousel && slideItemsOut.length > 0) {
          for (var i = 0; i < slideItemsOut.length; i++) {
            var item = slideItemsOut[i];
            // set item positions
            item.style.left = '';

            if (ANIMATIONDELAY && TRANSITIONDELAY) {
              item.style[ANIMATIONDELAY] = '';
              item.style[TRANSITIONDELAY] = '';
            }
            removeClass(item, animateOut);
            addClass(item, animateNormal);
          }
        }

        /* update slides, nav, controls after checking ...
         * => legacy browsers who don't support 'event'
         *    have to check event first, otherwise event.target will cause an error
         * => or 'gallery' mode:
         *   + event target is slide item
         * => or 'carousel' mode:
         *   + event target is container,
         *   + event.property is the same with transform attribute
         */
        if (!event ||
            !carousel && event.target.parentNode === container ||
            event.target === container && strTrans(event.propertyName) === strTrans(transformAttr)) {

          if (!updateIndexBeforeTransform) {
            var indexTem = index;
            updateIndex();
            if (index !== indexTem) {
              events.emit('indexChanged', info());

              doContainerTransformSilent();
            }
          }

          if (nested === 'inner') { events.emit('innerLoaded', info()); }
          running = false;
          indexCached = index;
        }
      }

    }

    // # ACTIONS
    function goTo (targetIndex, e) {
      if (freeze) { return; }

      // prev slideBy
      if (targetIndex === 'prev') {
        onControlsClick(e, -1);

      // next slideBy
      } else if (targetIndex === 'next') {
        onControlsClick(e, 1);

      // go to exact slide
      } else {
        if (running) {
          if (preventActionWhenRunning) { return; } else { onTransitionEnd(); }
        }

        var absIndex = getAbsIndex(),
            indexGap = 0;

        if (targetIndex === 'first') {
          indexGap = - absIndex;
        } else if (targetIndex === 'last') {
          indexGap = carousel ? slideCount - items - absIndex : slideCount - 1 - absIndex;
        } else {
          if (typeof targetIndex !== 'number') { targetIndex = parseInt(targetIndex); }

          if (!isNaN(targetIndex)) {
            // from directly called goTo function
            if (!e) { targetIndex = Math.max(0, Math.min(slideCount - 1, targetIndex)); }

            indexGap = targetIndex - absIndex;
          }
        }

        // gallery: make sure new page won't overlap with current page
        if (!carousel && indexGap && Math.abs(indexGap) < items) {
          var factor = indexGap > 0 ? 1 : -1;
          indexGap += (index + indexGap - slideCount) >= indexMin ? slideCount * factor : slideCount * 2 * factor * -1;
        }

        index += indexGap;

        // make sure index is in range
        if (carousel && loop) {
          if (index < indexMin) { index += slideCount; }
          if (index > indexMax) { index -= slideCount; }
        }

        // if index is changed, start rendering
        if (getAbsIndex(index) !== getAbsIndex(indexCached)) {
          render(e);
        }

      }
    }

    // on controls click
    function onControlsClick (e, dir) {
      if (running) {
        if (preventActionWhenRunning) { return; } else { onTransitionEnd(); }
      }
      var passEventObject;

      if (!dir) {
        e = getEvent(e);
        var target = getTarget(e);

        while (target !== controlsContainer && [prevButton, nextButton].indexOf(target) < 0) { target = target.parentNode; }

        var targetIn = [prevButton, nextButton].indexOf(target);
        if (targetIn >= 0) {
          passEventObject = true;
          dir = targetIn === 0 ? -1 : 1;
        }
      }

      if (rewind) {
        if (index === indexMin && dir === -1) {
          goTo('last', e);
          return;
        } else if (index === indexMax && dir === 1) {
          goTo('first', e);
          return;
        }
      }

      if (dir) {
        index += slideBy * dir;
        if (autoWidth) { index = Math.floor(index); }
        // pass e when click control buttons or keydown
        render((passEventObject || (e && e.type === 'keydown')) ? e : null);
      }
    }

    // on nav click
    function onNavClick (e) {
      if (running) {
        if (preventActionWhenRunning) { return; } else { onTransitionEnd(); }
      }

      e = getEvent(e);
      var target = getTarget(e), navIndex;

      // find the clicked nav item
      while (target !== navContainer && !hasAttr(target, 'data-nav')) { target = target.parentNode; }
      if (hasAttr(target, 'data-nav')) {
        var navIndex = navClicked = Number(getAttr(target, 'data-nav')),
            targetIndexBase = fixedWidth || autoWidth ? navIndex * slideCount / pages : navIndex * items,
            targetIndex = navAsThumbnails ? navIndex : Math.min(Math.ceil(targetIndexBase), slideCount - 1);
        goTo(targetIndex, e);

        if (navCurrentIndex === navIndex) {
          if (animating) { stopAutoplay(); }
          navClicked = -1; // reset navClicked
        }
      }
    }

    // autoplay functions
    function setAutoplayTimer () {
      autoplayTimer = setInterval(function () {
        onControlsClick(null, autoplayDirection);
      }, autoplayTimeout);

      animating = true;
    }

    function stopAutoplayTimer () {
      clearInterval(autoplayTimer);
      animating = false;
    }

    function updateAutoplayButton (action, txt) {
      setAttrs(autoplayButton, {'data-action': action});
      autoplayButton.innerHTML = autoplayHtmlStrings[0] + action + autoplayHtmlStrings[1] + txt;
    }

    function startAutoplay () {
      setAutoplayTimer();
      if (autoplayButton) { updateAutoplayButton('stop', autoplayText[1]); }
    }

    function stopAutoplay () {
      stopAutoplayTimer();
      if (autoplayButton) { updateAutoplayButton('start', autoplayText[0]); }
    }

    // programaitcally play/pause the slider
    function play () {
      if (autoplay && !animating) {
        startAutoplay();
        autoplayUserPaused = false;
      }
    }
    function pause () {
      if (animating) {
        stopAutoplay();
        autoplayUserPaused = true;
      }
    }

    function toggleAutoplay () {
      if (animating) {
        stopAutoplay();
        autoplayUserPaused = true;
      } else {
        startAutoplay();
        autoplayUserPaused = false;
      }
    }

    function onVisibilityChange () {
      if (doc.hidden) {
        if (animating) {
          stopAutoplayTimer();
          autoplayVisibilityPaused = true;
        }
      } else if (autoplayVisibilityPaused) {
        setAutoplayTimer();
        autoplayVisibilityPaused = false;
      }
    }

    function mouseoverPause () {
      if (animating) {
        stopAutoplayTimer();
        autoplayHoverPaused = true;
      }
    }

    function mouseoutRestart () {
      if (autoplayHoverPaused) {
        setAutoplayTimer();
        autoplayHoverPaused = false;
      }
    }

    // keydown events on document
    function onDocumentKeydown (e) {
      e = getEvent(e);
      var keyIndex = [KEYS.LEFT, KEYS.RIGHT].indexOf(e.keyCode);

      if (keyIndex >= 0) {
        onControlsClick(e, keyIndex === 0 ? -1 : 1);
      }
    }

    // on key control
    function onControlsKeydown (e) {
      e = getEvent(e);
      var keyIndex = [KEYS.LEFT, KEYS.RIGHT].indexOf(e.keyCode);

      if (keyIndex >= 0) {
        if (keyIndex === 0) {
          if (!prevButton.disabled) { onControlsClick(e, -1); }
        } else if (!nextButton.disabled) {
          onControlsClick(e, 1);
        }
      }
    }

    // set focus
    function setFocus (el) {
      el.focus();
    }

    // on key nav
    function onNavKeydown (e) {
      e = getEvent(e);
      var curElement = doc.activeElement;
      if (!hasAttr(curElement, 'data-nav')) { return; }

      // var code = e.keyCode,
      var keyIndex = [KEYS.LEFT, KEYS.RIGHT, KEYS.ENTER, KEYS.SPACE].indexOf(e.keyCode),
          navIndex = Number(getAttr(curElement, 'data-nav'));

      if (keyIndex >= 0) {
        if (keyIndex === 0) {
          if (navIndex > 0) { setFocus(navItems[navIndex - 1]); }
        } else if (keyIndex === 1) {
          if (navIndex < pages - 1) { setFocus(navItems[navIndex + 1]); }
        } else {
          navClicked = navIndex;
          goTo(navIndex, e);
        }
      }
    }

    function getEvent (e) {
      e = e || win.event;
      return isTouchEvent(e) ? e.changedTouches[0] : e;
    }
    function getTarget (e) {
      return e.target || win.event.srcElement;
    }

    function isTouchEvent (e) {
      return e.type.indexOf('touch') >= 0;
    }

    function preventDefaultBehavior (e) {
      e.preventDefault ? e.preventDefault() : e.returnValue = false;
    }

    function getMoveDirectionExpected () {
      return getTouchDirection(toDegree(lastPosition.y - initPosition.y, lastPosition.x - initPosition.x), swipeAngle) === options.axis;
    }

    function onPanStart (e) {
      if (running) {
        if (preventActionWhenRunning) { return; } else { onTransitionEnd(); }
      }

      if (autoplay && animating) { stopAutoplayTimer(); }

      panStart = true;
      if (rafIndex) {
        caf(rafIndex);
        rafIndex = null;
      }

      var $ = getEvent(e);
      events.emit(isTouchEvent(e) ? 'touchStart' : 'dragStart', info(e));

      if (!isTouchEvent(e) && ['img', 'a'].indexOf(getLowerCaseNodeName(getTarget(e))) >= 0) {
        preventDefaultBehavior(e);
      }

      lastPosition.x = initPosition.x = $.clientX;
      lastPosition.y = initPosition.y = $.clientY;
      if (carousel) {
        translateInit = parseFloat(container.style[transformAttr].replace(transformPrefix, ''));
        resetDuration(container, '0s');
      }
    }

    function onPanMove (e) {
      if (panStart) {
        var $ = getEvent(e);
        lastPosition.x = $.clientX;
        lastPosition.y = $.clientY;

        if (carousel) {
          if (!rafIndex) { rafIndex = raf(function(){ panUpdate(e); }); }
        } else {
          if (moveDirectionExpected === '?') { moveDirectionExpected = getMoveDirectionExpected(); }
          if (moveDirectionExpected) { preventScroll = true; }
        }

        if ((typeof e.cancelable !== 'boolean' || e.cancelable) && preventScroll) {
          e.preventDefault();
        }
      }
    }

    function panUpdate (e) {
      if (!moveDirectionExpected) {
        panStart = false;
        return;
      }
      caf(rafIndex);
      if (panStart) { rafIndex = raf(function(){ panUpdate(e); }); }

      if (moveDirectionExpected === '?') { moveDirectionExpected = getMoveDirectionExpected(); }
      if (moveDirectionExpected) {
        if (!preventScroll && isTouchEvent(e)) { preventScroll = true; }

        try {
          if (e.type) { events.emit(isTouchEvent(e) ? 'touchMove' : 'dragMove', info(e)); }
        } catch(err) {}

        var x = translateInit,
            dist = getDist(lastPosition, initPosition);
        if (!horizontal || fixedWidth || autoWidth) {
          x += dist;
          x += 'px';
        } else {
          var percentageX = TRANSFORM ? dist * items * 100 / ((viewport + gutter) * slideCountNew): dist * 100 / (viewport + gutter);
          x += percentageX;
          x += '%';
        }

        container.style[transformAttr] = transformPrefix + x + transformPostfix;
      }
    }

    function onPanEnd (e) {
      if (panStart) {
        if (rafIndex) {
          caf(rafIndex);
          rafIndex = null;
        }
        if (carousel) { resetDuration(container, ''); }
        panStart = false;

        var $ = getEvent(e);
        lastPosition.x = $.clientX;
        lastPosition.y = $.clientY;
        var dist = getDist(lastPosition, initPosition);

        if (Math.abs(dist)) {
          // drag vs click
          if (!isTouchEvent(e)) {
            // prevent "click"
            var target = getTarget(e);
            addEvents(target, {'click': function preventClick (e) {
              preventDefaultBehavior(e);
              removeEvents(target, {'click': preventClick});
            }});
          }

          if (carousel) {
            rafIndex = raf(function() {
              if (horizontal && !autoWidth) {
                var indexMoved = - dist * items / (viewport + gutter);
                indexMoved = dist > 0 ? Math.floor(indexMoved) : Math.ceil(indexMoved);
                if (textDirection === 'rtl') { 
                  index += indexMoved * -1;
                } else {
                  index += indexMoved;
                }
              } else {
                var moved = - (translateInit + dist);
                if (moved <= 0) {
                  index = indexMin;
                } else if (moved >= slidePositions[slideCountNew - 1]) {
                  index = indexMax;
                } else {
                  var i = 0;
                  while (i < slideCountNew && moved >= slidePositions[i]) {
                    index = i;
                    if (moved > slidePositions[i] && dist < 0) { index += 1; }
                    i++;
                  }
                }
              }

              render(e, dist);
              events.emit(isTouchEvent(e) ? 'touchEnd' : 'dragEnd', info(e));
            });
          } else {
            if (moveDirectionExpected) {
              onControlsClick(e, dist > 0 ? -1 : 1);
            }
          }
        }
      }

      // reset
      if (options.preventScrollOnTouch === 'auto') { preventScroll = false; }
      if (swipeAngle) { moveDirectionExpected = '?'; }
      if (autoplay && !animating) { setAutoplayTimer(); }
    }

    // === RESIZE FUNCTIONS === //
    // (slidePositions, index, items) => vertical_conentWrapper.height
    function updateContentWrapperHeight () {
      var wp = middleWrapper ? middleWrapper : innerWrapper;
      wp.style.height = slidePositions[index + items] - slidePositions[index] + 'px';
    }

    function getPages () {
      var rough = fixedWidth ? (fixedWidth + gutter) * slideCount / viewport : slideCount / items;
      return Math.min(Math.ceil(rough), slideCount);
    }

    /*
     * 1. update visible nav items list
     * 2. add "hidden" attributes to previous visible nav items
     * 3. remove "hidden" attrubutes to new visible nav items
     */
    function updateNavVisibility () {
      if (!nav || navAsThumbnails) { return; }

      if (pages !== pagesCached) {
        var min = pagesCached,
            max = pages,
            fn = showElement;

        if (pagesCached > pages) {
          min = pages;
          max = pagesCached;
          fn = hideElement;
        }

        while (min < max) {
          fn(navItems[min]);
          min++;
        }

        // cache pages
        pagesCached = pages;
      }
    }

    function info (e) {
      return {
        container: container,
        slideItems: slideItems,
        navContainer: navContainer,
        navItems: navItems,
        controlsContainer: controlsContainer,
        hasControls: hasControls,
        prevButton: prevButton,
        nextButton: nextButton,
        items: items,
        slideBy: slideBy,
        cloneCount: cloneCount,
        slideCount: slideCount,
        slideCountNew: slideCountNew,
        index: index,
        indexCached: indexCached,
        displayIndex: getCurrentSlide(),
        navCurrentIndex: navCurrentIndex,
        navCurrentIndexCached: navCurrentIndexCached,
        pages: pages,
        pagesCached: pagesCached,
        sheet: sheet,
        isOn: isOn,
        event: e || {},
      };
    }

    return {
      version: '2.9.3',
      getInfo: info,
      events: events,
      goTo: goTo,
      play: play,
      pause: pause,
      isOn: isOn,
      updateSliderHeight: updateInnerWrapperHeight,
      refresh: initSliderTransform,
      destroy: destroy,
      rebuild: function() {
        return tns(extend(options, optionsElements));
      }
    };
  };

  return tns;
  })();

  class BrowseGroupCateogries {
    connect() {
      var $container, slider;

      function init() {
        var data = $container.data();
        var sidebar = $container.data().sidebar;
        var items = data.browseGroupCategoriesCount;
        var dir = $('html').attr('dir');
        var controls = $container.parent().find('.browse-group-categories-controls')[0];

        slider = tns({
          container: $container[0],
          controlsContainer: controls,
          loop: false,
          nav: false,
          items: 1,
          slideBy: 'page',
          textDirection: dir,
          responsive: {
            576: {
              items: itemCount(items, sidebar)
            }
          }
        });
      }

      // Destroy the slider instance, as tns will change the dom elements, causing some issues with turbolinks
      function setupDestroy() {
        document.addEventListener('turbolinks:before-cache', function() {
          if (slider && slider.destroy) {
            slider.destroy();
          }
        });
      }

      function itemCount(items, sidebar) {
        if (items < 3) {
          return items;
        }
        return sidebar ? 3 : 4;
      }

      return $('[data-browse-group-categories-carousel]').each(function() {
        $container = $(this);
        init();
        setupDestroy();
      });
    }
  }

  class Carousel {
    connect() {
      if ($.fn.carousel) {
        $('.carousel').carousel();
      }
    }
  }

  class ClearFormButton {
    connect() {
      var $clearBtn = $('.btn-reset');
      var $input = $clearBtn.parent().prev('input');
      var btnCheck = function(){
        if ($input.val() !== '') {
          $clearBtn.css('display', 'inline-block');
        } else {
          $clearBtn.css('display', 'none');
        }
      };

      btnCheck();
      $input.on('keyup', function() {
        btnCheck();
      });

      $clearBtn.on('click', function(event) {
        event.preventDefault();
        $input.val('');
      });
    }
  }

  class ReportProblem {
    connect(){
      var container, target;

      function init() {
        const target_val = container.attr('data-target') || container.attr('data-bs-target');
        if (!target_val) 
          return

        target = $("#" + target_val); 
        container.on('click', open);
        target.find('[data-behavior="cancel-link"]').on('click', close);
      }

      function open(event) {
        event.preventDefault();
        target.slideToggle('slow');
      }

      function close(event) {
        event.preventDefault();
        target.slideUp('fast');
      }

      return $('[data-behavior="contact-link"]').each(function() {        
        container = $(this);
        init();
      });
    }
  }

  class ZprLinks {
    connect() {
      $('.zpr-link').on('click', function() {
        var modalDialog = $('#blacklight-modal .modal-dialog');
        var modalContent = modalDialog.find('.modal-content');
        modalDialog.removeClass('modal-lg');
        modalDialog.addClass('modal-xl');
        modalContent.html('<div id="osd-modal-container"></div>');
        var controls = `<div class="controls d-flex justify-content-center justify-content-md-end">
          <div class="custom-close-controls pr-3 pe-3 pt-3">
            <button type="button" class="btn btn-dark" data-dismiss="modal" data-bs-dismiss="modal" aria-hidden="true">${Spotlight.ZprLinks.close}</button>
          </div>
          <div class="zoom-controls mb-3 mr-md-3 me-md-3">
            <button id="osd-zoom-in" type="button" class="btn btn-dark">${Spotlight.ZprLinks.zoomIn}</button>
            <button id="osd-zoom-out" type="button" class="btn btn-dark">${Spotlight.ZprLinks.zoomOut}</button>
          </div>
          <div id="empty-div-required-by-osd"></div>
        </div>`;

        $('#osd-modal-container').append('<div id="osd-div"></div>');
        $('#osd-modal-container').append(controls);

        $('#blacklight-modal').modal('show');
        
        $('#blacklight-modal').one('hidden.bs.modal', function (event) {
          modalDialog.removeClass('modal-xl');
          modalDialog.addClass('modal-lg');
        });

        OpenSeadragon({
          id: 'osd-div',
          zoomInButton: "osd-zoom-in",
          zoomOutButton: "osd-zoom-out",
          // This is a hack where OpenSeadragon (if using mapped buttons) requires you
          // to map all of the buttons.
          homeButton: "empty-div-required-by-osd",
          fullPageButton: "empty-div-required-by-osd",
          nextButton: "empty-div-required-by-osd",
          previousButton: "empty-div-required-by-osd",
          tileSources: [$(this).data('iiif-tilesource')]
        });
      });
    }
  }

  class UserIndex {
    connect() {
      new BrowseGroupCateogries().connect();
      new Carousel().connect();
      new ClearFormButton().connect();
      new ReportProblem().connect();
      new ZprLinks().connect();
    }
  }

  /*!
   * Nestable jQuery Plugin - Copyright (c) 2012 David Bushell - http://dbushell.com/
   * Dual-licensed under the BSD or MIT licenses
   */
  (function($, window, document, undefined$1)
  {
      var hasTouch = 'ontouchstart' in window;

      /**
       * Detect CSS pointer-events property
       * events are normally disabled on the dragging element to avoid conflicts
       * https://github.com/ausi/Feature-detection-technique-for-pointer-events/blob/master/modernizr-pointerevents.js
       */
      var hasPointerEvents = (function()
      {
          var el    = document.createElement('div'),
              docEl = document.documentElement;
          if (!('pointerEvents' in el.style)) {
              return false;
          }
          el.style.pointerEvents = 'auto';
          el.style.pointerEvents = 'x';
          docEl.appendChild(el);
          var supports = window.getComputedStyle && window.getComputedStyle(el, '').pointerEvents === 'auto';
          docEl.removeChild(el);
          return !!supports;
      })();

      var eStart  = hasTouch ? 'touchstart'  : 'mousedown',
           eMove   = hasTouch ? 'touchmove'   : 'mousemove',
           eEnd    = hasTouch ? 'touchend'    : 'mouseup',
           eCancel = hasTouch ? 'touchcancel' : 'mouseup';
            
      var defaults = {
          listNodeName    : 'ol',
          itemNodeName    : 'li',
          rootClass       : 'dd',
          listClass       : 'dd-list',
          itemClass       : 'dd-item',
          dragClass       : 'dd-dragel',
          handleClass     : 'dd-handle',
          collapsedClass  : 'dd-collapsed',
          placeClass      : 'dd-placeholder',
          noDragClass     : 'dd-nodrag',
          noChildrenClass : 'dd-nochildren',
          emptyClass      : 'dd-empty',
          expandBtnHTML   : '<button data-action="expand" type="button">Expand</button>',
          collapseBtnHTML : '<button data-action="collapse" type="button">Collapse</button>',
          group           : 0,
          maxDepth        : 5,
          threshold       : 20,
          reject          : [],
          //method for call when an item has been successfully dropped
          //method has 1 argument in which sends an object containing all
          //necessary details
          dropCallback    : null,
        // When a node is dragged it is moved to its new location.
        // You can set the next option to true to create a copy of the node  that is dragged.
        cloneNodeOnDrag   : false,
        // When the node is dragged and released outside its list delete it.
        dragOutsideToDelete : false
      };

      function Plugin(element, options)
      {
          this.w = $(document);
          this.el = $(element);
          this.options = $.extend({}, defaults, options);
          this.init();
      }

      Plugin.prototype = {

          init: function()
          {
              var list = this;

              list.reset();

              list.el.data('nestable-group', this.options.group);

              list.placeEl = $('<div class="' + list.options.placeClass + '"/>');

              $.each(this.el.find(list.options.itemNodeName), function(k, el) {
                  list.setParent($(el));
              });

              list.el.on('click', 'button', function(e)
              {
                  if (list.dragEl || (!hasTouch && e.button !== 0)) {
                      return;
                  }
                  var target = $(e.currentTarget),
                      action = target.data('action'),
                      item   = target.parent(list.options.itemNodeName);
                  if (action === 'collapse') {
                      list.collapseItem(item);
                  }
                  if (action === 'expand') {
                      list.expandItem(item);
                  }
              });

              var onStartEvent = function(e)
              {
                  var handle = $(e.target);

                  list.nestableCopy = handle.closest('.'+list.options.rootClass).clone(true);

                  if (!handle.hasClass(list.options.handleClass)) {
                      if (handle.closest('.' + list.options.noDragClass).length) {
                          return;
                      }
                      handle = handle.closest('.' + list.options.handleClass);
                  }
                  if (!handle.length || list.dragEl || (!hasTouch && e.which !== 1) || (hasTouch && e.touches.length !== 1)) {
                      return;
                  }
                  e.preventDefault();
                  list.dragStart(hasTouch ? e.touches[0] : e);
              };

              var onMoveEvent = function(e)
              {
                  if (list.dragEl) {
                      e.preventDefault();
                      list.dragMove(hasTouch ? e.touches[0] : e);
                  }
              };

              var onEndEvent = function(e)
              {
                  if (list.dragEl) {
                      e.preventDefault();
                      list.dragStop(hasTouch ? e.touches[0] : e);
                  }
              };

              if (hasTouch) {
                  list.el[0].addEventListener(eStart, onStartEvent, false);
                  window.addEventListener(eMove, onMoveEvent, false);
                  window.addEventListener(eEnd, onEndEvent, false);
                  window.addEventListener(eCancel, onEndEvent, false);
              } else {
                  list.el.on(eStart, onStartEvent);
                  list.w.on(eMove, onMoveEvent);
                  list.w.on(eEnd, onEndEvent);
              }

              var destroyNestable = function()
              {
                  if (hasTouch) {
                      list.el[0].removeEventListener(eStart, onStartEvent, false);
                      window.removeEventListener(eMove, onMoveEvent, false);
                      window.removeEventListener(eEnd, onEndEvent, false);
                      window.removeEventListener(eCancel, onEndEvent, false);
                  } else {
                      list.el.off(eStart, onStartEvent);
                      list.w.off(eMove, onMoveEvent);
                      list.w.off(eEnd, onEndEvent);
                  }

                  list.el.off('click');
                  list.el.unbind('destroy-nestable');

                  list.el.data("nestable", null);

                  var buttons = list.el[0].getElementsByTagName('button');

                  $(buttons).remove();
              };

              list.el.bind('destroy-nestable', destroyNestable);
          },

          destroy: function ()
          {
              this.expandAll();
              this.el.trigger('destroy-nestable');
          },

          serialize: function()
          {
              var data,
                  list  = this;
              const step  = function(level, depth)
                  {
                      var array = [ ],
                          items = level.children(list.options.itemNodeName);
                      items.each(function()
                      {
                          var li   = $(this),
                              item = $.extend({}, li.data()),
                              sub  = li.children(list.options.listNodeName);
                          if (sub.length) {
                              item.children = step(sub);
                          }
                          array.push(item);
                      });
                      return array;
                  };
              var el;

              if (list.el.is(list.options.listNodeName)) {
                  el = list.el;
              } else {
                  el = list.el.find(list.options.listNodeName).first();
              }
              data = step(el);
              return data;
          },

          reset: function()
          {
              this.mouse = {
                  offsetX   : 0,
                  offsetY   : 0,
                  startX    : 0,
                  startY    : 0,
                  lastX     : 0,
                  lastY     : 0,
                  nowX      : 0,
                  nowY      : 0,
                  distX     : 0,
                  distY     : 0,
                  dirAx     : 0,
                  dirX      : 0,
                  dirY      : 0,
                  lastDirX  : 0,
                  lastDirY  : 0,
                  distAxX   : 0,
                  distAxY   : 0
              };
              this.moving     = false;
              this.dragEl     = null;
              this.dragRootEl = null;
              this.dragDepth  = 0;
              this.dragItem   = null;
              this.hasNewRoot = false;
              this.pointEl    = null;
              this.sourceRoot = null;
              this.isOutsideRoot = false;
          },

          expandItem: function(li)
          {
              li.removeClass(this.options.collapsedClass);
              li.children('[data-action="expand"]').hide();
              li.children('[data-action="collapse"]').show();
              li.children(this.options.listNodeName).show();
              this.el.trigger('expand', [li]);
              li.trigger('expand');
          },

          collapseItem: function(li)
          {
              var lists = li.children(this.options.listNodeName);
              if (lists.length) {
                  li.addClass(this.options.collapsedClass);
                  li.children('[data-action="collapse"]').hide();
                  li.children('[data-action="expand"]').show();
                  li.children(this.options.listNodeName).hide();
              }
              this.el.trigger('collapse', [li]);
              li.trigger('collapse');
          },

          expandAll: function()
          {
              var list = this;
              list.el.find(list.options.itemNodeName).each(function() {
                  list.expandItem($(this));
              });
          },

          collapseAll: function()
          {
              var list = this;
              list.el.find(list.options.itemNodeName).each(function() {
                  list.collapseItem($(this));
              });
          },

          setParent: function(li)
          {
              if (li.children(this.options.listNodeName).length) {
                  li.prepend($(this.options.expandBtnHTML));
                  li.prepend($(this.options.collapseBtnHTML));
              }
              if( (' ' + li[0].className + ' ').indexOf(' ' + defaults.collapsedClass + ' ') > -1 )
              {
                  li.children('[data-action="collapse"]').hide();
              } else {
                  li.children('[data-action="expand"]').hide();
              }
          },

          unsetParent: function(li)
          {
              li.removeClass(this.options.collapsedClass);
              li.children('[data-action]').remove();
              li.children(this.options.listNodeName).remove();
          },

          dragStart: function(e)
          {
              var mouse    = this.mouse,
                  target   = $(e.target),
                  dragItem = target.closest('.' + this.options.handleClass).closest(this.options.itemNodeName);

              this.sourceRoot = target.closest('.' + this.options.rootClass);

              this.dragItem = dragItem;

              this.placeEl.css('height', dragItem.height());

              mouse.offsetX = e.offsetX !== undefined$1 ? e.offsetX : e.pageX - target.offset().left;
              mouse.offsetY = e.offsetY !== undefined$1 ? e.offsetY : e.pageY - target.offset().top;
              mouse.startX = mouse.lastX = e.pageX;
              mouse.startY = mouse.lastY = e.pageY;

              this.dragRootEl = this.el;

              this.dragEl = $(document.createElement(this.options.listNodeName)).addClass(this.options.listClass + ' ' + this.options.dragClass);
              this.dragEl.css('width', dragItem.width());

              // fix for zepto.js
              //dragItem.after(this.placeEl).detach().appendTo(this.dragEl);
              if(this.options.cloneNodeOnDrag) {
                  dragItem.after(dragItem.clone());
              } else {
                  dragItem.after(this.placeEl);
              }
              dragItem[0].parentNode.removeChild(dragItem[0]);
              dragItem.appendTo(this.dragEl);

              $(document.body).append(this.dragEl);
              this.dragEl.css({
                  'left' : e.pageX - mouse.offsetX,
                  'top'  : e.pageY - mouse.offsetY
              });
              // total depth of dragging item
              var i, depth,
                  items = this.dragEl.find(this.options.itemNodeName);
              for (i = 0; i < items.length; i++) {
                  depth = $(items[i]).parents(this.options.listNodeName).length;
                  if (depth > this.dragDepth) {
                      this.dragDepth = depth;
                  }
              }
          },

          dragStop: function(e)
          {
              // fix for zepto.js
              //this.placeEl.replaceWith(this.dragEl.children(this.options.itemNodeName + ':first').detach());
              var el = this.dragEl.children(this.options.itemNodeName).first();
              el[0].parentNode.removeChild(el[0]);

              if(this.isOutsideRoot && this.options.dragOutsideToDelete)
                  {
                  var parent = this.placeEl.parent();
                  this.placeEl.remove();
                  if (!parent.children().length) {
                      this.unsetParent(parent.parent());
                  }
                  // If all nodes where deleted, create a placeholder element.
                  if (!this.dragRootEl.find(this.options.itemNodeName).length)
                       {
                      this.dragRootEl.append('<div class="' + this.options.emptyClass + '"/>');
                  }
              } 
                  else 
                  {
                  this.placeEl.replaceWith(el);
              }

              if (!this.moving)
              {
                  $(this.dragItem).trigger('click');
              }

              var i;
              var isRejected = false;
              for (i = 0; i < this.options.reject.length; i++)
              {
                  var reject = this.options.reject[i];
                  if (reject.rule.apply(this.dragRootEl))
                  {
                      var nestableDragEl = el.clone(true);
                      this.dragRootEl.html(this.nestableCopy.children().clone(true));
                      if (reject.action) {
                          reject.action.apply(this.dragRootEl, [nestableDragEl]);
                      }

                      isRejected = true;
                      break;
                  }
              }

              if (!isRejected)
              {
                  this.dragEl.remove();
                  this.el.trigger('change');

                  //Let's find out new parent id
                  var parentItem = el.parent().parent();
                  var parentId = null;
                  if(parentItem !== null && !parentItem.is('.' + this.options.rootClass))
                      parentId = parentItem.data('id');

                  if($.isFunction(this.options.dropCallback))
                  {
                      var details = {
                          sourceId   : el.data('id'),
                          destId     : parentId,
                          sourceEl   : el,
                          destParent : parentItem,
                          destRoot   : el.closest('.' + this.options.rootClass),
                          sourceRoot : this.sourceRoot
                    };
                    this.options.dropCallback.call(this, details);
                  }

                  if (this.hasNewRoot) {
                      this.dragRootEl.trigger('change');
                  }

                  this.reset();
              }
          },

          dragMove: function(e)
          {
              var list, parent, prev, next, depth,
                  opt   = this.options,
                  mouse = this.mouse;

              this.dragEl.css({
                  'left' : e.pageX - mouse.offsetX,
                  'top'  : e.pageY - mouse.offsetY
              });

              // mouse position last events
              mouse.lastX = mouse.nowX;
              mouse.lastY = mouse.nowY;
              // mouse position this events
              mouse.nowX  = e.pageX;
              mouse.nowY  = e.pageY;
              // distance mouse moved between events
              mouse.distX = mouse.nowX - mouse.lastX;
              mouse.distY = mouse.nowY - mouse.lastY;
              // direction mouse was moving
              mouse.lastDirX = mouse.dirX;
              mouse.lastDirY = mouse.dirY;
              // direction mouse is now moving (on both axis)
              mouse.dirX = mouse.distX === 0 ? 0 : mouse.distX > 0 ? 1 : -1;
              mouse.dirY = mouse.distY === 0 ? 0 : mouse.distY > 0 ? 1 : -1;
              // axis mouse is now moving on
              var newAx   = Math.abs(mouse.distX) > Math.abs(mouse.distY) ? 1 : 0;

              // do nothing on first move
              if (!this.moving) {
                  mouse.dirAx  = newAx;
                  this.moving = true;
                  return;
              }

              // calc distance moved on this axis (and direction)
              if (mouse.dirAx !== newAx) {
                  mouse.distAxX = 0;
                  mouse.distAxY = 0;
              } else {
                  mouse.distAxX += Math.abs(mouse.distX);
                  if (mouse.dirX !== 0 && mouse.dirX !== mouse.lastDirX) {
                      mouse.distAxX = 0;
                  }
                  mouse.distAxY += Math.abs(mouse.distY);
                  if (mouse.dirY !== 0 && mouse.dirY !== mouse.lastDirY) {
                      mouse.distAxY = 0;
                  }
              }
              mouse.dirAx = newAx;

              /**
               * move horizontal
               */
              if (mouse.dirAx && mouse.distAxX >= opt.threshold) {
                  // reset move distance on x-axis for new phase
                  mouse.distAxX = 0;
                  prev = this.placeEl.prev(opt.itemNodeName);
                  // increase horizontal level if previous sibling exists and is not collapsed
                  if (mouse.distX > 0 && prev.length && !prev.hasClass(opt.collapsedClass) && !prev.hasClass(opt.noChildrenClass)) {
                      // cannot increase level when item above is collapsed
                      list = prev.find(opt.listNodeName).last();
                      // check if depth limit has reached
                      depth = this.placeEl.parents(opt.listNodeName).length;
                      if (depth + this.dragDepth <= opt.maxDepth) {
                          // create new sub-level if one doesn't exist
                          if (!list.length) {
                              list = $('<' + opt.listNodeName + '/>').addClass(opt.listClass);
                              list.append(this.placeEl);
                              prev.append(list);
                              this.setParent(prev);
                          } else {
                              // else append to next level up
                              list = prev.children(opt.listNodeName).last();
                              list.append(this.placeEl);
                          }
                      }
                  }
                  // decrease horizontal level
                  if (mouse.distX < 0) {
                      // we can't decrease a level if an item preceeds the current one
                      next = this.placeEl.next(opt.itemNodeName);
                      if (!next.length) {
                          parent = this.placeEl.parent();
                          this.placeEl.closest(opt.itemNodeName).after(this.placeEl);
                          if (!parent.children().length) {
                              this.unsetParent(parent.parent());
                          }
                      }
                  }
              }

              var isEmpty = false;

              // find list item under cursor
              if (!hasPointerEvents) {
                  this.dragEl[0].style.visibility = 'hidden';
              }
                  
              this.pointEl = $(document.elementFromPoint(e.pageX - document.documentElement.scrollLeft, e.pageY - (window.pageYOffset || document.documentElement.scrollTop)));

              // Check if the node is dragged outside of its list.
              if(this.dragRootEl.has(this.pointEl).length) {
                  this.isOutsideRoot = false;
                  this.dragEl[0].style.opacity = 1;
              } else {
                  this.isOutsideRoot = true;
                  this.dragEl[0].style.opacity = 0.5;
              }

              // find parent list of item under cursor
              var pointElRoot = this.pointEl.closest('.' + opt.rootClass),
                  isNewRoot   = this.dragRootEl.data('nestable-id') !== pointElRoot.data('nestable-id');

              this.isOutsideRoot = !pointElRoot.length;

              if (!hasPointerEvents) {
                  this.dragEl[0].style.visibility = 'visible';
              }
              if (this.pointEl.hasClass(opt.handleClass)) {
                  this.pointEl = this.pointEl.closest( opt.itemNodeName );
              }

              if (opt.maxDepth == 1 && !this.pointEl.hasClass(opt.itemClass)) {
                  this.pointEl = this.pointEl.closest("." + opt.itemClass);
              }

              if (this.pointEl.hasClass(opt.emptyClass)) {
                  isEmpty = true;
              }
              else if (!this.pointEl.length || !this.pointEl.hasClass(opt.itemClass)) {
                  return;
              }

              /**
               * move vertical
               */
              if (!mouse.dirAx || isNewRoot || isEmpty) {
                  // check if groups match if dragging over new root
                  if (isNewRoot && opt.group !== pointElRoot.data('nestable-group')) {
                      return;
                  }
                  // check depth limit
                  depth = this.dragDepth - 1 + this.pointEl.parents(opt.listNodeName).length;
                  if (depth > opt.maxDepth) {
                      return;
                  }
                  var before = e.pageY < (this.pointEl.offset().top + this.pointEl.height() / 2);
                      parent = this.placeEl.parent();
                  // if empty create new list to replace empty placeholder
                  if (isEmpty) {
                      list = $(document.createElement(opt.listNodeName)).addClass(opt.listClass);
                      list.append(this.placeEl);
                      this.pointEl.replaceWith(list);
                  }
                  else if (before) {
                      this.pointEl.before(this.placeEl);
                  }
                  else {
                      this.pointEl.after(this.placeEl);
                  }
                  if (!parent.children().length) {
                      this.unsetParent(parent.parent());
                  }
                  if (!this.dragRootEl.find(opt.itemNodeName).length) {
                      this.dragRootEl.append('<div class="' + opt.emptyClass + '"/>');
                  }
                  // parent root list has changed
                  this.dragRootEl = pointElRoot;
                  if (isNewRoot) {
                      this.hasNewRoot = this.el[0] !== this.dragRootEl[0];
                  }
              }
          }

      };

      $.fn.nestable = function(params)
      {
          var lists  = this,
              retval = this;

          var generateUid = function (separator) {
              var delim = "-";

              function S4() {
                  return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
              }

              return (S4() + S4() + delim + S4() + delim + S4() + delim + S4() + delim + S4() + S4() + S4());
          };

          lists.each(function()
          {
              var plugin = $(this).data("nestable");

              if (!plugin) {
                  $(this).data("nestable", new Plugin(this, params));
                  $(this).data("nestable-id", generateUid());
              } else {
                  if (typeof params === 'string' && typeof plugin[params] === 'function') {
                      retval = plugin[params]();
                  }
              }
          });

          return retval || lists;
      };

  })(window.jQuery || window.Zepto, window, document);

  /* From https://github.com/TimSchlechter/bootstrap-tagsinput/blob/2661784c2c281d3a69b93897ff3f39e4ffa5cbd1/dist/bootstrap-tagsinput.js */

  /* The MIT License (MIT)

  Copyright (c) 2013 Tim Schlechter

  Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the "Software"), to deal in
  the Software without restriction, including without limitation the rights to
  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  the Software, and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */

  /* Retrieved 12 February 2014 */

  (function ($) {

    var defaultOptions = {
      tagClass: function(item) {
        return 'badge badge-info bg-info';
      },
      itemValue: function(item) {
        return item ? item.toString() : item;
      },
      itemText: function(item) {
        return this.itemValue(item);
      },
      freeInput: true,
      maxTags: undefined,
      confirmKeys: [13],
      onTagExists: function(item, $tag) {
        $tag.hide().fadeIn();
      }
    };

    /**
     * Constructor function
     */
    function TagsInput(element, options) {
      this.itemsArray = [];

      this.$element = $(element);
      this.$element.hide();

      this.isSelect = (element.tagName === 'SELECT');
      this.multiple = (this.isSelect && element.hasAttribute('multiple'));
      this.objectItems = options && options.itemValue;
      this.placeholderText = element.hasAttribute('placeholder') ? this.$element.attr('placeholder') : '';
      this.inputSize = Math.max(1, this.placeholderText.length);

      this.$container = $('<div class="bootstrap-tagsinput"></div>');
      this.$input = $('<input size="' + this.inputSize + '" type="text" placeholder="' + this.placeholderText + '"/>').appendTo(this.$container);

      this.$element.after(this.$container);

      this.build(options);
    }

    TagsInput.prototype = {
      constructor: TagsInput,

      /**
       * Adds the given item as a new tag. Pass true to dontPushVal to prevent
       * updating the elements val()
       */
      add: function(item, dontPushVal) {
        var self = this;

        if (self.options.maxTags && self.itemsArray.length >= self.options.maxTags)
          return;

        // Ignore falsey values, except false
        if (item !== false && !item)
          return;

        // Throw an error when trying to add an object while the itemValue option was not set
        if (typeof item === "object" && !self.objectItems)
          throw("Can't add objects when itemValue option is not set");

        // Ignore strings only containg whitespace
        if (item.toString().match(/^\s*$/))
          return;

        // If SELECT but not multiple, remove current tag
        if (self.isSelect && !self.multiple && self.itemsArray.length > 0)
          self.remove(self.itemsArray[0]);

        if (typeof item === "string" && this.$element[0].tagName === 'INPUT') {
          var items = item.split(',');
          if (items.length > 1) {
            for (var i = 0; i < items.length; i++) {
              this.add(items[i], true);
            }

            if (!dontPushVal)
              self.pushVal();
            return;
          }
        }

        var itemValue = self.options.itemValue(item),
            itemText = self.options.itemText(item),
            tagClass = self.options.tagClass(item);

        // Ignore items allready added
        var existing = $.grep(self.itemsArray, function(item) { return self.options.itemValue(item) === itemValue; } )[0];
        if (existing) {
          // Invoke onTagExists
          if (self.options.onTagExists) {
            var $existingTag = $(".tag", self.$container).filter(function() { return $(this).data("item") === existing; });
            self.options.onTagExists(item, $existingTag);
          }
          return;
        }

        // register item in internal array and map
        self.itemsArray.push(item);

        // add a tag element
        var $tag = $('<span class="tag ' + htmlEncode(tagClass) + '">' + htmlEncode(itemText) + '<span data-role="remove"></span></span>');
        $tag.data('item', item);
        self.findInputWrapper().before($tag);
        $tag.after(' ');

        // add <option /> if item represents a value not present in one of the <select />'s options
        if (self.isSelect && !$('option[value="' + escape(itemValue) + '"]',self.$element)[0]) {
          var $option = $('<option selected>' + htmlEncode(itemText) + '</option>');
          $option.data('item', item);
          $option.attr('value', itemValue);
          self.$element.append($option);
        }

        if (!dontPushVal)
          self.pushVal();

        // Add class when reached maxTags
        if (self.options.maxTags === self.itemsArray.length)
          self.$container.addClass('bootstrap-tagsinput-max');

        self.$element.trigger($.Event('itemAdded', { item: item }));
      },

      /**
       * Removes the given item. Pass true to dontPushVal to prevent updating the
       * elements val()
       */
      remove: function(item, dontPushVal) {
        var self = this;

        if (self.objectItems) {
          if (typeof item === "object")
            item = $.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  self.options.itemValue(item); } )[0];
          else
            item = $.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  item; } )[0];
        }

        if (item) {
          $('.tag', self.$container).filter(function() { return $(this).data('item') === item; }).remove();
          $('option', self.$element).filter(function() { return $(this).data('item') === item; }).remove();
          self.itemsArray.splice($.inArray(item, self.itemsArray), 1);
        }

        if (!dontPushVal)
          self.pushVal();

        // Remove class when reached maxTags
        if (self.options.maxTags > self.itemsArray.length)
          self.$container.removeClass('bootstrap-tagsinput-max');

        self.$element.trigger($.Event('itemRemoved',  { item: item }));
      },

      /**
       * Removes all items
       */
      removeAll: function() {
        var self = this;

        $('.tag', self.$container).remove();
        $('option', self.$element).remove();

        while(self.itemsArray.length > 0)
          self.itemsArray.pop();

        self.pushVal();

        if (self.options.maxTags && !this.isEnabled())
          this.enable();
      },

      /**
       * Refreshes the tags so they match the text/value of their corresponding
       * item.
       */
      refresh: function() {
        var self = this;
        $('.tag', self.$container).each(function() {
          var $tag = $(this),
              item = $tag.data('item'),
              itemValue = self.options.itemValue(item),
              itemText = self.options.itemText(item),
              tagClass = self.options.tagClass(item);

            // Update tag's class and inner text
            $tag.attr('class', null);
            $tag.addClass('tag ' + htmlEncode(tagClass));
            $tag.contents().filter(function() {
              return this.nodeType == 3;
            })[0].nodeValue = htmlEncode(itemText);

            if (self.isSelect) {
              var option = $('option', self.$element).filter(function() { return $(this).data('item') === item; });
              option.attr('value', itemValue);
            }
        });
      },

      /**
       * Returns the items added as tags
       */
      items: function() {
        return this.itemsArray;
      },

      /**
       * Assembly value by retrieving the value of each item, and set it on the
       * element. 
       */
      pushVal: function() {
        var self = this,
            val = $.map(self.items(), function(item) {
              return self.options.itemValue(item).toString();
            });

        self.$element.val(val, true).trigger('change');
      },

      /**
       * Initializes the tags input behaviour on the element
       */
      build: function(options) {
        var self = this;

        self.options = $.extend({}, defaultOptions, options);
        var typeahead = self.options.typeahead || {};

        // When itemValue is set, freeInput should always be false
        if (self.objectItems)
          self.options.freeInput = false;

        makeOptionItemFunction(self.options, 'itemValue');
        makeOptionItemFunction(self.options, 'itemText');
        makeOptionItemFunction(self.options, 'tagClass');

        // for backwards compatibility, self.options.source is deprecated
        if (self.options.source)
          typeahead.source = self.options.source;

        if (typeahead.source && $.fn.typeahead) {
          makeOptionFunction(typeahead, 'source');

          self.$input.typeahead({
            source: function (query, process) {
              function processItems(items) {
                var texts = [];

                for (var i = 0; i < items.length; i++) {
                  var text = self.options.itemText(items[i]);
                  map[text] = items[i];
                  texts.push(text);
                }
                process(texts);
              }

              this.map = {};
              var map = this.map,
                  data = typeahead.source(query);

              if ($.isFunction(data.success)) {
                // support for Angular promises
                data.success(processItems);
              } else {
                // support for functions and jquery promises
                $.when(data)
                 .then(processItems);
              }
            },
            updater: function (text) {
              self.add(this.map[text]);
            },
            matcher: function (text) {
              return (text.toLowerCase().indexOf(this.query.trim().toLowerCase()) !== -1);
            },
            sorter: function (texts) {
              return texts.sort();
            },
            highlighter: function (text) {
              var regex = new RegExp( '(' + this.query + ')', 'gi' );
              return text.replace( regex, "<strong>$1</strong>" );
            }
          });
        }

        self.$container.on('click', $.proxy(function(event) {
          self.$input.focus();
        }, self));

        self.$container.on('keydown', 'input', $.proxy(function(event) {
          var $input = $(event.target),
              $inputWrapper = self.findInputWrapper();

          switch (event.which) {
            // BACKSPACE
            case 8:
              if (doGetCaretPosition($input[0]) === 0) {
                var prev = $inputWrapper.prev();
                if (prev) {
                  self.remove(prev.data('item'));
                }
              }
              break;

            // DELETE
            case 46:
              if (doGetCaretPosition($input[0]) === 0) {
                var next = $inputWrapper.next();
                if (next) {
                  self.remove(next.data('item'));
                }
              }
              break;

            // LEFT ARROW
            case 37:
              // Try to move the input before the previous tag
              var $prevTag = $inputWrapper.prev();
              if ($input.val().length === 0 && $prevTag[0]) {
                $prevTag.before($inputWrapper);
                $input.focus();
              }
              break;
            // RIGHT ARROW
            case 39:
              // Try to move the input after the next tag
              var $nextTag = $inputWrapper.next();
              if ($input.val().length === 0 && $nextTag[0]) {
                $nextTag.after($inputWrapper);
                $input.focus();
              }
              break;
           default:
              // When key corresponds one of the confirmKeys, add current input
              // as a new tag
              if (self.options.freeInput && $.inArray(event.which, self.options.confirmKeys) >= 0) {
                self.add($input.val());
                $input.val('');
                event.preventDefault();
              }
          }

          // Reset internal input's size
          $input.attr('size', Math.max(this.inputSize, $input.val().length));
        }, self));

        // Remove icon clicked
        self.$container.on('click', '[data-role=remove]', $.proxy(function(event) {
          self.remove($(event.target).closest('.tag').data('item'));
        }, self));

        // Only add existing value as tags when using strings as tags
        if (self.options.itemValue === defaultOptions.itemValue) {
          if (self.$element[0].tagName === 'INPUT') {
              self.add(self.$element.val());
          } else {
            $('option', self.$element).each(function() {
              self.add($(this).attr('value'), true);
            });
          }
        }
      },

      /**
       * Removes all tagsinput behaviour and unregsiter all event handlers
       */
      destroy: function() {
        var self = this;

        // Unbind events
        self.$container.off('keypress', 'input');
        self.$container.off('click', '[role=remove]');

        self.$container.remove();
        self.$element.removeData('tagsinput');
        self.$element.show();
      },

      /**
       * Sets focus on the tagsinput 
       */
      focus: function() {
        this.$input.focus();
      },

      /**
       * Returns the internal input element
       */
      input: function() {
        return this.$input;
      },

      /**
       * Returns the element which is wrapped around the internal input. This
       * is normally the $container, but typeahead.js moves the $input element.
       */
      findInputWrapper: function() {
        var elt = this.$input[0],
            container = this.$container[0];
        while(elt && elt.parentNode !== container)
          elt = elt.parentNode;

        return $(elt);
      }
    };

    /**
     * Register JQuery plugin
     */
    $.fn.tagsinput = function(arg1, arg2) {
      var results = [];

      this.each(function() {
        var tagsinput = $(this).data('tagsinput');

        // Initialize a new tags input
        if (!tagsinput) {
          tagsinput = new TagsInput(this, arg1);
          $(this).data('tagsinput', tagsinput);
          results.push(tagsinput);

          if (this.tagName === 'SELECT') {
            $('option', $(this)).attr('selected', 'selected');
          }

          // Init tags from $(this).val()
          $(this).val($(this).val());
        } else {
          // Invoke function on existing tags input
          var retVal = tagsinput[arg1](arg2);
          if (retVal !== undefined)
            results.push(retVal);
        }
      });

      if ( typeof arg1 == 'string') {
        // Return the results from the invoked function calls
        return results.length > 1 ? results : results[0];
      } else {
        return results;
      }
    };

    $.fn.tagsinput.Constructor = TagsInput;
    
    /**
     * Most options support both a string or number as well as a function as 
     * option value. This function makes sure that the option with the given
     * key in the given options is wrapped in a function
     */
    function makeOptionItemFunction(options, key) {
      if (typeof options[key] !== 'function') {
        var propertyName = options[key];
        options[key] = function(item) { return item[propertyName]; };
      }
    }
    function makeOptionFunction(options, key) {
      if (typeof options[key] !== 'function') {
        var value = options[key];
        options[key] = function() { return value; };
      }
    }
    /**
     * HtmlEncodes the given value
     */
    var htmlEncodeContainer = $('<div />');
    function htmlEncode(value) {
      if (value) {
        return htmlEncodeContainer.text(value).html();
      } else {
        return '';
      }
    }

    /**
     * Returns the position of the caret in the given input field
     * http://flightschool.acylt.com/devnotes/caret-position-woes/
     */
    function doGetCaretPosition(oField) {
      var iCaretPos = 0;
      if (document.selection) {
        oField.focus ();
        var oSel = document.selection.createRange();
        oSel.moveStart ('character', -oField.value.length);
        iCaretPos = oSel.text.length;
      } else if (oField.selectionStart || oField.selectionStart == '0') {
        iCaretPos = oField.selectionStart;
      }
      return (iCaretPos);
    }

    /**
     * Initialize tagsinput behaviour on inputs and selects which have
     * data-role=tagsinput
     */
    $(function() {
      $("input[data-role=tagsinput], select[multiple][data-role=tagsinput]").tagsinput();
    });
  })(window.jQuery);

  /*!
   * typeahead.js 0.10.2
   * https://github.com/twitter/typeahead.js
   * Copyright 2013-2014 Twitter, Inc. and other contributors; Licensed MIT
   */

  !function(a){var b={isMsie:function(){return /(msie|trident)/i.test(navigator.userAgent)?navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2]:!1},isBlankString:function(a){return !a||/^\s*$/.test(a)},escapeRegExChars:function(a){return a.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")},isString:function(a){return "string"==typeof a},isNumber:function(a){return "number"==typeof a},isArray:a.isArray,isFunction:a.isFunction,isObject:a.isPlainObject,isUndefined:function(a){return "undefined"==typeof a},bind:a.proxy,each:function(b,c){function d(a,b){return c(b,a)}a.each(b,d);},map:a.map,filter:a.grep,every:function(b,c){var d=!0;return b?(a.each(b,function(a,e){return (d=c.call(null,e,a,b))?void 0:!1}),!!d):d},some:function(b,c){var d=!1;return b?(a.each(b,function(a,e){return (d=c.call(null,e,a,b))?!1:void 0}),!!d):d},mixin:a.extend,getUniqueId:function(){var a=0;return function(){return a++}}(),templatify:function(b){function c(){return String(b)}return a.isFunction(b)?b:c},defer:function(a){setTimeout(a,0);},debounce:function(a,b,c){var d,e;return function(){var f,g,h=this,i=arguments;return f=function(){d=null,c||(e=a.apply(h,i));},g=c&&!d,clearTimeout(d),d=setTimeout(f,b),g&&(e=a.apply(h,i)),e}},throttle:function(a,b){var c,d,e,f,g,h;return g=0,h=function(){g=new Date,e=null,f=a.apply(c,d);},function(){var i=new Date,j=b-(i-g);return c=this,d=arguments,0>=j?(clearTimeout(e),e=null,g=i,f=a.apply(c,d)):e||(e=setTimeout(h,j)),f}},noop:function(){}},c="0.10.2",d=function(){function a(a){return a.split(/\s+/)}function b(a){return a.split(/\W+/)}function c(a){return function(b){return function(c){return a(c[b])}}}return {nonword:b,whitespace:a,obj:{nonword:c(b),whitespace:c(a)}}}(),e=function(){function a(a){this.maxSize=a||100,this.size=0,this.hash={},this.list=new c;}function c(){this.head=this.tail=null;}function d(a,b){this.key=a,this.val=b,this.prev=this.next=null;}return b.mixin(a.prototype,{set:function(a,b){var c,e=this.list.tail;this.size>=this.maxSize&&(this.list.remove(e),delete this.hash[e.key]),(c=this.hash[a])?(c.val=b,this.list.moveToFront(c)):(c=new d(a,b),this.list.add(c),this.hash[a]=c,this.size++);},get:function(a){var b=this.hash[a];return b?(this.list.moveToFront(b),b.val):void 0}}),b.mixin(c.prototype,{add:function(a){this.head&&(a.next=this.head,this.head.prev=a),this.head=a,this.tail=this.tail||a;},remove:function(a){a.prev?a.prev.next=a.next:this.head=a.next,a.next?a.next.prev=a.prev:this.tail=a.prev;},moveToFront:function(a){this.remove(a),this.add(a);}}),a}(),f=function(){function a(a){this.prefix=["__",a,"__"].join(""),this.ttlKey="__ttl__",this.keyMatcher=new RegExp("^"+this.prefix);}function c(){return (new Date).getTime()}function d(a){return JSON.stringify(b.isUndefined(a)?null:a)}function e(a){return JSON.parse(a)}var f,g;try{f=window.localStorage,f.setItem("~~~","!"),f.removeItem("~~~");}catch(h){f=null;}return g=f&&window.JSON?{_prefix:function(a){return this.prefix+a},_ttlKey:function(a){return this._prefix(a)+this.ttlKey},get:function(a){return this.isExpired(a)&&this.remove(a),e(f.getItem(this._prefix(a)))},set:function(a,e,g){return b.isNumber(g)?f.setItem(this._ttlKey(a),d(c()+g)):f.removeItem(this._ttlKey(a)),f.setItem(this._prefix(a),d(e))},remove:function(a){return f.removeItem(this._ttlKey(a)),f.removeItem(this._prefix(a)),this},clear:function(){var a,b,c=[],d=f.length;for(a=0;d>a;a++)(b=f.key(a)).match(this.keyMatcher)&&c.push(b.replace(this.keyMatcher,""));for(a=c.length;a--;)this.remove(c[a]);return this},isExpired:function(a){var d=e(f.getItem(this._ttlKey(a)));return b.isNumber(d)&&c()>d?!0:!1}}:{get:b.noop,set:b.noop,remove:b.noop,clear:b.noop,isExpired:b.noop},b.mixin(a.prototype,g),a}(),g=function(){function c(b){b=b||{},this._send=b.transport?d(b.transport):a.ajax,this._get=b.rateLimiter?b.rateLimiter(this._get):this._get;}function d(c){return function(d,e){function f(a){b.defer(function(){h.resolve(a);});}function g(a){b.defer(function(){h.reject(a);});}var h=a.Deferred();return c(d,e,f,g),h}}var f=0,g={},h=6,i=new e(10);return c.setMaxPendingRequests=function(a){h=a;},c.resetCache=function(){i=new e(10);},b.mixin(c.prototype,{_get:function(a,b,c){function d(b){c&&c(null,b),i.set(a,b);}function e(){c&&c(!0);}function j(){f--,delete g[a],l.onDeckRequestArgs&&(l._get.apply(l,l.onDeckRequestArgs),l.onDeckRequestArgs=null);}var k,l=this;(k=g[a])?k.done(d).fail(e):h>f?(f++,g[a]=this._send(a,b).done(d).fail(e).always(j)):this.onDeckRequestArgs=[].slice.call(arguments,0);},get:function(a,c,d){var e;return b.isFunction(c)&&(d=c,c={}),(e=i.get(a))?b.defer(function(){d&&d(null,e);}):this._get(a,c,d),!!e}}),c}(),h=function(){function c(b){b=b||{},b.datumTokenizer&&b.queryTokenizer||a.error("datumTokenizer and queryTokenizer are both required"),this.datumTokenizer=b.datumTokenizer,this.queryTokenizer=b.queryTokenizer,this.reset();}function d(a){return a=b.filter(a,function(a){return !!a}),a=b.map(a,function(a){return a.toLowerCase()})}function e(){return {ids:[],children:{}}}function f(a){for(var b={},c=[],d=0;d<a.length;d++)b[a[d]]||(b[a[d]]=!0,c.push(a[d]));return c}function g(a,b){function c(a,b){return a-b}var d=0,e=0,f=[];for(a=a.sort(c),b=b.sort(c);d<a.length&&e<b.length;)a[d]<b[e]?d++:a[d]>b[e]?e++:(f.push(a[d]),d++,e++);return f}return b.mixin(c.prototype,{bootstrap:function(a){this.datums=a.datums,this.trie=a.trie;},add:function(a){var c=this;a=b.isArray(a)?a:[a],b.each(a,function(a){var f,g;f=c.datums.push(a)-1,g=d(c.datumTokenizer(a)),b.each(g,function(a){var b,d,g;for(b=c.trie,d=a.split("");g=d.shift();)b=b.children[g]||(b.children[g]=e()),b.ids.push(f);});});},get:function(a){var c,e,h=this;return c=d(this.queryTokenizer(a)),b.each(c,function(a){var b,c,d,f;if(e&&0===e.length)return !1;for(b=h.trie,c=a.split("");b&&(d=c.shift());)b=b.children[d];return b&&0===c.length?(f=b.ids.slice(0),void(e=e?g(e,f):f)):(e=[],!1)}),e?b.map(f(e),function(a){return h.datums[a]}):[]},reset:function(){this.datums=[],this.trie=e();},serialize:function(){return {datums:this.datums,trie:this.trie}}}),c}(),i=function(){function d(a){return a.local||null}function e(d){var e,f;return f={url:null,thumbprint:"",ttl:864e5,filter:null,ajax:{}},(e=d.prefetch||null)&&(e=b.isString(e)?{url:e}:e,e=b.mixin(f,e),e.thumbprint=c+e.thumbprint,e.ajax.type=e.ajax.type||"GET",e.ajax.dataType=e.ajax.dataType||"json",!e.url&&a.error("prefetch requires url to be set")),e}function f(c){function d(a){return function(c){return b.debounce(c,a)}}function e(a){return function(c){return b.throttle(c,a)}}var f,g;return g={url:null,wildcard:"%QUERY",replace:null,rateLimitBy:"debounce",rateLimitWait:300,send:null,filter:null,ajax:{}},(f=c.remote||null)&&(f=b.isString(f)?{url:f}:f,f=b.mixin(g,f),f.rateLimiter=/^throttle$/i.test(f.rateLimitBy)?e(f.rateLimitWait):d(f.rateLimitWait),f.ajax.type=f.ajax.type||"GET",f.ajax.dataType=f.ajax.dataType||"json",delete f.rateLimitBy,delete f.rateLimitWait,!f.url&&a.error("remote requires url to be set")),f}return {local:d,prefetch:e,remote:f}}();!function(c){function e(b){b&&(b.local||b.prefetch||b.remote)||a.error("one of local, prefetch, or remote is required"),this.limit=b.limit||5,this.sorter=j(b.sorter),this.dupDetector=b.dupDetector||k,this.local=i.local(b),this.prefetch=i.prefetch(b),this.remote=i.remote(b),this.cacheKey=this.prefetch?this.prefetch.cacheKey||this.prefetch.url:null,this.index=new h({datumTokenizer:b.datumTokenizer,queryTokenizer:b.queryTokenizer}),this.storage=this.cacheKey?new f(this.cacheKey):null;}function j(a){function c(b){return b.sort(a)}function d(a){return a}return b.isFunction(a)?c:d}function k(){return !1}var l,m;return l=c.Bloodhound,m={data:"data",protocol:"protocol",thumbprint:"thumbprint"},c.Bloodhound=e,e.noConflict=function(){return c.Bloodhound=l,e},e.tokenizers=d,b.mixin(e.prototype,{_loadPrefetch:function(b){function c(a){f.clear(),f.add(b.filter?b.filter(a):a),f._saveToStorage(f.index.serialize(),b.thumbprint,b.ttl);}var d,e,f=this;return (d=this._readFromStorage(b.thumbprint))?(this.index.bootstrap(d),e=a.Deferred().resolve()):e=a.ajax(b.url,b.ajax).done(c),e},_getFromRemote:function(a,b){function c(a,c){b(a?[]:f.remote.filter?f.remote.filter(c):c);}var d,e,f=this;return a=a||"",e=encodeURIComponent(a),d=this.remote.replace?this.remote.replace(this.remote.url,a):this.remote.url.replace(this.remote.wildcard,e),this.transport.get(d,this.remote.ajax,c)},_saveToStorage:function(a,b,c){this.storage&&(this.storage.set(m.data,a,c),this.storage.set(m.protocol,location.protocol,c),this.storage.set(m.thumbprint,b,c));},_readFromStorage:function(a){var b,c={};return this.storage&&(c.data=this.storage.get(m.data),c.protocol=this.storage.get(m.protocol),c.thumbprint=this.storage.get(m.thumbprint)),b=c.thumbprint!==a||c.protocol!==location.protocol,c.data&&!b?c.data:null},_initialize:function(){function c(){e.add(b.isFunction(f)?f():f);}var d,e=this,f=this.local;return d=this.prefetch?this._loadPrefetch(this.prefetch):a.Deferred().resolve(),f&&d.done(c),this.transport=this.remote?new g(this.remote):null,this.initPromise=d.promise()},initialize:function(a){return !this.initPromise||a?this._initialize():this.initPromise},add:function(a){this.index.add(a);},get:function(a,c){function d(a){var d=f.slice(0);b.each(a,function(a){var c;return c=b.some(d,function(b){return e.dupDetector(a,b)}),!c&&d.push(a),d.length<e.limit}),c&&c(e.sorter(d));}var e=this,f=[],g=!1;f=this.index.get(a),f=this.sorter(f).slice(0,this.limit),f.length<this.limit&&this.transport&&(g=this._getFromRemote(a,d)),g||(f.length>0||!this.transport)&&c&&c(f);},clear:function(){this.index.reset();},clearPrefetchCache:function(){this.storage&&this.storage.clear();},clearRemoteCache:function(){this.transport&&g.resetCache();},ttAdapter:function(){return b.bind(this.get,this)}}),e}(this);var j={wrapper:'<span class="twitter-typeahead"></span>',dropdown:'<span class="tt-dropdown-menu"></span>',dataset:'<div class="tt-dataset-%CLASS%"></div>',suggestions:'<span class="tt-suggestions"></span>',suggestion:'<div class="tt-suggestion"></div>'},k={wrapper:{position:"relative",display:"inline-block"},hint:{position:"absolute",top:"0",left:"0",borderColor:"transparent",boxShadow:"none"},input:{position:"relative",verticalAlign:"top",backgroundColor:"transparent"},inputWithNoHint:{position:"relative",verticalAlign:"top"},dropdown:{position:"absolute",top:"100%",left:"0",zIndex:"100",display:"none"},suggestions:{display:"block"},suggestion:{whiteSpace:"nowrap",cursor:"pointer"},suggestionChild:{whiteSpace:"normal"},ltr:{left:"0",right:"auto"},rtl:{left:"auto",right:" 0"}};b.isMsie()&&b.mixin(k.input,{backgroundImage:"url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"}),b.isMsie()&&b.isMsie()<=7&&b.mixin(k.input,{marginTop:"-1px"});var l=function(){function c(b){b&&b.el||a.error("EventBus initialized without el"),this.$el=a(b.el);}var d="typeahead:";return b.mixin(c.prototype,{trigger:function(a){var b=[].slice.call(arguments,1);this.$el.trigger(d+a,b);}}),c}(),m=function(){function a(a,b,c,d){var e;if(!c)return this;for(b=b.split(i),c=d?h(c,d):c,this._callbacks=this._callbacks||{};e=b.shift();)this._callbacks[e]=this._callbacks[e]||{sync:[],async:[]},this._callbacks[e][a].push(c);return this}function b(b,c,d){return a.call(this,"async",b,c,d)}function c(b,c,d){return a.call(this,"sync",b,c,d)}function d(a){var b;if(!this._callbacks)return this;for(a=a.split(i);b=a.shift();)delete this._callbacks[b];return this}function e(a){var b,c,d,e,g;if(!this._callbacks)return this;for(a=a.split(i),d=[].slice.call(arguments,1);(b=a.shift())&&(c=this._callbacks[b]);)e=f(c.sync,this,[b].concat(d)),g=f(c.async,this,[b].concat(d)),e()&&j(g);return this}function f(a,b,c){function d(){for(var d,e=0;!d&&e<a.length;e+=1)d=a[e].apply(b,c)===!1;return !d}return d}function g(){return window.setImmediate?function(a){setImmediate(function(){a();});}:function(a){setTimeout(function(){a();},0);}}function h(a,b){return a.bind?a.bind(b):function(){a.apply(b,[].slice.call(arguments,0));}}var i=/\s+/,j=g();return {onSync:c,onAsync:b,off:d,trigger:e}}(),n=function(a){function c(a,c,d){for(var e,f=[],g=0;g<a.length;g++)f.push(b.escapeRegExChars(a[g]));return e=d?"\\b("+f.join("|")+")\\b":"("+f.join("|")+")",c?new RegExp(e):new RegExp(e,"i")}var d={node:null,pattern:null,tagName:"strong",className:null,wordsOnly:!1,caseSensitive:!1};return function(e){function f(b){var c,d;return (c=h.exec(b.data))&&(wrapperNode=a.createElement(e.tagName),e.className&&(wrapperNode.className=e.className),d=b.splitText(c.index),d.splitText(c[0].length),wrapperNode.appendChild(d.cloneNode(!0)),b.parentNode.replaceChild(wrapperNode,d)),!!c}function g(a,b){for(var c,d=3,e=0;e<a.childNodes.length;e++)c=a.childNodes[e],c.nodeType===d?e+=b(c)?1:0:g(c,b);}var h;e=b.mixin({},d,e),e.node&&e.pattern&&(e.pattern=b.isArray(e.pattern)?e.pattern:[e.pattern],h=c(e.pattern,e.caseSensitive,e.wordsOnly),g(e.node,f));}}(window.document),o=function(){function c(c){var e,f,h,i,j=this;c=c||{},c.input||a.error("input is missing"),e=b.bind(this._onBlur,this),f=b.bind(this._onFocus,this),h=b.bind(this._onKeydown,this),i=b.bind(this._onInput,this),this.$hint=a(c.hint),this.$input=a(c.input).on("blur.tt",e).on("focus.tt",f).on("keydown.tt",h),0===this.$hint.length&&(this.setHint=this.getHint=this.clearHint=this.clearHintIfInvalid=b.noop),b.isMsie()?this.$input.on("keydown.tt keypress.tt cut.tt paste.tt",function(a){g[a.which||a.keyCode]||b.defer(b.bind(j._onInput,j,a));}):this.$input.on("input.tt",i),this.query=this.$input.val(),this.$overflowHelper=d(this.$input);}function d(b){return a('<pre aria-hidden="true"></pre>').css({position:"absolute",visibility:"hidden",whiteSpace:"pre",fontFamily:b.css("font-family"),fontSize:b.css("font-size"),fontStyle:b.css("font-style"),fontVariant:b.css("font-variant"),fontWeight:b.css("font-weight"),wordSpacing:b.css("word-spacing"),letterSpacing:b.css("letter-spacing"),textIndent:b.css("text-indent"),textRendering:b.css("text-rendering"),textTransform:b.css("text-transform")}).insertAfter(b)}function e(a,b){return c.normalizeQuery(a)===c.normalizeQuery(b)}function f(a){return a.altKey||a.ctrlKey||a.metaKey||a.shiftKey}var g;return g={9:"tab",27:"esc",37:"left",39:"right",13:"enter",38:"up",40:"down"},c.normalizeQuery=function(a){return (a||"").replace(/^\s*/g,"").replace(/\s{2,}/g," ")},b.mixin(c.prototype,m,{_onBlur:function(){this.resetInputValue(),this.trigger("blurred");},_onFocus:function(){this.trigger("focused");},_onKeydown:function(a){var b=g[a.which||a.keyCode];this._managePreventDefault(b,a),b&&this._shouldTrigger(b,a)&&this.trigger(b+"Keyed",a);},_onInput:function(){this._checkInputValue();},_managePreventDefault:function(a,b){var c,d,e;switch(a){case"tab":d=this.getHint(),e=this.getInputValue(),c=d&&d!==e&&!f(b);break;case"up":case"down":c=!f(b);break;default:c=!1;}c&&b.preventDefault();},_shouldTrigger:function(a,b){var c;switch(a){case"tab":c=!f(b);break;default:c=!0;}return c},_checkInputValue:function(){var a,b,c;a=this.getInputValue(),b=e(a,this.query),c=b?this.query.length!==a.length:!1,b?c&&this.trigger("whitespaceChanged",this.query):this.trigger("queryChanged",this.query=a);},focus:function(){this.$input.focus();},blur:function(){this.$input.blur();},getQuery:function(){return this.query},setQuery:function(a){this.query=a;},getInputValue:function(){return this.$input.val()},setInputValue:function(a,b){this.$input.val(a),b?this.clearHint():this._checkInputValue();},resetInputValue:function(){this.setInputValue(this.query,!0);},getHint:function(){return this.$hint.val()},setHint:function(a){this.$hint.val(a);},clearHint:function(){this.setHint("");},clearHintIfInvalid:function(){var a,b,c,d;a=this.getInputValue(),b=this.getHint(),c=a!==b&&0===b.indexOf(a),d=""!==a&&c&&!this.hasOverflow(),!d&&this.clearHint();},getLanguageDirection:function(){return (this.$input.css("direction")||"ltr").toLowerCase()},hasOverflow:function(){var a=this.$input.width()-2;return this.$overflowHelper.text(this.getInputValue()),this.$overflowHelper.width()>=a},isCursorAtEnd:function(){var a,c,d;return a=this.$input.val().length,c=this.$input[0].selectionStart,b.isNumber(c)?c===a:document.selection?(d=document.selection.createRange(),d.moveStart("character",-a),a===d.text.length):!0},destroy:function(){this.$hint.off(".tt"),this.$input.off(".tt"),this.$hint=this.$input=this.$overflowHelper=null;}}),c}(),p=function(){function c(c){c=c||{},c.templates=c.templates||{},c.source||a.error("missing source"),c.name&&!f(c.name)&&a.error("invalid dataset name: "+c.name),this.query=null,this.highlight=!!c.highlight,this.name=c.name||b.getUniqueId(),this.source=c.source,this.displayFn=d(c.display||c.displayKey),this.templates=e(c.templates,this.displayFn),this.$el=a(j.dataset.replace("%CLASS%",this.name));}function d(a){function c(b){return b[a]}return a=a||"value",b.isFunction(a)?a:c}function e(a,c){function d(a){return "<p>"+c(a)+"</p>"}return {empty:a.empty&&b.templatify(a.empty),header:a.header&&b.templatify(a.header),footer:a.footer&&b.templatify(a.footer),suggestion:a.suggestion||d}}function f(a){return /^[_a-zA-Z0-9-]+$/.test(a)}var g="ttDataset",h="ttValue",i="ttDatum";return c.extractDatasetName=function(b){return a(b).data(g)},c.extractValue=function(b){return a(b).data(h)},c.extractDatum=function(b){return a(b).data(i)},b.mixin(c.prototype,m,{_render:function(c,d){function e(){return p.templates.empty({query:c,isEmpty:!0})}function f(){function e(b){var c;return c=a(j.suggestion).append(p.templates.suggestion(b)).data(g,p.name).data(h,p.displayFn(b)).data(i,b),c.children().each(function(){a(this).css(k.suggestionChild);}),c}var f,l;return f=a(j.suggestions).css(k.suggestions),l=b.map(d,e),f.append.apply(f,l),p.highlight&&n({node:f[0],pattern:c}),f}function l(){return p.templates.header({query:c,isEmpty:!o})}function m(){return p.templates.footer({query:c,isEmpty:!o})}if(this.$el){var o,p=this;this.$el.empty(),o=d&&d.length,!o&&this.templates.empty?this.$el.html(e()).prepend(p.templates.header?l():null).append(p.templates.footer?m():null):o&&this.$el.html(f()).prepend(p.templates.header?l():null).append(p.templates.footer?m():null),this.trigger("rendered");}},getRoot:function(){return this.$el},update:function(a){function b(b){c.canceled||a!==c.query||c._render(a,b);}var c=this;this.query=a,this.canceled=!1,this.source(a,b);},cancel:function(){this.canceled=!0;},clear:function(){this.cancel(),this.$el.empty(),this.trigger("rendered");},isEmpty:function(){return this.$el.is(":empty")},destroy:function(){this.$el=null;}}),c}(),q=function(){function c(c){var e,f,g,h=this;c=c||{},c.menu||a.error("menu is required"),this.isOpen=!1,this.isEmpty=!0,this.datasets=b.map(c.datasets,d),e=b.bind(this._onSuggestionClick,this),f=b.bind(this._onSuggestionMouseEnter,this),g=b.bind(this._onSuggestionMouseLeave,this),this.$menu=a(c.menu).on("click.tt",".tt-suggestion",e).on("mouseenter.tt",".tt-suggestion",f).on("mouseleave.tt",".tt-suggestion",g),b.each(this.datasets,function(a){h.$menu.append(a.getRoot()),a.onSync("rendered",h._onRendered,h);});}function d(a){return new p(a)}return b.mixin(c.prototype,m,{_onSuggestionClick:function(b){this.trigger("suggestionClicked",a(b.currentTarget));},_onSuggestionMouseEnter:function(b){this._removeCursor(),this._setCursor(a(b.currentTarget),!0);},_onSuggestionMouseLeave:function(){this._removeCursor();},_onRendered:function(){function a(a){return a.isEmpty()}this.isEmpty=b.every(this.datasets,a),this.isEmpty?this._hide():this.isOpen&&this._show(),this.trigger("datasetRendered");},_hide:function(){this.$menu.hide();},_show:function(){this.$menu.css("display","block");},_getSuggestions:function(){return this.$menu.find(".tt-suggestion")},_getCursor:function(){return this.$menu.find(".tt-cursor").first()},_setCursor:function(a,b){a.first().addClass("tt-cursor"),!b&&this.trigger("cursorMoved");},_removeCursor:function(){this._getCursor().removeClass("tt-cursor");},_moveCursor:function(a){var b,c,d,e;if(this.isOpen){if(c=this._getCursor(),b=this._getSuggestions(),this._removeCursor(),d=b.index(c)+a,d=(d+1)%(b.length+1)-1,-1===d)return void this.trigger("cursorRemoved");-1>d&&(d=b.length-1),this._setCursor(e=b.eq(d)),this._ensureVisible(e);}},_ensureVisible:function(a){var b,c,d,e;b=a.position().top,c=b+a.outerHeight(!0),d=this.$menu.scrollTop(),e=this.$menu.height()+parseInt(this.$menu.css("paddingTop"),10)+parseInt(this.$menu.css("paddingBottom"),10),0>b?this.$menu.scrollTop(d+b):c>e&&this.$menu.scrollTop(d+(c-e));},close:function(){this.isOpen&&(this.isOpen=!1,this._removeCursor(),this._hide(),this.trigger("closed"));},open:function(){this.isOpen||(this.isOpen=!0,!this.isEmpty&&this._show(),this.trigger("opened"));},setLanguageDirection:function(a){this.$menu.css("ltr"===a?k.ltr:k.rtl);},moveCursorUp:function(){this._moveCursor(-1);},moveCursorDown:function(){this._moveCursor(1);},getDatumForSuggestion:function(a){var b=null;return a.length&&(b={raw:p.extractDatum(a),value:p.extractValue(a),datasetName:p.extractDatasetName(a)}),b},getDatumForCursor:function(){return this.getDatumForSuggestion(this._getCursor().first())},getDatumForTopSuggestion:function(){return this.getDatumForSuggestion(this._getSuggestions().first())},update:function(a){function c(b){b.update(a);}b.each(this.datasets,c);},empty:function(){function a(a){a.clear();}b.each(this.datasets,a),this.isEmpty=!0;},isVisible:function(){return this.isOpen&&!this.isEmpty},destroy:function(){function a(a){a.destroy();}this.$menu.off(".tt"),this.$menu=null,b.each(this.datasets,a);}}),c}(),r=function(){function c(c){var e,f,g;c=c||{},c.input||a.error("missing input"),this.isActivated=!1,this.autoselect=!!c.autoselect,this.minLength=b.isNumber(c.minLength)?c.minLength:1,this.$node=d(c.input,c.withHint),e=this.$node.find(".tt-dropdown-menu"),f=this.$node.find(".tt-input"),g=this.$node.find(".tt-hint"),f.on("blur.tt",function(a){var c,d,g;c=document.activeElement,d=e.is(c),g=e.has(c).length>0,b.isMsie()&&(d||g)&&(a.preventDefault(),a.stopImmediatePropagation(),b.defer(function(){f.focus();}));}),e.on("mousedown.tt",function(a){a.preventDefault();}),this.eventBus=c.eventBus||new l({el:f}),this.dropdown=new q({menu:e,datasets:c.datasets}).onSync("suggestionClicked",this._onSuggestionClicked,this).onSync("cursorMoved",this._onCursorMoved,this).onSync("cursorRemoved",this._onCursorRemoved,this).onSync("opened",this._onOpened,this).onSync("closed",this._onClosed,this).onAsync("datasetRendered",this._onDatasetRendered,this),this.input=new o({input:f,hint:g}).onSync("focused",this._onFocused,this).onSync("blurred",this._onBlurred,this).onSync("enterKeyed",this._onEnterKeyed,this).onSync("tabKeyed",this._onTabKeyed,this).onSync("escKeyed",this._onEscKeyed,this).onSync("upKeyed",this._onUpKeyed,this).onSync("downKeyed",this._onDownKeyed,this).onSync("leftKeyed",this._onLeftKeyed,this).onSync("rightKeyed",this._onRightKeyed,this).onSync("queryChanged",this._onQueryChanged,this).onSync("whitespaceChanged",this._onWhitespaceChanged,this),this._setLanguageDirection();}function d(b,c){var d,f,h,i;d=a(b),f=a(j.wrapper).css(k.wrapper),h=a(j.dropdown).css(k.dropdown),i=d.clone().css(k.hint).css(e(d)),i.val("").removeData().addClass("tt-hint").removeAttr("id name placeholder").prop("disabled",!0).attr({autocomplete:"off",spellcheck:"false"}),d.data(g,{dir:d.attr("dir"),autocomplete:d.attr("autocomplete"),spellcheck:d.attr("spellcheck"),style:d.attr("style")}),d.addClass("tt-input").attr({autocomplete:"off",spellcheck:!1}).css(c?k.input:k.inputWithNoHint);try{!d.attr("dir")&&d.attr("dir","auto");}catch(l){}return d.wrap(f).parent().prepend(c?i:null).append(h)}function e(a){return {backgroundAttachment:a.css("background-attachment"),backgroundClip:a.css("background-clip"),backgroundColor:a.css("background-color"),backgroundImage:a.css("background-image"),backgroundOrigin:a.css("background-origin"),backgroundPosition:a.css("background-position"),backgroundRepeat:a.css("background-repeat"),backgroundSize:a.css("background-size")}}function f(a){var c=a.find(".tt-input");b.each(c.data(g),function(a,d){b.isUndefined(a)?c.removeAttr(d):c.attr(d,a);}),c.detach().removeData(g).removeClass("tt-input").insertAfter(a),a.remove();}var g="ttAttrs";return b.mixin(c.prototype,{_onSuggestionClicked:function(a,b){var c;(c=this.dropdown.getDatumForSuggestion(b))&&this._select(c);},_onCursorMoved:function(){var a=this.dropdown.getDatumForCursor();this.input.setInputValue(a.value,!0),this.eventBus.trigger("cursorchanged",a.raw,a.datasetName);},_onCursorRemoved:function(){this.input.resetInputValue(),this._updateHint();},_onDatasetRendered:function(){this._updateHint();},_onOpened:function(){this._updateHint(),this.eventBus.trigger("opened");},_onClosed:function(){this.input.clearHint(),this.eventBus.trigger("closed");},_onFocused:function(){this.isActivated=!0,this.dropdown.open();},_onBlurred:function(){this.isActivated=!1,this.dropdown.empty(),this.dropdown.close();},_onEnterKeyed:function(a,b){var c,d;c=this.dropdown.getDatumForCursor(),d=this.dropdown.getDatumForTopSuggestion(),c?(this._select(c),b.preventDefault()):this.autoselect&&d&&(this._select(d),b.preventDefault());},_onTabKeyed:function(a,b){var c;(c=this.dropdown.getDatumForCursor())?(this._select(c),b.preventDefault()):this._autocomplete(!0);},_onEscKeyed:function(){this.dropdown.close(),this.input.resetInputValue();},_onUpKeyed:function(){var a=this.input.getQuery();this.dropdown.isEmpty&&a.length>=this.minLength?this.dropdown.update(a):this.dropdown.moveCursorUp(),this.dropdown.open();},_onDownKeyed:function(){var a=this.input.getQuery();this.dropdown.isEmpty&&a.length>=this.minLength?this.dropdown.update(a):this.dropdown.moveCursorDown(),this.dropdown.open();},_onLeftKeyed:function(){"rtl"===this.dir&&this._autocomplete();},_onRightKeyed:function(){"ltr"===this.dir&&this._autocomplete();},_onQueryChanged:function(a,b){this.input.clearHintIfInvalid(),b.length>=this.minLength?this.dropdown.update(b):this.dropdown.empty(),this.dropdown.open(),this._setLanguageDirection();},_onWhitespaceChanged:function(){this._updateHint(),this.dropdown.open();},_setLanguageDirection:function(){var a;this.dir!==(a=this.input.getLanguageDirection())&&(this.dir=a,this.$node.css("direction",a),this.dropdown.setLanguageDirection(a));},_updateHint:function(){var a,c,d,e,f,g;a=this.dropdown.getDatumForTopSuggestion(),a&&this.dropdown.isVisible()&&!this.input.hasOverflow()?(c=this.input.getInputValue(),d=o.normalizeQuery(c),e=b.escapeRegExChars(d),f=new RegExp("^(?:"+e+")(.+$)","i"),g=f.exec(a.value),g?this.input.setHint(c+g[1]):this.input.clearHint()):this.input.clearHint();},_autocomplete:function(a){var b,c,d,e;b=this.input.getHint(),c=this.input.getQuery(),d=a||this.input.isCursorAtEnd(),b&&c!==b&&d&&(e=this.dropdown.getDatumForTopSuggestion(),e&&this.input.setInputValue(e.value),this.eventBus.trigger("autocompleted",e.raw,e.datasetName));},_select:function(a){this.input.setQuery(a.value),this.input.setInputValue(a.value,!0),this._setLanguageDirection(),this.eventBus.trigger("selected",a.raw,a.datasetName),this.dropdown.close(),b.defer(b.bind(this.dropdown.empty,this.dropdown));},open:function(){this.dropdown.open();},close:function(){this.dropdown.close();},setVal:function(a){this.isActivated?this.input.setInputValue(a):(this.input.setQuery(a),this.input.setInputValue(a,!0)),this._setLanguageDirection();},getVal:function(){return this.input.getQuery()},destroy:function(){this.input.destroy(),this.dropdown.destroy(),f(this.$node),this.$node=null;}}),c}();!function(){var c,d,e;c=a.fn.typeahead,d="ttTypeahead",e={initialize:function(c,e){function f(){var g,h=a(this);b.each(e,function(a){a.highlight=!!c.highlight;}),g=new r({input:h,eventBus:new l({el:h}),withHint:b.isUndefined(c.hint)?!0:!!c.hint,minLength:c.minLength,autoselect:c.autoselect,datasets:e}),h.data(d,g);}return e=b.isArray(e)?e:[].slice.call(arguments,1),c=c||{},this.each(f)},open:function(){function b(){var b,c=a(this);(b=c.data(d))&&b.open();}return this.each(b)},close:function(){function b(){var b,c=a(this);(b=c.data(d))&&b.close();}return this.each(b)},val:function(b){function c(){var c,e=a(this);(c=e.data(d))&&c.setVal(b);}function e(a){var b,c;return (b=a.data(d))&&(c=b.getVal()),c}return arguments.length?this.each(c):e(this.first())},destroy:function(){function b(){var b,c=a(this);(b=c.data(d))&&(b.destroy(),c.removeData(d));}return this.each(b)}},a.fn.typeahead=function(a){return e[a]?e[a].apply(this,[].slice.call(arguments,1)):e.initialize.apply(this,arguments)},a.fn.typeahead.noConflict=function(){return a.fn.typeahead=c,this};}();}(window.jQuery);

  /*
   * Leaflet-IIIF 3.0.0
   * IIIF Viewer for Leaflet
   * by Jack Reed, @mejackreed
   */

  L.TileLayer.Iiif = L.TileLayer.extend({
    options: {
      continuousWorld: true,
      tileSize: 256,
      updateWhenIdle: true,
      tileFormat: 'jpg',
      fitBounds: true,
      setMaxBounds: false
    },

    initialize: function(url, options) {
      options = typeof options !== 'undefined' ? options : {};

      if (options.maxZoom) {
        this._customMaxZoom = true;
      }

      // Check for explicit tileSize set
      if (options.tileSize) {
        this._explicitTileSize = true;
      }

      // Check for an explicit quality
      if (options.quality) {
        this._explicitQuality = true;
      }

      options = L.setOptions(this, options);
      this._infoPromise = null;
      this._infoUrl = url;
      this._baseUrl = this._templateUrl();
      this._getInfo();
    },
    getTileUrl: function(coords) {
      var _this = this,
        x = coords.x,
        y = (coords.y),
        zoom = _this._getZoomForUrl(),
        scale = Math.pow(2, _this.maxNativeZoom - zoom),
        tileBaseSize = _this.options.tileSize * scale,
        minx = (x * tileBaseSize),
        miny = (y * tileBaseSize),
        maxx = Math.min(minx + tileBaseSize, _this.x),
        maxy = Math.min(miny + tileBaseSize, _this.y);

      var xDiff = (maxx - minx);
      var yDiff = (maxy - miny);

      // Canonical URI Syntax for v2
      var size = Math.ceil(xDiff / scale) + ',';
      if (_this.type === 'ImageService3') {
        // Cannonical URI Syntax for v3
        size = size + Math.ceil(yDiff / scale);
      }

      return L.Util.template(this._baseUrl, L.extend({
        format: _this.options.tileFormat,
        quality: _this.quality,
        region: [minx, miny, xDiff, yDiff].join(','),
        rotation: 0,
        size: size
      }, this.options));
    },
    onAdd: function(map) {
      var _this = this;

      // Wait for info.json fetch and parse to complete
      Promise.all([_this._infoPromise]).then(function() {
        // Store unmutated imageSizes
        _this._imageSizesOriginal = _this._imageSizes.slice(0);

        // Set maxZoom for map
        map._layersMaxZoom = _this.maxZoom;

        // Call add TileLayer
        L.TileLayer.prototype.onAdd.call(_this, map);

        // Set minZoom and minNativeZoom based on how the imageSizes match up
        var smallestImage = _this._imageSizes[0];
        var mapSize = _this._map.getSize();
        var newMinZoom = 0;
        // Loop back through 5 times to see if a better fit can be found.
        for (var i = 1; i <= 5; i++) {
          if (smallestImage.x > mapSize.x || smallestImage.y > mapSize.y) {
            smallestImage = smallestImage.divideBy(2);
            _this._imageSizes.unshift(smallestImage);
            newMinZoom = -i;
          } else {
            break;
          }
        }
        _this.options.minZoom = newMinZoom;
        _this.options.minNativeZoom = newMinZoom;
        _this._prev_map_layersMinZoom = _this._map._layersMinZoom;
        _this._map._layersMinZoom = newMinZoom;

        if (_this.options.fitBounds) {
          _this._fitBounds();
        }

        if(_this.options.setMaxBounds) {
          _this._setMaxBounds();
        }

        // Reset tile sizes to handle non 256x256 IIIF tiles
        _this.on('tileload', function(tile, url) {

          var height = tile.tile.naturalHeight,
            width = tile.tile.naturalWidth;

          // No need to resize if tile is 256 x 256
          if (height === 256 && width === 256) return;

          tile.tile.style.width = width + 'px';
          tile.tile.style.height = height + 'px';

        });
      })
      .catch(function(err){
          console.error(err);
      });
    },
    onRemove: function(map) {
      var _this = this;

      map._layersMinZoom = _this._prev_map_layersMinZoom;
      _this._imageSizes = _this._imageSizesOriginal;

      // Remove maxBounds set for this image
      if(_this.options.setMaxBounds) {
        map.setMaxBounds(null);
      }

      // Call remove TileLayer
      L.TileLayer.prototype.onRemove.call(_this, map);

    },
    _fitBounds: function() {
      var _this = this;

      // Find best zoom level and center map
      var initialZoom = _this._getInitialZoom(_this._map.getSize());
      var offset = _this._imageSizes.length - 1 - _this.options.maxNativeZoom;
      var imageSize = _this._imageSizes[initialZoom + offset];
      var sw = _this._map.options.crs.pointToLatLng(L.point(0, imageSize.y), initialZoom);
      var ne = _this._map.options.crs.pointToLatLng(L.point(imageSize.x, 0), initialZoom);
      var bounds = L.latLngBounds(sw, ne);

      _this._map.fitBounds(bounds, true);
    },
    _setMaxBounds: function() {
      var _this = this;

      // Find best zoom level, center map, and constrain viewer
      var initialZoom = _this._getInitialZoom(_this._map.getSize());
      var imageSize = _this._imageSizes[initialZoom];
      var sw = _this._map.options.crs.pointToLatLng(L.point(0, imageSize.y), initialZoom);
      var ne = _this._map.options.crs.pointToLatLng(L.point(imageSize.x, 0), initialZoom);
      var bounds = L.latLngBounds(sw, ne);

      _this._map.setMaxBounds(bounds, true);
    },
    _getInfo: function() {
      var _this = this;

      _this._infoPromise = fetch(_this._infoUrl)
        .then(function(response) {
          return response.json();
        })
        .catch(function(err){
            console.error(err);
        })
        .then(function(data) {
          _this.y = data.height;
          _this.x = data.width;

          var tierSizes = [],
            imageSizes = [],
            scale,
            width_,
            height_,
            tilesX_,
            tilesY_;

          // Set quality based off of IIIF version
          if (data.profile instanceof Array) {
            _this.profile = data.profile[0];
          }else {
            _this.profile = data.profile;
          }
          _this.type = data.type;

          _this._setQuality();

          // Unless an explicit tileSize is set, use a preferred tileSize
          if (!_this._explicitTileSize) {
            // Set the default first
            _this.options.tileSize = 256;
            if (data.tiles) {
              // Image API 2.0 Case
              _this.options.tileSize = data.tiles[0].width;
            } else if (data.tile_width){
              // Image API 1.1 Case
              _this.options.tileSize = data.tile_width;
            }
          }

          function ceilLog2(x) {
            return Math.ceil(Math.log(x) / Math.LN2);
          }
          // Calculates maximum native zoom for the layer
          _this.maxNativeZoom = Math.max(
            ceilLog2(_this.x / _this.options.tileSize),
            ceilLog2(_this.y / _this.options.tileSize),
            0
          );
          _this.options.maxNativeZoom = _this.maxNativeZoom;

          // Enable zooming further than native if maxZoom option supplied
          if (_this._customMaxZoom && _this.options.maxZoom > _this.maxNativeZoom) {
            _this.maxZoom = _this.options.maxZoom;
          }
          else {
            _this.maxZoom = _this.maxNativeZoom;
          }

          for (var i = 0; i <= _this.maxZoom; i++) {
            scale = Math.pow(2, _this.maxNativeZoom - i);
            width_ = Math.ceil(_this.x / scale);
            height_ = Math.ceil(_this.y / scale);
            tilesX_ = Math.ceil(width_ / _this.options.tileSize);
            tilesY_ = Math.ceil(height_ / _this.options.tileSize);
            tierSizes.push([tilesX_, tilesY_]);
            imageSizes.push(L.point(width_,height_));
          }

          _this._tierSizes = tierSizes;
          _this._imageSizes = imageSizes;
        })
        .catch(function(err){
            console.error(err);
        });

    },

    _setQuality: function() {
      var _this = this;
      var profileToCheck = _this.profile;

      if (_this._explicitQuality) {
        return;
      }

      // If profile is an object
      if (typeof(profileToCheck) === 'object') {
        profileToCheck = profileToCheck['@id'];
      }

      // Set the quality based on the IIIF compliance level
      switch (true) {
        case /^http:\/\/library.stanford.edu\/iiif\/image-api\/1.1\/compliance.html.*$/.test(profileToCheck):
          _this.options.quality = 'native';
          break;
        // Assume later profiles and set to default
        default:
          _this.options.quality = 'default';
          break;
      }
    },

    _infoToBaseUrl: function() {
      return this._infoUrl.replace('info.json', '');
    },
    _templateUrl: function() {
      return this._infoToBaseUrl() + '{region}/{size}/{rotation}/{quality}.{format}';
    },
    _isValidTile: function(coords) {
      var _this = this;
      var zoom = _this._getZoomForUrl();
      var sizes = _this._tierSizes[zoom];
      var x = coords.x;
      var y = coords.y;
      if (zoom < 0 && x >= 0 && y >= 0) {
        return true;
      }

      if (!sizes) return false;
      if (x < 0 || sizes[0] <= x || y < 0 || sizes[1] <= y) {
        return false;
      }else {
        return true;
      }
    },
    _tileShouldBeLoaded: function(coords) {
      return this._isValidTile(coords);
    },
    _getInitialZoom: function (mapSize) {
      var _this = this;
      var tolerance = 0.8;
      var imageSize;
      // Calculate an offset between the zoom levels and the array accessors
      var offset = _this._imageSizes.length - 1 - _this.options.maxNativeZoom;
      for (var i = _this._imageSizes.length - 1; i >= 0; i--) {
        imageSize = _this._imageSizes[i];
        if (imageSize.x * tolerance < mapSize.x && imageSize.y * tolerance < mapSize.y) {
          return i - offset;
        }
      }
      // return a default zoom
      return 2;
    }
  });

  L.tileLayer.iiif = function(url, options) {
    return new L.TileLayer.Iiif(url, options);
  };

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var Leaflet_Editable = {exports: {}};

  (function (module, exports) {
  	(function (factory, window) {
  	    /*globals define, module, require*/

  	    // define an AMD module that relies on 'leaflet'
  	    {
  	        module.exports = factory(require$$0);
  	    }

  	    // attach your plugin to the global 'L' variable
  	    if(typeof window !== 'undefined' && window.L){
  	        factory(window.L);
  	    }

  	}(function (L) {
  	    // miniclass CancelableEvent (Event objects)
  	    // method cancel()
  	    // Cancel any subsequent action.

  	    // miniclass VertexEvent (Event objects)
  	    // property vertex: VertexMarker
  	    // The vertex that fires the event.

  	    // miniclass ShapeEvent (Event objects)
  	    // property shape: Array
  	    // The shape (LatLngs array) subject of the action.

  	    // miniclass CancelableVertexEvent (Event objects)
  	    // inherits VertexEvent
  	    // inherits CancelableEvent

  	    // miniclass CancelableShapeEvent (Event objects)
  	    // inherits ShapeEvent
  	    // inherits CancelableEvent

  	    // miniclass LayerEvent (Event objects)
  	    // property layer: object
  	    // The Layer (Marker, Polyline) subject of the action.

  	    // namespace Editable; class Editable; aka L.Editable
  	    // Main edition handler. By default, it is attached to the map
  	    // as `map.editTools` property.
  	    // Leaflet.Editable is made to be fully extendable. You have three ways to customize
  	    // the behaviour: using options, listening to events, or extending.
  	    L.Editable = L.Evented.extend({

  	        statics: {
  	            FORWARD: 1,
  	            BACKWARD: -1
  	        },

  	        options: {

  	            // You can pass them when creating a map using the `editOptions` key.
  	            // option zIndex: int = 1000
  	            // The default zIndex of the editing tools.
  	            zIndex: 1000,

  	            // option polygonClass: class = L.Polygon
  	            // Class to be used when creating a new Polygon.
  	            polygonClass: L.Polygon,

  	            // option polylineClass: class = L.Polyline
  	            // Class to be used when creating a new Polyline.
  	            polylineClass: L.Polyline,

  	            // option markerClass: class = L.Marker
  	            // Class to be used when creating a new Marker.
  	            markerClass: L.Marker,

  	            // option rectangleClass: class = L.Rectangle
  	            // Class to be used when creating a new Rectangle.
  	            rectangleClass: L.Rectangle,

  	            // option circleClass: class = L.Circle
  	            // Class to be used when creating a new Circle.
  	            circleClass: L.Circle,

  	            // option drawingCSSClass: string = 'leaflet-editable-drawing'
  	            // CSS class to be added to the map container while drawing.
  	            drawingCSSClass: 'leaflet-editable-drawing',

  	            // option drawingCursor: const = 'crosshair'
  	            // Cursor mode set to the map while drawing.
  	            drawingCursor: 'crosshair',

  	            // option editLayer: Layer = new L.LayerGroup()
  	            // Layer used to store edit tools (vertex, line guide).
  	            editLayer: undefined,

  	            // option featuresLayer: Layer = new L.LayerGroup()
  	            // Default layer used to store drawn features (Marker, Polyline).
  	            featuresLayer: undefined,

  	            // option polylineEditorClass: class = PolylineEditor
  	            // Class to be used as Polyline editor.
  	            polylineEditorClass: undefined,

  	            // option polygonEditorClass: class = PolygonEditor
  	            // Class to be used as Polygon editor.
  	            polygonEditorClass: undefined,

  	            // option markerEditorClass: class = MarkerEditor
  	            // Class to be used as Marker editor.
  	            markerEditorClass: undefined,

  	            // option rectangleEditorClass: class = RectangleEditor
  	            // Class to be used as Rectangle editor.
  	            rectangleEditorClass: undefined,

  	            // option circleEditorClass: class = CircleEditor
  	            // Class to be used as Circle editor.
  	            circleEditorClass: undefined,

  	            // option lineGuideOptions: hash = {}
  	            // Options to be passed to the line guides.
  	            lineGuideOptions: {},

  	            // option skipMiddleMarkers: boolean = false
  	            // Set this to true if you don't want middle markers.
  	            skipMiddleMarkers: false

  	        },

  	        initialize: function (map, options) {
  	            L.setOptions(this, options);
  	            this._lastZIndex = this.options.zIndex;
  	            this.map = map;
  	            this.editLayer = this.createEditLayer();
  	            this.featuresLayer = this.createFeaturesLayer();
  	            this.forwardLineGuide = this.createLineGuide();
  	            this.backwardLineGuide = this.createLineGuide();
  	        },

  	        fireAndForward: function (type, e) {
  	            e = e || {};
  	            e.editTools = this;
  	            this.fire(type, e);
  	            this.map.fire(type, e);
  	        },

  	        createLineGuide: function () {
  	            var options = L.extend({dashArray: '5,10', weight: 1, interactive: false}, this.options.lineGuideOptions);
  	            return L.polyline([], options);
  	        },

  	        createVertexIcon: function (options) {
  	            return L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);
  	        },

  	        createEditLayer: function () {
  	            return this.options.editLayer || new L.LayerGroup().addTo(this.map);
  	        },

  	        createFeaturesLayer: function () {
  	            return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);
  	        },

  	        moveForwardLineGuide: function (latlng) {
  	            if (this.forwardLineGuide._latlngs.length) {
  	                this.forwardLineGuide._latlngs[1] = latlng;
  	                this.forwardLineGuide._bounds.extend(latlng);
  	                this.forwardLineGuide.redraw();
  	            }
  	        },

  	        moveBackwardLineGuide: function (latlng) {
  	            if (this.backwardLineGuide._latlngs.length) {
  	                this.backwardLineGuide._latlngs[1] = latlng;
  	                this.backwardLineGuide._bounds.extend(latlng);
  	                this.backwardLineGuide.redraw();
  	            }
  	        },

  	        anchorForwardLineGuide: function (latlng) {
  	            this.forwardLineGuide._latlngs[0] = latlng;
  	            this.forwardLineGuide._bounds.extend(latlng);
  	            this.forwardLineGuide.redraw();
  	        },

  	        anchorBackwardLineGuide: function (latlng) {
  	            this.backwardLineGuide._latlngs[0] = latlng;
  	            this.backwardLineGuide._bounds.extend(latlng);
  	            this.backwardLineGuide.redraw();
  	        },

  	        attachForwardLineGuide: function () {
  	            this.editLayer.addLayer(this.forwardLineGuide);
  	        },

  	        attachBackwardLineGuide: function () {
  	            this.editLayer.addLayer(this.backwardLineGuide);
  	        },

  	        detachForwardLineGuide: function () {
  	            this.forwardLineGuide.setLatLngs([]);
  	            this.editLayer.removeLayer(this.forwardLineGuide);
  	        },

  	        detachBackwardLineGuide: function () {
  	            this.backwardLineGuide.setLatLngs([]);
  	            this.editLayer.removeLayer(this.backwardLineGuide);
  	        },

  	        blockEvents: function () {
  	            // Hack: force map not to listen to other layers events while drawing.
  	            if (!this._oldTargets) {
  	                this._oldTargets = this.map._targets;
  	                this.map._targets = {};
  	            }
  	        },

  	        unblockEvents: function () {
  	            if (this._oldTargets) {
  	                // Reset, but keep targets created while drawing.
  	                this.map._targets = L.extend(this.map._targets, this._oldTargets);
  	                delete this._oldTargets;
  	            }
  	        },

  	        registerForDrawing: function (editor) {
  	            if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);
  	            this.blockEvents();
  	            editor.reset();  // Make sure editor tools still receive events.
  	            this._drawingEditor = editor;
  	            this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);
  	            this.map.on('mousedown', this.onMousedown, this);
  	            this.map.on('mouseup', this.onMouseup, this);
  	            L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);
  	            this.defaultMapCursor = this.map._container.style.cursor;
  	            this.map._container.style.cursor = this.options.drawingCursor;
  	        },

  	        unregisterForDrawing: function (editor) {
  	            this.unblockEvents();
  	            L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);
  	            this.map._container.style.cursor = this.defaultMapCursor;
  	            editor = editor || this._drawingEditor;
  	            if (!editor) return;
  	            this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);
  	            this.map.off('mousedown', this.onMousedown, this);
  	            this.map.off('mouseup', this.onMouseup, this);
  	            if (editor !== this._drawingEditor) return;
  	            delete this._drawingEditor;
  	            if (editor._drawing) editor.cancelDrawing();
  	        },

  	        onMousedown: function (e) {
  	            this._mouseDown = e;
  	            this._drawingEditor.onDrawingMouseDown(e);
  	        },

  	        onMouseup: function (e) {
  	            if (this._mouseDown) {
  	                var editor = this._drawingEditor,
  	                    mouseDown = this._mouseDown;
  	                this._mouseDown = null;
  	                editor.onDrawingMouseUp(e);
  	                if (this._drawingEditor !== editor) return;  // onDrawingMouseUp may call unregisterFromDrawing.
  	                var origin = L.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);
  	                var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);
  	                if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);
  	            }
  	        },

  	        // section Public methods
  	        // You will generally access them by the `map.editTools`
  	        // instance:
  	        //
  	        // `map.editTools.startPolyline();`

  	        // method drawing(): boolean
  	        // Return true if any drawing action is ongoing.
  	        drawing: function () {
  	            return this._drawingEditor && this._drawingEditor.drawing();
  	        },

  	        // method stopDrawing()
  	        // When you need to stop any ongoing drawing, without needing to know which editor is active.
  	        stopDrawing: function () {
  	            this.unregisterForDrawing();
  	        },

  	        // method commitDrawing()
  	        // When you need to commit any ongoing drawing, without needing to know which editor is active.
  	        commitDrawing: function (e) {
  	            if (!this._drawingEditor) return;
  	            this._drawingEditor.commitDrawing(e);
  	        },

  	        connectCreatedToMap: function (layer) {
  	            return this.featuresLayer.addLayer(layer);
  	        },

  	        // method startPolyline(latlng: L.LatLng, options: hash): L.Polyline
  	        // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.
  	        // If `options` is given, it will be passed to the Polyline class constructor.
  	        startPolyline: function (latlng, options) {
  	            var line = this.createPolyline([], options);
  	            line.enableEdit(this.map).newShape(latlng);
  	            return line;
  	        },

  	        // method startPolygon(latlng: L.LatLng, options: hash): L.Polygon
  	        // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.
  	        // If `options` is given, it will be passed to the Polygon class constructor.
  	        startPolygon: function (latlng, options) {
  	            var polygon = this.createPolygon([], options);
  	            polygon.enableEdit(this.map).newShape(latlng);
  	            return polygon;
  	        },

  	        // method startMarker(latlng: L.LatLng, options: hash): L.Marker
  	        // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.
  	        // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).
  	        // If `options` is given, it will be passed to the Marker class constructor.
  	        startMarker: function (latlng, options) {
  	            latlng = latlng || this.map.getCenter().clone();
  	            var marker = this.createMarker(latlng, options);
  	            marker.enableEdit(this.map).startDrawing();
  	            return marker;
  	        },

  	        // method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle
  	        // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.
  	        // If `options` is given, it will be passed to the Rectangle class constructor.
  	        startRectangle: function(latlng, options) {
  	            var corner = latlng || L.latLng([0, 0]);
  	            var bounds = new L.LatLngBounds(corner, corner);
  	            var rectangle = this.createRectangle(bounds, options);
  	            rectangle.enableEdit(this.map).startDrawing();
  	            return rectangle;
  	        },

  	        // method startCircle(latlng: L.LatLng, options: hash): L.Circle
  	        // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.
  	        // If `options` is given, it will be passed to the Circle class constructor.
  	        startCircle: function (latlng, options) {
  	            latlng = latlng || this.map.getCenter().clone();
  	            var circle = this.createCircle(latlng, options);
  	            circle.enableEdit(this.map).startDrawing();
  	            return circle;
  	        },

  	        startHole: function (editor, latlng) {
  	            editor.newHole(latlng);
  	        },

  	        createLayer: function (klass, latlngs, options) {
  	            options = L.Util.extend({editOptions: {editTools: this}}, options);
  	            var layer = new klass(latlngs, options);
  	            // namespace Editable
  	            // event editable:created: LayerEvent
  	            // Fired when a new feature (Marker, Polyline) is created.
  	            this.fireAndForward('editable:created', {layer: layer});
  	            return layer;
  	        },

  	        createPolyline: function (latlngs, options) {
  	            return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);
  	        },

  	        createPolygon: function (latlngs, options) {
  	            return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);
  	        },

  	        createMarker: function (latlng, options) {
  	            return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);
  	        },

  	        createRectangle: function (bounds, options) {
  	            return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);
  	        },

  	        createCircle: function (latlng, options) {
  	            return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);
  	        }

  	    });

  	    L.extend(L.Editable, {

  	        makeCancellable: function (e) {
  	            e.cancel = function () {
  	                e._cancelled = true;
  	            };
  	        }

  	    });

  	    // namespace Map; class Map
  	    // Leaflet.Editable add options and events to the `L.Map` object.
  	    // See `Editable` events for the list of events fired on the Map.
  	    // example
  	    //
  	    // ```js
  	    // var map = L.map('map', {
  	    //  editable: true,
  	    //  editOptions: {
  	    //    
  	    // }
  	    // });
  	    // ```
  	    // section Editable Map Options
  	    L.Map.mergeOptions({

  	        // namespace Map
  	        // section Map Options
  	        // option editToolsClass: class = L.Editable
  	        // Class to be used as vertex, for path editing.
  	        editToolsClass: L.Editable,

  	        // option editable: boolean = false
  	        // Whether to create a L.Editable instance at map init.
  	        editable: false,

  	        // option editOptions: hash = {}
  	        // Options to pass to L.Editable when instanciating.
  	        editOptions: {}

  	    });

  	    L.Map.addInitHook(function () {

  	        this.whenReady(function () {
  	            if (this.options.editable) {
  	                this.editTools = new this.options.editToolsClass(this, this.options.editOptions);
  	            }
  	        });

  	    });

  	    L.Editable.VertexIcon = L.DivIcon.extend({

  	        options: {
  	            iconSize: new L.Point(8, 8)
  	        }

  	    });

  	    L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({

  	        options: {
  	            iconSize: new L.Point(20, 20)
  	        }

  	    });


  	    // namespace Editable; class VertexMarker; Handler for dragging path vertices.
  	    L.Editable.VertexMarker = L.Marker.extend({

  	        options: {
  	            draggable: true,
  	            className: 'leaflet-div-icon leaflet-vertex-icon'
  	        },


  	        // section Public methods
  	        // The marker used to handle path vertex. You will usually interact with a `VertexMarker`
  	        // instance when listening for events like `editable:vertex:ctrlclick`.

  	        initialize: function (latlng, latlngs, editor, options) {
  	            // We don't use this._latlng, because on drag Leaflet replace it while
  	            // we want to keep reference.
  	            this.latlng = latlng;
  	            this.latlngs = latlngs;
  	            this.editor = editor;
  	            L.Marker.prototype.initialize.call(this, latlng, options);
  	            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});
  	            this.latlng.__vertex = this;
  	            this.editor.editLayer.addLayer(this);
  	            this.setZIndexOffset(editor.tools._lastZIndex + 1);
  	        },

  	        onAdd: function (map) {
  	            L.Marker.prototype.onAdd.call(this, map);
  	            this.on('drag', this.onDrag);
  	            this.on('dragstart', this.onDragStart);
  	            this.on('dragend', this.onDragEnd);
  	            this.on('mouseup', this.onMouseup);
  	            this.on('click', this.onClick);
  	            this.on('contextmenu', this.onContextMenu);
  	            this.on('mousedown touchstart', this.onMouseDown);
  	            this.addMiddleMarkers();
  	        },

  	        onRemove: function (map) {
  	            if (this.middleMarker) this.middleMarker.delete();
  	            delete this.latlng.__vertex;
  	            this.off('drag', this.onDrag);
  	            this.off('dragstart', this.onDragStart);
  	            this.off('dragend', this.onDragEnd);
  	            this.off('mouseup', this.onMouseup);
  	            this.off('click', this.onClick);
  	            this.off('contextmenu', this.onContextMenu);
  	            this.off('mousedown touchstart', this.onMouseDown);
  	            L.Marker.prototype.onRemove.call(this, map);
  	        },

  	        onDrag: function (e) {
  	            e.vertex = this;
  	            this.editor.onVertexMarkerDrag(e);
  	            var iconPos = L.DomUtil.getPosition(this._icon),
  	                latlng = this._map.layerPointToLatLng(iconPos);
  	            this.latlng.update(latlng);
  	            this._latlng = this.latlng;  // Push back to Leaflet our reference.
  	            this.editor.refresh();
  	            if (this.middleMarker) this.middleMarker.updateLatLng();
  	            var next = this.getNext();
  	            if (next && next.middleMarker) next.middleMarker.updateLatLng();
  	        },

  	        onDragStart: function (e) {
  	            e.vertex = this;
  	            this.editor.onVertexMarkerDragStart(e);
  	        },

  	        onDragEnd: function (e) {
  	            e.vertex = this;
  	            this.editor.onVertexMarkerDragEnd(e);
  	        },

  	        onClick: function (e) {
  	            e.vertex = this;
  	            this.editor.onVertexMarkerClick(e);
  	        },

  	        onMouseup: function (e) {
  	            L.DomEvent.stop(e);
  	            e.vertex = this;
  	            this.editor.map.fire('mouseup', e);
  	        },

  	        onContextMenu: function (e) {
  	            e.vertex = this;
  	            this.editor.onVertexMarkerContextMenu(e);
  	        },

  	        onMouseDown: function (e) {
  	            e.vertex = this;
  	            this.editor.onVertexMarkerMouseDown(e);
  	        },

  	        // method delete()
  	        // Delete a vertex and the related LatLng.
  	        delete: function () {
  	            var next = this.getNext();  // Compute before changing latlng
  	            this.latlngs.splice(this.getIndex(), 1);
  	            this.editor.editLayer.removeLayer(this);
  	            this.editor.onVertexDeleted({latlng: this.latlng, vertex: this});
  	            if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);
  	            if (next) next.resetMiddleMarker();
  	            this.editor.refresh();
  	        },

  	        // method getIndex(): int
  	        // Get the index of the current vertex among others of the same LatLngs group.
  	        getIndex: function () {
  	            return this.latlngs.indexOf(this.latlng);
  	        },

  	        // method getLastIndex(): int
  	        // Get last vertex index of the LatLngs group of the current vertex.
  	        getLastIndex: function () {
  	            return this.latlngs.length - 1;
  	        },

  	        // method getPrevious(): VertexMarker
  	        // Get the previous VertexMarker in the same LatLngs group.
  	        getPrevious: function () {
  	            if (this.latlngs.length < 2) return;
  	            var index = this.getIndex(),
  	                previousIndex = index - 1;
  	            if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();
  	            var previous = this.latlngs[previousIndex];
  	            if (previous) return previous.__vertex;
  	        },

  	        // method getNext(): VertexMarker
  	        // Get the next VertexMarker in the same LatLngs group.
  	        getNext: function () {
  	            if (this.latlngs.length < 2) return;
  	            var index = this.getIndex(),
  	                nextIndex = index + 1;
  	            if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;
  	            var next = this.latlngs[nextIndex];
  	            if (next) return next.__vertex;
  	        },

  	        addMiddleMarker: function (previous) {
  	            if (!this.editor.hasMiddleMarkers()) return;
  	            previous = previous || this.getPrevious();
  	            if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);
  	        },

  	        addMiddleMarkers: function () {
  	            if (!this.editor.hasMiddleMarkers()) return;
  	            var previous = this.getPrevious();
  	            if (previous) this.addMiddleMarker(previous);
  	            var next = this.getNext();
  	            if (next) next.resetMiddleMarker();
  	        },

  	        resetMiddleMarker: function () {
  	            if (this.middleMarker) this.middleMarker.delete();
  	            this.addMiddleMarker();
  	        },

  	        // method split()
  	        // Split the vertex LatLngs group at its index, if possible.
  	        split: function () {
  	            if (!this.editor.splitShape) return;  // Only for PolylineEditor
  	            this.editor.splitShape(this.latlngs, this.getIndex());
  	        },

  	        // method continue()
  	        // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.
  	        continue: function () {
  	            if (!this.editor.continueBackward) return;  // Only for PolylineEditor
  	            var index = this.getIndex();
  	            if (index === 0) this.editor.continueBackward(this.latlngs);
  	            else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);
  	        }

  	    });

  	    L.Editable.mergeOptions({

  	        // namespace Editable
  	        // option vertexMarkerClass: class = VertexMarker
  	        // Class to be used as vertex, for path editing.
  	        vertexMarkerClass: L.Editable.VertexMarker

  	    });

  	    L.Editable.MiddleMarker = L.Marker.extend({

  	        options: {
  	            opacity: 0.5,
  	            className: 'leaflet-div-icon leaflet-middle-icon',
  	            draggable: true
  	        },

  	        initialize: function (left, right, latlngs, editor, options) {
  	            this.left = left;
  	            this.right = right;
  	            this.editor = editor;
  	            this.latlngs = latlngs;
  	            L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);
  	            this._opacity = this.options.opacity;
  	            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});
  	            this.editor.editLayer.addLayer(this);
  	            this.setVisibility();
  	        },

  	        setVisibility: function () {
  	            var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),
  	                rightPoint = this._map.latLngToContainerPoint(this.right.latlng),
  	                size = L.point(this.options.icon.options.iconSize);
  	            if (leftPoint.distanceTo(rightPoint) < size.x * 3) this.hide();
  	            else this.show();
  	        },

  	        show: function () {
  	            this.setOpacity(this._opacity);
  	        },

  	        hide: function () {
  	            this.setOpacity(0);
  	        },

  	        updateLatLng: function () {
  	            this.setLatLng(this.computeLatLng());
  	            this.setVisibility();
  	        },

  	        computeLatLng: function () {
  	            var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),
  	                rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),
  	                y = (leftPoint.y + rightPoint.y) / 2,
  	                x = (leftPoint.x + rightPoint.x) / 2;
  	            return this.editor.map.containerPointToLatLng([x, y]);
  	        },

  	        onAdd: function (map) {
  	            L.Marker.prototype.onAdd.call(this, map);
  	            L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);
  	            map.on('zoomend', this.setVisibility, this);
  	        },

  	        onRemove: function (map) {
  	            delete this.right.middleMarker;
  	            L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);
  	            map.off('zoomend', this.setVisibility, this);
  	            L.Marker.prototype.onRemove.call(this, map);
  	        },

  	        onMouseDown: function (e) {
  	            var iconPos = L.DomUtil.getPosition(this._icon),
  	                latlng = this.editor.map.layerPointToLatLng(iconPos);
  	            e = {
  	                originalEvent: e,
  	                latlng: latlng
  	            };
  	            if (this.options.opacity === 0) return;
  	            L.Editable.makeCancellable(e);
  	            this.editor.onMiddleMarkerMouseDown(e);
  	            if (e._cancelled) return;
  	            this.latlngs.splice(this.index(), 0, e.latlng);
  	            this.editor.refresh();
  	            var icon = this._icon;
  	            var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);
  	            this.editor.onNewVertex(marker);
  	            /* Hack to workaround browser not firing touchend when element is no more on DOM */
  	            var parent = marker._icon.parentNode;
  	            parent.removeChild(marker._icon);
  	            marker._icon = icon;
  	            parent.appendChild(marker._icon);
  	            marker._initIcon();
  	            marker._initInteraction();
  	            marker.setOpacity(1);
  	            /* End hack */
  	            // Transfer ongoing dragging to real marker
  	            L.Draggable._dragging = false;
  	            marker.dragging._draggable._onDown(e.originalEvent);
  	            this.delete();
  	        },

  	        delete: function () {
  	            this.editor.editLayer.removeLayer(this);
  	        },

  	        index: function () {
  	            return this.latlngs.indexOf(this.right.latlng);
  	        }

  	    });

  	    L.Editable.mergeOptions({

  	        // namespace Editable
  	        // option middleMarkerClass: class = VertexMarker
  	        // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.
  	        middleMarkerClass: L.Editable.MiddleMarker

  	    });

  	    // namespace Editable; class BaseEditor; aka L.Editable.BaseEditor
  	    // When editing a feature (Marker, Polyline), an editor is attached to it. This
  	    // editor basically knows how to handle the edition.
  	    L.Editable.BaseEditor = L.Handler.extend({

  	        initialize: function (map, feature, options) {
  	            L.setOptions(this, options);
  	            this.map = map;
  	            this.feature = feature;
  	            this.feature.editor = this;
  	            this.editLayer = new L.LayerGroup();
  	            this.tools = this.options.editTools || map.editTools;
  	        },

  	        // method enable(): this
  	        // Set up the drawing tools for the feature to be editable.
  	        addHooks: function () {
  	            if (this.isConnected()) this.onFeatureAdd();
  	            else this.feature.once('add', this.onFeatureAdd, this);
  	            this.onEnable();
  	            this.feature.on(this._getEvents(), this);
  	            return;
  	        },

  	        // method disable(): this
  	        // Remove the drawing tools for the feature.
  	        removeHooks: function () {
  	            this.feature.off(this._getEvents(), this);
  	            if (this.feature.dragging) this.feature.dragging.disable();
  	            this.editLayer.clearLayers();
  	            this.tools.editLayer.removeLayer(this.editLayer);
  	            this.onDisable();
  	            if (this._drawing) this.cancelDrawing();
  	            return;
  	        },

  	        // method drawing(): boolean
  	        // Return true if any drawing action is ongoing with this editor.
  	        drawing: function () {
  	            return !!this._drawing;
  	        },

  	        reset: function () {},

  	        onFeatureAdd: function () {
  	            this.tools.editLayer.addLayer(this.editLayer);
  	            if (this.feature.dragging) this.feature.dragging.enable();
  	        },

  	        hasMiddleMarkers: function () {
  	            return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;
  	        },

  	        fireAndForward: function (type, e) {
  	            e = e || {};
  	            e.layer = this.feature;
  	            this.feature.fire(type, e);
  	            this.tools.fireAndForward(type, e);
  	        },

  	        onEnable: function () {
  	            // namespace Editable
  	            // event editable:enable: Event
  	            // Fired when an existing feature is ready to be edited.
  	            this.fireAndForward('editable:enable');
  	        },

  	        onDisable: function () {
  	            // namespace Editable
  	            // event editable:disable: Event
  	            // Fired when an existing feature is not ready anymore to be edited.
  	            this.fireAndForward('editable:disable');
  	        },

  	        onEditing: function () {
  	            // namespace Editable
  	            // event editable:editing: Event
  	            // Fired as soon as any change is made to the feature geometry.
  	            this.fireAndForward('editable:editing');
  	        },

  	        onStartDrawing: function () {
  	            // namespace Editable
  	            // section Drawing events
  	            // event editable:drawing:start: Event
  	            // Fired when a feature is to be drawn.
  	            this.fireAndForward('editable:drawing:start');
  	        },

  	        onEndDrawing: function () {
  	            // namespace Editable
  	            // section Drawing events
  	            // event editable:drawing:end: Event
  	            // Fired when a feature is not drawn anymore.
  	            this.fireAndForward('editable:drawing:end');
  	        },

  	        onCancelDrawing: function () {
  	            // namespace Editable
  	            // section Drawing events
  	            // event editable:drawing:cancel: Event
  	            // Fired when user cancel drawing while a feature is being drawn.
  	            this.fireAndForward('editable:drawing:cancel');
  	        },

  	        onCommitDrawing: function (e) {
  	            // namespace Editable
  	            // section Drawing events
  	            // event editable:drawing:commit: Event
  	            // Fired when user finish drawing a feature.
  	            this.fireAndForward('editable:drawing:commit', e);
  	        },

  	        onDrawingMouseDown: function (e) {
  	            // namespace Editable
  	            // section Drawing events
  	            // event editable:drawing:mousedown: Event
  	            // Fired when user `mousedown` while drawing.
  	            this.fireAndForward('editable:drawing:mousedown', e);
  	        },

  	        onDrawingMouseUp: function (e) {
  	            // namespace Editable
  	            // section Drawing events
  	            // event editable:drawing:mouseup: Event
  	            // Fired when user `mouseup` while drawing.
  	            this.fireAndForward('editable:drawing:mouseup', e);
  	        },

  	        startDrawing: function () {
  	            if (!this._drawing) this._drawing = L.Editable.FORWARD;
  	            this.tools.registerForDrawing(this);
  	            this.onStartDrawing();
  	        },

  	        commitDrawing: function (e) {
  	            this.onCommitDrawing(e);
  	            this.endDrawing();
  	        },

  	        cancelDrawing: function () {
  	            // If called during a vertex drag, the vertex will be removed before
  	            // the mouseup fires on it. This is a workaround. Maybe better fix is
  	            // To have L.Draggable reset it's status on disable (Leaflet side).
  	            L.Draggable._dragging = false;
  	            this.onCancelDrawing();
  	            this.endDrawing();
  	        },

  	        endDrawing: function () {
  	            this._drawing = false;
  	            this.tools.unregisterForDrawing(this);
  	            this.onEndDrawing();
  	        },

  	        onDrawingClick: function (e) {
  	            if (!this.drawing()) return;
  	            L.Editable.makeCancellable(e);
  	            // namespace Editable
  	            // section Drawing events
  	            // event editable:drawing:click: CancelableEvent
  	            // Fired when user `click` while drawing, before any internal action is being processed.
  	            this.fireAndForward('editable:drawing:click', e);
  	            if (e._cancelled) return;
  	            if (!this.isConnected()) this.connect(e);
  	            this.processDrawingClick(e);
  	        },

  	        isConnected: function () {
  	            return this.map.hasLayer(this.feature);
  	        },

  	        connect: function (e) {
  	            this.tools.connectCreatedToMap(this.feature);
  	            this.tools.editLayer.addLayer(this.editLayer);
  	        },

  	        onMove: function (e) {
  	            // namespace Editable
  	            // section Drawing events
  	            // event editable:drawing:move: Event
  	            // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.
  	            this.fireAndForward('editable:drawing:move', e);
  	        },

  	        onDrawingMouseMove: function (e) {
  	            this.onMove(e);
  	        },

  	        _getEvents: function () {
  	            return {
  	                dragstart: this.onDragStart,
  	                drag: this.onDrag,
  	                dragend: this.onDragEnd,
  	                remove: this.disable
  	            };
  	        },

  	        onDragStart: function (e) {
  	            this.onEditing();
  	            // namespace Editable
  	            // event editable:dragstart: Event
  	            // Fired before a path feature is dragged.
  	            this.fireAndForward('editable:dragstart', e);
  	        },

  	        onDrag: function (e) {
  	            this.onMove(e);
  	            // namespace Editable
  	            // event editable:drag: Event
  	            // Fired when a path feature is being dragged.
  	            this.fireAndForward('editable:drag', e);
  	        },

  	        onDragEnd: function (e) {
  	            // namespace Editable
  	            // event editable:dragend: Event
  	            // Fired after a path feature has been dragged.
  	            this.fireAndForward('editable:dragend', e);
  	        }

  	    });

  	    // namespace Editable; class MarkerEditor; aka L.Editable.MarkerEditor
  	    // inherits BaseEditor
  	    // Editor for Marker.
  	    L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({

  	        onDrawingMouseMove: function (e) {
  	            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);
  	            if (this._drawing) this.feature.setLatLng(e.latlng);
  	        },

  	        processDrawingClick: function (e) {
  	            // namespace Editable
  	            // section Drawing events
  	            // event editable:drawing:clicked: Event
  	            // Fired when user `click` while drawing, after all internal actions.
  	            this.fireAndForward('editable:drawing:clicked', e);
  	            this.commitDrawing(e);
  	        },

  	        connect: function (e) {
  	            // On touch, the latlng has not been updated because there is
  	            // no mousemove.
  	            if (e) this.feature._latlng = e.latlng;
  	            L.Editable.BaseEditor.prototype.connect.call(this, e);
  	        }

  	    });

  	    // namespace Editable; class PathEditor; aka L.Editable.PathEditor
  	    // inherits BaseEditor
  	    // Base class for all path editors.
  	    L.Editable.PathEditor = L.Editable.BaseEditor.extend({

  	        CLOSED: false,
  	        MIN_VERTEX: 2,

  	        addHooks: function () {
  	            L.Editable.BaseEditor.prototype.addHooks.call(this);
  	            if (this.feature) this.initVertexMarkers();
  	            return this;
  	        },

  	        initVertexMarkers: function (latlngs) {
  	            if (!this.enabled()) return;
  	            latlngs = latlngs || this.getLatLngs();
  	            if (isFlat(latlngs)) this.addVertexMarkers(latlngs);
  	            else for (var i = 0; i < latlngs.length; i++) this.initVertexMarkers(latlngs[i]);
  	        },

  	        getLatLngs: function () {
  	            return this.feature.getLatLngs();
  	        },

  	        // method reset()
  	        // Rebuild edit elements (Vertex, MiddleMarker, etc.).
  	        reset: function () {
  	            this.editLayer.clearLayers();
  	            this.initVertexMarkers();
  	        },

  	        addVertexMarker: function (latlng, latlngs) {
  	            return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);
  	        },

  	        onNewVertex: function (vertex) {
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:new: VertexEvent
  	            // Fired when a new vertex is created.
  	            this.fireAndForward('editable:vertex:new', {latlng: vertex.latlng, vertex: vertex});
  	        },

  	        addVertexMarkers: function (latlngs) {
  	            for (var i = 0; i < latlngs.length; i++) {
  	                this.addVertexMarker(latlngs[i], latlngs);
  	            }
  	        },

  	        refreshVertexMarkers: function (latlngs) {
  	            latlngs = latlngs || this.getDefaultLatLngs();
  	            for (var i = 0; i < latlngs.length; i++) {
  	                latlngs[i].__vertex.update();
  	            }
  	        },

  	        addMiddleMarker: function (left, right, latlngs) {
  	            return new this.tools.options.middleMarkerClass(left, right, latlngs, this);
  	        },

  	        onVertexMarkerClick: function (e) {
  	            L.Editable.makeCancellable(e);
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:click: CancelableVertexEvent
  	            // Fired when a `click` is issued on a vertex, before any internal action is being processed.
  	            this.fireAndForward('editable:vertex:click', e);
  	            if (e._cancelled) return;
  	            if (this.tools.drawing() && this.tools._drawingEditor !== this) return;
  	            var index = e.vertex.getIndex(), commit;
  	            if (e.originalEvent.ctrlKey) {
  	                this.onVertexMarkerCtrlClick(e);
  	            } else if (e.originalEvent.altKey) {
  	                this.onVertexMarkerAltClick(e);
  	            } else if (e.originalEvent.shiftKey) {
  	                this.onVertexMarkerShiftClick(e);
  	            } else if (e.originalEvent.metaKey) {
  	                this.onVertexMarkerMetaKeyClick(e);
  	            } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {
  	                if (index >= this.MIN_VERTEX - 1) commit = true;
  	            } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {
  	                commit = true;
  	            } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {
  	                commit = true;  // Allow to close on first point also for polygons
  	            } else {
  	                this.onVertexRawMarkerClick(e);
  	            }
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:clicked: VertexEvent
  	            // Fired when a `click` is issued on a vertex, after all internal actions.
  	            this.fireAndForward('editable:vertex:clicked', e);
  	            if (commit) this.commitDrawing(e);
  	        },

  	        onVertexRawMarkerClick: function (e) {
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:rawclick: CancelableVertexEvent
  	            // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.
  	            this.fireAndForward('editable:vertex:rawclick', e);
  	            if (e._cancelled) return;
  	            if (!this.vertexCanBeDeleted(e.vertex)) return;
  	            e.vertex.delete();
  	        },

  	        vertexCanBeDeleted: function (vertex) {
  	            return vertex.latlngs.length > this.MIN_VERTEX;
  	        },

  	        onVertexDeleted: function (e) {
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:deleted: VertexEvent
  	            // Fired after a vertex has been deleted by user.
  	            this.fireAndForward('editable:vertex:deleted', e);
  	        },

  	        onVertexMarkerCtrlClick: function (e) {
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:ctrlclick: VertexEvent
  	            // Fired when a `click` with `ctrlKey` is issued on a vertex.
  	            this.fireAndForward('editable:vertex:ctrlclick', e);
  	        },

  	        onVertexMarkerShiftClick: function (e) {
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:shiftclick: VertexEvent
  	            // Fired when a `click` with `shiftKey` is issued on a vertex.
  	            this.fireAndForward('editable:vertex:shiftclick', e);
  	        },

  	        onVertexMarkerMetaKeyClick: function (e) {
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:metakeyclick: VertexEvent
  	            // Fired when a `click` with `metaKey` is issued on a vertex.
  	            this.fireAndForward('editable:vertex:metakeyclick', e);
  	        },

  	        onVertexMarkerAltClick: function (e) {
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:altclick: VertexEvent
  	            // Fired when a `click` with `altKey` is issued on a vertex.
  	            this.fireAndForward('editable:vertex:altclick', e);
  	        },

  	        onVertexMarkerContextMenu: function (e) {
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:contextmenu: VertexEvent
  	            // Fired when a `contextmenu` is issued on a vertex.
  	            this.fireAndForward('editable:vertex:contextmenu', e);
  	        },

  	        onVertexMarkerMouseDown: function (e) {
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:mousedown: VertexEvent
  	            // Fired when user `mousedown` a vertex.
  	            this.fireAndForward('editable:vertex:mousedown', e);
  	        },

  	        onMiddleMarkerMouseDown: function (e) {
  	            // namespace Editable
  	            // section MiddleMarker events
  	            // event editable:middlemarker:mousedown: VertexEvent
  	            // Fired when user `mousedown` a middle marker.
  	            this.fireAndForward('editable:middlemarker:mousedown', e);
  	        },

  	        onVertexMarkerDrag: function (e) {
  	            this.onMove(e);
  	            if (this.feature._bounds) this.extendBounds(e);
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:drag: VertexEvent
  	            // Fired when a vertex is dragged by user.
  	            this.fireAndForward('editable:vertex:drag', e);
  	        },

  	        onVertexMarkerDragStart: function (e) {
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:dragstart: VertexEvent
  	            // Fired before a vertex is dragged by user.
  	            this.fireAndForward('editable:vertex:dragstart', e);
  	        },

  	        onVertexMarkerDragEnd: function (e) {
  	            // namespace Editable
  	            // section Vertex events
  	            // event editable:vertex:dragend: VertexEvent
  	            // Fired after a vertex is dragged by user.
  	            this.fireAndForward('editable:vertex:dragend', e);
  	        },

  	        setDrawnLatLngs: function (latlngs) {
  	            this._drawnLatLngs = latlngs || this.getDefaultLatLngs();
  	        },

  	        startDrawing: function () {
  	            if (!this._drawnLatLngs) this.setDrawnLatLngs();
  	            L.Editable.BaseEditor.prototype.startDrawing.call(this);
  	        },

  	        startDrawingForward: function () {
  	            this.startDrawing();
  	        },

  	        endDrawing: function () {
  	            this.tools.detachForwardLineGuide();
  	            this.tools.detachBackwardLineGuide();
  	            if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);
  	            L.Editable.BaseEditor.prototype.endDrawing.call(this);
  	            delete this._drawnLatLngs;
  	        },

  	        addLatLng: function (latlng) {
  	            if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);
  	            else this._drawnLatLngs.unshift(latlng);
  	            this.feature._bounds.extend(latlng);
  	            var vertex = this.addVertexMarker(latlng, this._drawnLatLngs);
  	            this.onNewVertex(vertex);
  	            this.refresh();
  	        },

  	        newPointForward: function (latlng) {
  	            this.addLatLng(latlng);
  	            this.tools.attachForwardLineGuide();
  	            this.tools.anchorForwardLineGuide(latlng);
  	        },

  	        newPointBackward: function (latlng) {
  	            this.addLatLng(latlng);
  	            this.tools.anchorBackwardLineGuide(latlng);
  	        },

  	        // namespace PathEditor
  	        // method push()
  	        // Programmatically add a point while drawing.
  	        push: function (latlng) {
  	            if (!latlng) return console.error('L.Editable.PathEditor.push expect a vaild latlng as parameter');
  	            if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);
  	            else this.newPointBackward(latlng);
  	        },

  	        removeLatLng: function (latlng) {
  	            latlng.__vertex.delete();
  	            this.refresh();
  	        },

  	        // method pop(): L.LatLng or null
  	        // Programmatically remove last point (if any) while drawing.
  	        pop: function () {
  	            if (this._drawnLatLngs.length <= 1) return;
  	            var latlng;
  	            if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];
  	            else latlng = this._drawnLatLngs[0];
  	            this.removeLatLng(latlng);
  	            if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);
  	            else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);
  	            return latlng;
  	        },

  	        processDrawingClick: function (e) {
  	            if (e.vertex && e.vertex.editor === this) return;
  	            if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);
  	            else this.newPointBackward(e.latlng);
  	            this.fireAndForward('editable:drawing:clicked', e);
  	        },

  	        onDrawingMouseMove: function (e) {
  	            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);
  	            if (this._drawing) {
  	                this.tools.moveForwardLineGuide(e.latlng);
  	                this.tools.moveBackwardLineGuide(e.latlng);
  	            }
  	        },

  	        refresh: function () {
  	            this.feature.redraw();
  	            this.onEditing();
  	        },

  	        // namespace PathEditor
  	        // method newShape(latlng?: L.LatLng)
  	        // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;
  	        // if optional `latlng` is given, start a path at this point.
  	        newShape: function (latlng) {
  	            var shape = this.addNewEmptyShape();
  	            if (!shape) return;
  	            this.setDrawnLatLngs(shape[0] || shape);  // Polygon or polyline
  	            this.startDrawingForward();
  	            // namespace Editable
  	            // section Shape events
  	            // event editable:shape:new: ShapeEvent
  	            // Fired when a new shape is created in a multi (Polygon or Polyline).
  	            this.fireAndForward('editable:shape:new', {shape: shape});
  	            if (latlng) this.newPointForward(latlng);
  	        },

  	        deleteShape: function (shape, latlngs) {
  	            var e = {shape: shape};
  	            L.Editable.makeCancellable(e);
  	            // namespace Editable
  	            // section Shape events
  	            // event editable:shape:delete: CancelableShapeEvent
  	            // Fired before a new shape is deleted in a multi (Polygon or Polyline).
  	            this.fireAndForward('editable:shape:delete', e);
  	            if (e._cancelled) return;
  	            shape = this._deleteShape(shape, latlngs);
  	            if (this.ensureNotFlat) this.ensureNotFlat();  // Polygon.
  	            this.feature.setLatLngs(this.getLatLngs());  // Force bounds reset.
  	            this.refresh();
  	            this.reset();
  	            // namespace Editable
  	            // section Shape events
  	            // event editable:shape:deleted: ShapeEvent
  	            // Fired after a new shape is deleted in a multi (Polygon or Polyline).
  	            this.fireAndForward('editable:shape:deleted', {shape: shape});
  	            return shape;
  	        },

  	        _deleteShape: function (shape, latlngs) {
  	            latlngs = latlngs || this.getLatLngs();
  	            if (!latlngs.length) return;
  	            var self = this,
  	                inplaceDelete = function (latlngs, shape) {
  	                    // Called when deleting a flat latlngs
  	                    shape = latlngs.splice(0, Number.MAX_VALUE);
  	                    return shape;
  	                },
  	                spliceDelete = function (latlngs, shape) {
  	                    // Called when removing a latlngs inside an array
  	                    latlngs.splice(latlngs.indexOf(shape), 1);
  	                    if (!latlngs.length) self._deleteShape(latlngs);
  	                    return shape;
  	                };
  	            if (latlngs === shape) return inplaceDelete(latlngs, shape);
  	            for (var i = 0; i < latlngs.length; i++) {
  	                if (latlngs[i] === shape) return spliceDelete(latlngs, shape);
  	                else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);
  	            }
  	        },

  	        // namespace PathEditor
  	        // method deleteShapeAt(latlng: L.LatLng): Array
  	        // Remove a path shape at the given `latlng`.
  	        deleteShapeAt: function (latlng) {
  	            var shape = this.feature.shapeAt(latlng);
  	            if (shape) return this.deleteShape(shape);
  	        },

  	        // method appendShape(shape: Array)
  	        // Append a new shape to the Polygon or Polyline.
  	        appendShape: function (shape) {
  	            this.insertShape(shape);
  	        },

  	        // method prependShape(shape: Array)
  	        // Prepend a new shape to the Polygon or Polyline.
  	        prependShape: function (shape) {
  	            this.insertShape(shape, 0);
  	        },

  	        // method insertShape(shape: Array, index: int)
  	        // Insert a new shape to the Polygon or Polyline at given index (default is to append).
  	        insertShape: function (shape, index) {
  	            this.ensureMulti();
  	            shape = this.formatShape(shape);
  	            if (typeof index === 'undefined') index = this.feature._latlngs.length;
  	            this.feature._latlngs.splice(index, 0, shape);
  	            this.feature.redraw();
  	            if (this._enabled) this.reset();
  	        },

  	        extendBounds: function (e) {
  	            this.feature._bounds.extend(e.vertex.latlng);
  	        },

  	        onDragStart: function (e) {
  	            this.editLayer.clearLayers();
  	            L.Editable.BaseEditor.prototype.onDragStart.call(this, e);
  	        },

  	        onDragEnd: function (e) {
  	            this.initVertexMarkers();
  	            L.Editable.BaseEditor.prototype.onDragEnd.call(this, e);
  	        }

  	    });

  	    // namespace Editable; class PolylineEditor; aka L.Editable.PolylineEditor
  	    // inherits PathEditor
  	    L.Editable.PolylineEditor = L.Editable.PathEditor.extend({

  	        startDrawingBackward: function () {
  	            this._drawing = L.Editable.BACKWARD;
  	            this.startDrawing();
  	        },

  	        // method continueBackward(latlngs?: Array)
  	        // Set up drawing tools to continue the line backward.
  	        continueBackward: function (latlngs) {
  	            if (this.drawing()) return;
  	            latlngs = latlngs || this.getDefaultLatLngs();
  	            this.setDrawnLatLngs(latlngs);
  	            if (latlngs.length > 0) {
  	                this.tools.attachBackwardLineGuide();
  	                this.tools.anchorBackwardLineGuide(latlngs[0]);
  	            }
  	            this.startDrawingBackward();
  	        },

  	        // method continueForward(latlngs?: Array)
  	        // Set up drawing tools to continue the line forward.
  	        continueForward: function (latlngs) {
  	            if (this.drawing()) return;
  	            latlngs = latlngs || this.getDefaultLatLngs();
  	            this.setDrawnLatLngs(latlngs);
  	            if (latlngs.length > 0) {
  	                this.tools.attachForwardLineGuide();
  	                this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);
  	            }
  	            this.startDrawingForward();
  	        },

  	        getDefaultLatLngs: function (latlngs) {
  	            latlngs = latlngs || this.feature._latlngs;
  	            if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;
  	            else return this.getDefaultLatLngs(latlngs[0]);
  	        },

  	        ensureMulti: function () {
  	            if (this.feature._latlngs.length && isFlat(this.feature._latlngs)) {
  	                this.feature._latlngs = [this.feature._latlngs];
  	            }
  	        },

  	        addNewEmptyShape: function () {
  	            if (this.feature._latlngs.length) {
  	                var shape = [];
  	                this.appendShape(shape);
  	                return shape;
  	            } else {
  	                return this.feature._latlngs;
  	            }
  	        },

  	        formatShape: function (shape) {
  	            if (isFlat(shape)) return shape;
  	            else if (shape[0]) return this.formatShape(shape[0]);
  	        },

  	        // method splitShape(latlngs?: Array, index: int)
  	        // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.
  	        splitShape: function (shape, index) {
  	            if (!index || index >= shape.length - 1) return;
  	            this.ensureMulti();
  	            var shapeIndex = this.feature._latlngs.indexOf(shape);
  	            if (shapeIndex === -1) return;
  	            var first = shape.slice(0, index + 1),
  	                second = shape.slice(index);
  	            // We deal with reference, we don't want twice the same latlng around.
  	            second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);
  	            this.feature._latlngs.splice(shapeIndex, 1, first, second);
  	            this.refresh();
  	            this.reset();
  	        }

  	    });

  	    // namespace Editable; class PolygonEditor; aka L.Editable.PolygonEditor
  	    // inherits PathEditor
  	    L.Editable.PolygonEditor = L.Editable.PathEditor.extend({

  	        CLOSED: true,
  	        MIN_VERTEX: 3,

  	        newPointForward: function (latlng) {
  	            L.Editable.PathEditor.prototype.newPointForward.call(this, latlng);
  	            if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);
  	            if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();
  	        },

  	        addNewEmptyHole: function (latlng) {
  	            this.ensureNotFlat();
  	            var latlngs = this.feature.shapeAt(latlng);
  	            if (!latlngs) return;
  	            var holes = [];
  	            latlngs.push(holes);
  	            return holes;
  	        },

  	        // method newHole(latlng?: L.LatLng, index: int)
  	        // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.
  	        newHole: function (latlng) {
  	            var holes = this.addNewEmptyHole(latlng);
  	            if (!holes) return;
  	            this.setDrawnLatLngs(holes);
  	            this.startDrawingForward();
  	            if (latlng) this.newPointForward(latlng);
  	        },

  	        addNewEmptyShape: function () {
  	            if (this.feature._latlngs.length && this.feature._latlngs[0].length) {
  	                var shape = [];
  	                this.appendShape(shape);
  	                return shape;
  	            } else {
  	                return this.feature._latlngs;
  	            }
  	        },

  	        ensureMulti: function () {
  	            if (this.feature._latlngs.length && isFlat(this.feature._latlngs[0])) {
  	                this.feature._latlngs = [this.feature._latlngs];
  	            }
  	        },

  	        ensureNotFlat: function () {
  	            if (!this.feature._latlngs.length || isFlat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];
  	        },

  	        vertexCanBeDeleted: function (vertex) {
  	            var parent = this.feature.parentShape(vertex.latlngs),
  	                idx = L.Util.indexOf(parent, vertex.latlngs);
  	            if (idx > 0) return true;  // Holes can be totally deleted without removing the layer itself.
  	            return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);
  	        },

  	        getDefaultLatLngs: function () {
  	            if (!this.feature._latlngs.length) this.feature._latlngs.push([]);
  	            return this.feature._latlngs[0];
  	        },

  	        formatShape: function (shape) {
  	            // [[1, 2], [3, 4]] => must be nested
  	            // [] => must be nested
  	            // [[]] => is already nested
  	            if (isFlat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];
  	            else return shape;
  	        }

  	    });

  	    // namespace Editable; class RectangleEditor; aka L.Editable.RectangleEditor
  	    // inherits PathEditor
  	    L.Editable.RectangleEditor = L.Editable.PathEditor.extend({

  	        CLOSED: true,
  	        MIN_VERTEX: 4,

  	        options: {
  	            skipMiddleMarkers: true
  	        },

  	        extendBounds: function (e) {
  	            var index = e.vertex.getIndex(),
  	                next = e.vertex.getNext(),
  	                previous = e.vertex.getPrevious(),
  	                oppositeIndex = (index + 2) % 4,
  	                opposite = e.vertex.latlngs[oppositeIndex],
  	                bounds = new L.LatLngBounds(e.latlng, opposite);
  	            // Update latlngs by hand to preserve order.
  	            previous.latlng.update([e.latlng.lat, opposite.lng]);
  	            next.latlng.update([opposite.lat, e.latlng.lng]);
  	            this.updateBounds(bounds);
  	            this.refreshVertexMarkers();
  	        },

  	        onDrawingMouseDown: function (e) {
  	            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);
  	            this.connect();
  	            var latlngs = this.getDefaultLatLngs();
  	            // L.Polygon._convertLatLngs removes last latlng if it equals first point,
  	            // which is the case here as all latlngs are [0, 0]
  	            if (latlngs.length === 3) latlngs.push(e.latlng);
  	            var bounds = new L.LatLngBounds(e.latlng, e.latlng);
  	            this.updateBounds(bounds);
  	            this.updateLatLngs(bounds);
  	            this.refresh();
  	            this.reset();
  	            // Stop dragging map.
  	            // L.Draggable has two workflows:
  	            // - mousedown => mousemove => mouseup
  	            // - touchstart => touchmove => touchend
  	            // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only
  	            // can deal with mousedown, but then when in a touch device, we are dealing with
  	            // simulated events (actually simulated by L.Map.Tap), which are no more taken
  	            // into account by L.Draggable.
  	            // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103
  	            e.originalEvent._simulated = false;
  	            this.map.dragging._draggable._onUp(e.originalEvent);
  	            // Now transfer ongoing drag action to the bottom right corner.
  	            // Should we refine which corne will handle the drag according to
  	            // drag direction?
  	            latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);
  	        },

  	        onDrawingMouseUp: function (e) {
  	            this.commitDrawing(e);
  	            e.originalEvent._simulated = false;
  	            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);
  	        },

  	        onDrawingMouseMove: function (e) {
  	            e.originalEvent._simulated = false;
  	            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);
  	        },


  	        getDefaultLatLngs: function (latlngs) {
  	            return latlngs || this.feature._latlngs[0];
  	        },

  	        updateBounds: function (bounds) {
  	            this.feature._bounds = bounds;
  	        },

  	        updateLatLngs: function (bounds) {
  	            var latlngs = this.getDefaultLatLngs(),
  	                newLatlngs = this.feature._boundsToLatLngs(bounds);
  	            // Keep references.
  	            for (var i = 0; i < latlngs.length; i++) {
  	                latlngs[i].update(newLatlngs[i]);
  	            }	        }

  	    });

  	    // namespace Editable; class CircleEditor; aka L.Editable.CircleEditor
  	    // inherits PathEditor
  	    L.Editable.CircleEditor = L.Editable.PathEditor.extend({

  	        MIN_VERTEX: 2,

  	        options: {
  	            skipMiddleMarkers: true
  	        },

  	        initialize: function (map, feature, options) {
  	            L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);
  	            this._resizeLatLng = this.computeResizeLatLng();
  	        },

  	        computeResizeLatLng: function () {
  	            // While circle is not added to the map, _radius is not set.
  	            var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),
  	                point = this.map.project(this.feature._latlng);
  	            return this.map.unproject([point.x + delta, point.y - delta]);
  	        },

  	        updateResizeLatLng: function () {
  	            this._resizeLatLng.update(this.computeResizeLatLng());
  	            this._resizeLatLng.__vertex.update();
  	        },

  	        getLatLngs: function () {
  	            return [this.feature._latlng, this._resizeLatLng];
  	        },

  	        getDefaultLatLngs: function () {
  	            return this.getLatLngs();
  	        },

  	        onVertexMarkerDrag: function (e) {
  	            if (e.vertex.getIndex() === 1) this.resize(e);
  	            else this.updateResizeLatLng(e);
  	            L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);
  	        },

  	        resize: function (e) {
  	            var radius = this.feature._latlng.distanceTo(e.latlng);
  	            this.feature.setRadius(radius);
  	        },

  	        onDrawingMouseDown: function (e) {
  	            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);
  	            this._resizeLatLng.update(e.latlng);
  	            this.feature._latlng.update(e.latlng);
  	            this.connect();
  	            // Stop dragging map.
  	            e.originalEvent._simulated = false;
  	            this.map.dragging._draggable._onUp(e.originalEvent);
  	            // Now transfer ongoing drag action to the radius handler.
  	            this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);
  	        },

  	        onDrawingMouseUp: function (e) {
  	            this.commitDrawing(e);
  	            e.originalEvent._simulated = false;
  	            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);
  	        },

  	        onDrawingMouseMove: function (e) {
  	            e.originalEvent._simulated = false;
  	            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);
  	        },

  	        onDrag: function (e) {
  	            L.Editable.PathEditor.prototype.onDrag.call(this, e);
  	            this.feature.dragging.updateLatLng(this._resizeLatLng);
  	        }

  	    });

  	    // namespace Editable; class EditableMixin
  	    // `EditableMixin` is included to `L.Polyline`, `L.Polygon`, `L.Rectangle`, `L.Circle`
  	    // and `L.Marker`. It adds some methods to them.
  	    // *When editing is enabled, the editor is accessible on the instance with the
  	    // `editor` property.*
  	    var EditableMixin = {

  	        createEditor: function (map) {
  	            map = map || this._map;
  	            var tools = (this.options.editOptions || {}).editTools || map.editTools;
  	            if (!tools) throw Error('Unable to detect Editable instance.')
  	            var Klass = this.options.editorClass || this.getEditorClass(tools);
  	            return new Klass(map, this, this.options.editOptions);
  	        },

  	        // method enableEdit(map?: L.Map): this.editor
  	        // Enable editing, by creating an editor if not existing, and then calling `enable` on it.
  	        enableEdit: function (map) {
  	            if (!this.editor) this.createEditor(map);
  	            this.editor.enable();
  	            return this.editor;
  	        },

  	        // method editEnabled(): boolean
  	        // Return true if current instance has an editor attached, and this editor is enabled.
  	        editEnabled: function () {
  	            return this.editor && this.editor.enabled();
  	        },

  	        // method disableEdit()
  	        // Disable editing, also remove the editor property reference.
  	        disableEdit: function () {
  	            if (this.editor) {
  	                this.editor.disable();
  	                delete this.editor;
  	            }
  	        },

  	        // method toggleEdit()
  	        // Enable or disable editing, according to current status.
  	        toggleEdit: function () {
  	            if (this.editEnabled()) this.disableEdit();
  	            else this.enableEdit();
  	        },

  	        _onEditableAdd: function () {
  	            if (this.editor) this.enableEdit();
  	        }

  	    };

  	    var PolylineMixin = {

  	        getEditorClass: function (tools) {
  	            return (tools && tools.options.polylineEditorClass) ? tools.options.polylineEditorClass : L.Editable.PolylineEditor;
  	        },

  	        shapeAt: function (latlng, latlngs) {
  	            // We can have those cases:
  	            // - latlngs are just a flat array of latlngs, use this
  	            // - latlngs is an array of arrays of latlngs, loop over
  	            var shape = null;
  	            latlngs = latlngs || this._latlngs;
  	            if (!latlngs.length) return shape;
  	            else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;
  	            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];
  	            return shape;
  	        },

  	        isInLatLngs: function (l, latlngs) {
  	            if (!latlngs) return false;
  	            var i, k, len, part = [], p,
  	                w = this._clickTolerance();
  	            this._projectLatlngs(latlngs, part, this._pxBounds);
  	            part = part[0];
  	            p = this._map.latLngToLayerPoint(l);

  	            if (!this._pxBounds.contains(p)) { return false; }
  	            for (i = 1, len = part.length, k = 0; i < len; k = i++) {

  	                if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {
  	                    return true;
  	                }
  	            }
  	            return false;
  	        }

  	    };

  	    var PolygonMixin = {

  	        getEditorClass: function (tools) {
  	            return (tools && tools.options.polygonEditorClass) ? tools.options.polygonEditorClass : L.Editable.PolygonEditor;
  	        },

  	        shapeAt: function (latlng, latlngs) {
  	            // We can have those cases:
  	            // - latlngs are just a flat array of latlngs, use this
  	            // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first
  	            // - latlngs is an array of arrays of arrays, this is a multi, loop over
  	            var shape = null;
  	            latlngs = latlngs || this._latlngs;
  	            if (!latlngs.length) return shape;
  	            else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;
  	            else if (isFlat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;
  	            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];
  	            return shape;
  	        },

  	        isInLatLngs: function (l, latlngs) {
  	            var inside = false, l1, l2, j, k, len2;

  	            for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {
  	                l1 = latlngs[j];
  	                l2 = latlngs[k];

  	                if (((l1.lat > l.lat) !== (l2.lat > l.lat)) &&
  	                        (l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng)) {
  	                    inside = !inside;
  	                }
  	            }

  	            return inside;
  	        },

  	        parentShape: function (shape, latlngs) {
  	            latlngs = latlngs || this._latlngs;
  	            if (!latlngs) return;
  	            var idx = L.Util.indexOf(latlngs, shape);
  	            if (idx !== -1) return latlngs;
  	            for (var i = 0; i < latlngs.length; i++) {
  	                idx = L.Util.indexOf(latlngs[i], shape);
  	                if (idx !== -1) return latlngs[i];
  	            }
  	        }

  	    };


  	    var MarkerMixin = {

  	        getEditorClass: function (tools) {
  	            return (tools && tools.options.markerEditorClass) ? tools.options.markerEditorClass : L.Editable.MarkerEditor;
  	        }

  	    };

  	    var RectangleMixin = {

  	        getEditorClass: function (tools) {
  	            return (tools && tools.options.rectangleEditorClass) ? tools.options.rectangleEditorClass : L.Editable.RectangleEditor;
  	        }

  	    };

  	    var CircleMixin = {

  	        getEditorClass: function (tools) {
  	            return (tools && tools.options.circleEditorClass) ? tools.options.circleEditorClass : L.Editable.CircleEditor;
  	        }

  	    };

  	    var keepEditable = function () {
  	        // Make sure you can remove/readd an editable layer.
  	        this.on('add', this._onEditableAdd);
  	    };

  	    var isFlat = L.LineUtil.isFlat || L.LineUtil._flat || L.Polyline._flat;  // <=> 1.1 compat.


  	    if (L.Polyline) {
  	        L.Polyline.include(EditableMixin);
  	        L.Polyline.include(PolylineMixin);
  	        L.Polyline.addInitHook(keepEditable);
  	    }
  	    if (L.Polygon) {
  	        L.Polygon.include(EditableMixin);
  	        L.Polygon.include(PolygonMixin);
  	    }
  	    if (L.Marker) {
  	        L.Marker.include(EditableMixin);
  	        L.Marker.include(MarkerMixin);
  	        L.Marker.addInitHook(keepEditable);
  	    }
  	    if (L.Rectangle) {
  	        L.Rectangle.include(EditableMixin);
  	        L.Rectangle.include(RectangleMixin);
  	    }
  	    if (L.Circle) {
  	        L.Circle.include(EditableMixin);
  	        L.Circle.include(CircleMixin);
  	    }

  	    L.LatLng.prototype.update = function (latlng) {
  	        latlng = L.latLng(latlng);
  	        this.lat = latlng.lat;
  	        this.lng = latlng.lng;
  	    };

  	}, window)); 
  } (Leaflet_Editable));

  /* A Draggable that does not update the element position
  and takes care of only bubbling to targetted path in Canvas mode. */
  L.PathDraggable = L.Draggable.extend({

    initialize: function (path) {
      this._path = path;
      this._canvas = (path._map.getRenderer(path) instanceof L.Canvas);
      var element = this._canvas ? this._path._map.getRenderer(this._path)._container : this._path._path;
      L.Draggable.prototype.initialize.call(this, element, element, true);
    },

    _updatePosition: function () {
      var e = {originalEvent: this._lastEvent};
      this.fire('drag', e);
    },

    _onDown: function (e) {
      var first = e.touches ? e.touches[0] : e;
      this._startPoint = new L.Point(first.clientX, first.clientY);
      if (this._canvas && !this._path._containsPoint(this._path._map.mouseEventToLayerPoint(first))) { return; }
      L.Draggable.prototype._onDown.call(this, e);
    }

  });


  L.Handler.PathDrag = L.Handler.extend({

    initialize: function (path) {
      this._path = path;
    },

    getEvents: function () {
      return {
        dragstart: this._onDragStart,
        drag: this._onDrag,
        dragend: this._onDragEnd
      };
    },

    addHooks: function () {
      if (!this._draggable) { this._draggable = new L.PathDraggable(this._path); }
      this._draggable.on(this.getEvents(), this).enable();
      L.DomUtil.addClass(this._draggable._element, 'leaflet-path-draggable');
    },

    removeHooks: function () {
      this._draggable.off(this.getEvents(), this).disable();
      L.DomUtil.removeClass(this._draggable._element, 'leaflet-path-draggable');
    },

    moved: function () {
      return this._draggable && this._draggable._moved;
    },

    _onDragStart: function () {
      this._startPoint = this._draggable._startPoint;
      this._path
          .closePopup()
          .fire('movestart')
          .fire('dragstart');
    },

    _onDrag: function (e) {
      var path = this._path,
          event = (e.originalEvent.touches && e.originalEvent.touches.length === 1 ? e.originalEvent.touches[0] : e.originalEvent),
          newPoint = L.point(event.clientX, event.clientY),
          latlng = path._map.layerPointToLatLng(newPoint);

      this._offset = newPoint.subtract(this._startPoint);
      this._startPoint = newPoint;

      this._path.eachLatLng(this.updateLatLng, this);
      path.redraw();

      e.latlng = latlng;
      e.offset = this._offset;
      path.fire('move', e)
          .fire('drag', e);
    },

    _onDragEnd: function (e) {
      if (this._path._bounds) this.resetBounds();
      this._path.fire('moveend')
          .fire('dragend', e);
    },

    latLngToLayerPoint: function (latlng) {
      // Same as map.latLngToLayerPoint, but without the round().
      var projectedPoint = this._path._map.project(L.latLng(latlng));
      return projectedPoint._subtract(this._path._map.getPixelOrigin());
    },

    updateLatLng: function (latlng) {
      var oldPoint = this.latLngToLayerPoint(latlng);
      oldPoint._add(this._offset);
      var newLatLng = this._path._map.layerPointToLatLng(oldPoint);
      latlng.lat = newLatLng.lat;
      latlng.lng = newLatLng.lng;
    },

    resetBounds: function () {
      this._path._bounds = new L.LatLngBounds();
      this._path.eachLatLng(function (latlng) {
        this._bounds.extend(latlng);
      });
    }

  });

  L.Path.include({

    eachLatLng: function (callback, context) {
      context = context || this;
      var loop = function (latlngs) {
        for (var i = 0; i < latlngs.length; i++) {
          if (L.Util.isArray(latlngs[i])) loop(latlngs[i]);
          else callback.call(context, latlngs[i]);
        }
      };
      loop(this.getLatLngs ? this.getLatLngs() : [this.getLatLng()]);
    }

  });

  L.Path.addInitHook(function () {

    this.dragging = new L.Handler.PathDrag(this);
    if (this.options.draggable) {
      this.once('add', function () {
        this.dragging.enable();
      });
    }

  });

  class AddAnother {
    connect() {
      $("[data-action='add-another']").on("click", function(event) {
        event.preventDefault();

        var templateId = $(this).data('template-id');

        var template = document.querySelector('#' + templateId);
        var clone = document.importNode(template.content, true);

        var count = $(this).closest('.form-group').find('[name="' + $(clone).find('[name]').attr('name') + '"]').length + 1;
        $(clone).find('[id]').each(function(index, el) {
          $(el).attr('id', $(el).attr('id') + '_' + String(count));
        });

        $(clone).find('[for]').each(function(index, el) {
          $(el).attr('for', $(el).attr('for') + '_' + String(count));
        });


        $(clone).insertBefore(this);
      });
    }
  }

  class AddNewButton {
    connect() {
      $("[data-expanded-add-button]").each((_i, el) => this.addExpandBehaviorToButton($(el)));
    }

    addExpandBehaviorToButton(button){
      var settings = {
        speed: (button.data('speed') || 450),
        animate_width: (button.data('animate_width') || 425)
      };
      var target = $(button.data('field-target'));
      var save   = $("input[data-behavior='save']", target);
      var cancel = $("input[data-behavior='cancel']", target);
      var input  = $("input[type='text']", target);
      var original_width  = button.outerWidth();
      var expanded = false;

      // Animate button open when the mouse enters or
      // the button is given focus (i.e. clicked/tabbed)
      button.on("mouseenter focus", function(){
        expandButton();
      });

      // Don't allow blank titles
      save.on('click', function(){
        if ( inputEmpty() ) {
          return false;
        }
      });

      // Empty input and collapse
      // button on cancel click
      cancel.on('click', function(e){
        e.preventDefault();
        input.val('');
        collapseButton();
      });

      // Collapse the button on when
      // an empty input loses focus
      input.on("blur", function(){
        if ( inputEmpty() ) {
          collapseButton();
        }
      });
      function expandButton(){
        // If this has not yet been expanded, recalculate original_width to 
        // handle things that may have been originally hidden.
        if (!expanded) {
          original_width  = button.outerWidth();
        }
        if(button.outerWidth() <= (original_width + 5)) {
          expanded = true;
          button.animate(
            {width: settings.animate_width + 'px'}, settings.speed, function(){
              target.show(0, function(){
                input.focus();
                // Set the button to auto width to make
                // sure it has room for any inputs
                button.width("auto");
                // Explicitly set the width of the button
                // so the close animation works properly
                button.width(button.width());
              });
            }
          );
        }
      }
      function collapseButton(){
        target.hide();
        button.animate({width: original_width + 'px'}, settings.speed);
      }
      function inputEmpty(){
        return $.trim(input.val()) == "";
      }
    }
  }

  class BlacklightConfiguration {
    connect() {
      // Add Select/Deselect all button behavior
      this.addCheckboxToggleBehavior();
      this.addEnableToggleBehavior();
    }
    
    // Add Select/Deselect all button behavior
    addCheckboxToggleBehavior() {
      $("[data-behavior='metadata-select']").each(function(){
        var button = $(this);
        var parentCell = button.parents("th");
        var table = parentCell.closest("table");
        var columnRows = $("tr td:nth-child(" + (parentCell.index() + 1) + ")", table);
        var checkboxes = $("input[type='checkbox']", columnRows);
        swapSelectAllButtonText(button, columnRows);
        // Add the check/uncheck behavior to the button
        // and swap the button text if necessary
        button.on('click', function(e){
          e.preventDefault();
          var allChecked = allCheckboxesChecked(columnRows);
          columnRows.each(function(){
            $("input[type='checkbox']", $(this)).prop('checked', !allChecked);
            swapSelectAllButtonText(button, columnRows);
          });
        });
        // Swap button text when a checkbox value changes
        checkboxes.each(function(){
          $(this).on('change', function(){
            swapSelectAllButtonText(button, columnRows);
          });
        });
      });
      // Check number of checkboxes against the number of checked
      // checkboxes to determine if all of them are checked or not
      function allCheckboxesChecked(elements) {
        return ($("input[type='checkbox']", elements).length == $("input[type='checkbox']:checked", elements).length)
      }
      // Swap the button text to "Deselect all"
      // when all the checkboxes are checked and
      // "Select all" when any are unchecked
      function swapSelectAllButtonText(button, elements) {
        if ( allCheckboxesChecked(elements) ) {
          button.text(button.data('deselect-text'));
        } else {
          button.text(button.data('select-text'));
        }
      }
    }

    addEnableToggleBehavior() {
      $("[data-behavior='enable-feature']").each(function(){
        var checkbox = $(this);
        var target = $($(this).data('target'));

        checkbox.on('change', function() {
          if ($(this).is(':checked')) {
            target.find('input:checkbox').not("[data-behavior='enable-feature']").prop('checked', true).attr('disabled', false);
          } else {
            target.find('input:checkbox').not("[data-behavior='enable-feature']").prop('checked', false).attr('disabled', true);
          }
        });
      });
    }
  }

  class CopyEmailAddress {
      connect() {
          new Clipboard('.copy-email-addresses');
      }
  }

  class Iiif {
    constructor(manifestUrl, manifest) {
      this.manifestUrl = manifestUrl;
      this.manifest = manifest;
    }

    sequences() {
      var it = {};
      var context = this;
      it[Symbol.iterator] = function*() {
        for (let sequence of context.manifest.sequences) {
          yield sequence;
        }    };
      return it;
    }

    canvases() {
      var it = {};
      var context = this;
      it[Symbol.iterator] = function*() {
        for (let sequence of context.sequences()) {
          for (let canvas of sequence.canvases) {
            yield canvas;
          }
        }
      };
      return it;
    }

    images() {
      var it = {};
      var context = this;
      it[Symbol.iterator] = function*() {
        for (let canvas of context.canvases()) {
          for (let image of canvas.images) {
            var iiifService = image.resource.service['@id'];
            yield {
              'thumb': iiifService + '/full/!100,100/0/default.jpg',
              'tilesource': iiifService + '/info.json',
              'manifest': context.manifestUrl,
              'canvasId': canvas['@id'],
              'imageId': image['@id']
            };
          }
        }
      };
      return it;
    }

    imagesArray() {
      return Array.from(this.images())
    }
  }

  function addImageSelector(input, panel, manifestUrl, initialize) {
    if (!manifestUrl) {
      showNonIiifAlert(input);
      return;
    }
    var cropper = input.data('iiifCropper');
    $.ajax(manifestUrl).done(
      function(manifest) {
        var iiifManifest = new Iiif(manifestUrl, manifest);

        var thumbs = iiifManifest.imagesArray();

        hideNonIiifAlert(input);

        if (initialize) {
          cropper.setIiifFields(thumbs[0]);
          panel.multiImageSelector(); // Clears out existing selector
        }

        if(thumbs.length > 1) {
          panel.show();
          panel.multiImageSelector(thumbs, function(selectorImage) {
            cropper.setIiifFields(selectorImage);
          }, cropper.iiifImageField.val());
        }
      }
    );
  }

  function showNonIiifAlert(input){
    input.parent().prev('[data-behavior="non-iiif-alert"]').show();
  }

  function hideNonIiifAlert(input){
    input.parent().prev('[data-behavior="non-iiif-alert"]').hide();
  }

  const Spotlight$1 = function() {
    var buffer = [];
    return {
      onLoad: function(func) {
        buffer.push(func);
      },

      activate: function() {
        this.sirTrevorIcon = window.sirTrevorIcon;
        for(var i = 0; i < buffer.length; i++) {
          buffer[i].call();
        }
      },
      csrfToken: function () {
        return document.querySelector('meta[name=csrf-token]')?.content
      },
      ZprLinks: {
        close: "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\"><path d=\"M0 0h24v24H0V0z\" fill=\"none\"/><path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z\"/></svg>",
        zoomIn: "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\"><path d=\"M0 0h24v24H0V0z\" fill=\"none\"/><path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zm.5-7H9v2H7v1h2v2h1v-2h2V9h-2z\"/></svg>\n",
        zoomOut: "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\"><path d=\"M0 0h24v24H0V0z\" fill=\"none\"/><path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7V9z\"/></svg>\n"
      }
    };
  }();

  // This allows us to configure Spotlight in app/views/layouts/base.html.erb
  window.Spotlight = Spotlight$1;

  Blacklight.onLoad(function() {
    Spotlight$1.activate();
  });

  class Crop {
    constructor(cropArea) {
      this.cropArea = cropArea;
      this.cropArea.data('iiifCropper', this);
      this.cropSelector = '[data-cropper="' + cropArea.data('cropperKey') + '"]';
      this.cropTool = $(this.cropSelector);
      this.formPrefix = this.cropTool.data('form-prefix');
      this.iiifUrlField = $('#' + this.formPrefix + '_iiif_tilesource');
      this.iiifRegionField = $('#' + this.formPrefix + '_iiif_region');
      this.iiifManifestField = $('#' + this.formPrefix + '_iiif_manifest_url');
      this.iiifCanvasField = $('#' + this.formPrefix + '_iiif_canvas_id');
      this.iiifImageField = $('#' + this.formPrefix + '_iiif_image_id');

      this.form = cropArea.closest('form');
      this.tileSource = null;
    }

    // Render the cropper environment and add hooks into the autocomplete and upload forms
    render() {
      this.setupAutoCompletes();
      this.setupAjaxFileUpload();
      this.setupExistingIiifCropper();
    }

    // Setup the cropper on page load if the field
    // that holds the IIIF url is populated
    setupExistingIiifCropper() {
      if(this.iiifUrlField.val() === '') {
        return;
      }

      this.addImageSelectorToExistingCropTool();
      this.setTileSource(this.iiifUrlField.val());
    }

    // Display the IIIF Cropper map with the current IIIF Layer (and cropbox, once the layer is available)
    setupIiifCropper() {
      this.loaded = false;

      this.renderCropperMap();

      if (this.imageLayer) {
        // Force a broken layer's container to be an element before removing.
        // Code in leaflet-iiif land calls delete on the image layer's container when removing,
        // which errors if there is an issue fetching the info.json and stops further necessary steps to execute.
        if(!this.imageLayer._container) {
          this.imageLayer._container = $('<div></div>');
        }
        this.cropperMap.removeLayer(this.imageLayer);
      }

      this.imageLayer = L.tileLayer.iiif(this.tileSource).addTo(this.cropperMap);

      var self = this;
      this.imageLayer.on('load', function() {
        if (!self.loaded) {
          var region = self.getCropRegion();
          self.positionIiifCropBox(region);
          self.loaded = true;
        }
      });

      this.cropArea.data('initiallyVisible', this.cropArea.is(':visible'));
    }

    // Get (or initialize) the current crop region from the form data
    getCropRegion() {
      var regionFieldValue = this.iiifRegionField.val();
      if(!regionFieldValue || regionFieldValue === '') {
        var region = this.defaultCropRegion();
        this.iiifRegionField.val(region);
        return region;
      } else {
        return regionFieldValue.split(',');
      }
    }

    // Calculate a default crop region in the center of the image using the correct aspect ratio
    defaultCropRegion() {
      var imageWidth = this.imageLayer.x;
      var imageHeight = this.imageLayer.y;

      var boxWidth = Math.floor(imageWidth / 2);
      var boxHeight = Math.floor(boxWidth / this.aspectRatio());

      return [
        Math.floor((imageWidth - boxWidth) / 2),
        Math.floor((imageHeight - boxHeight) / 2),
        boxWidth,
        boxHeight
      ];
    }

    // Calculate the required aspect ratio for the crop area
    aspectRatio() {
      var cropWidth = parseInt(this.cropArea.data('crop-width'));
      var cropHeight = parseInt(this.cropArea.data('crop-height'));
      return cropWidth / cropHeight;
    }

    // Position the IIIF Crop Box at the given IIIF region
    positionIiifCropBox(region) {
      var bounds = this.unprojectIIIFRegionToBounds(region);

      if (!this.cropBox) {
        this.renderCropBox(bounds);
      }

      this.cropBox.setBounds(bounds);
      this.cropperMap.invalidateSize();
      this.cropperMap.fitBounds(bounds);

      this.cropBox.editor.editLayer.clearLayers();
      this.cropBox.editor.refresh();
      this.cropBox.editor.initVertexMarkers();
    }

    // Set all of the various input fields to
    // the appropriate IIIF URL or identifier
    setIiifFields(iiifObject) {
      this.setTileSource(iiifObject.tilesource);
      this.iiifManifestField.val(iiifObject.manifest);
      this.iiifCanvasField.val(iiifObject.canvasId);
      this.iiifImageField.val(iiifObject.imageId);
    }

    // Set the Crop tileSource and setup the cropper
    setTileSource(source) {
      if (source == this.tileSource) {
        return;
      }

      if (source === null || source === undefined) {
        console.error('No tilesource provided when setting up IIIF Cropper');
        return;
      }

      if (this.cropBox) {
        this.iiifRegionField.val("");
      }

      this.tileSource = source;
      this.iiifUrlField.val(source);
      this.setupIiifCropper();
    }

    // Render the Leaflet Map into the crop area
    renderCropperMap() {
      if (this.cropperMap) {
        return;
      }
      this.cropperMap = L.map(this.cropArea.attr('id'), {
        editable: true,
        center: [0, 0],
        crs: L.CRS.Simple,
        zoom: 0,
        editOptions: {
          rectangleEditorClass: this.aspectRatioPreservingRectangleEditor(this.aspectRatio())
        }
      });
      this.invalidateMapSizeOnTabToggle();
    }

    // Render the crop box (a Leaflet editable rectangle) onto the canvas
    renderCropBox(initialBounds) {
      this.cropBox = L.rectangle(initialBounds);
      this.cropBox.addTo(this.cropperMap);
      this.cropBox.enableEdit();
      this.cropBox.on('dblclick', L.DomEvent.stop).on('dblclick', this.cropBox.toggleEdit);

      var self = this;
      this.cropperMap.on('editable:dragend editable:vertex:dragend', function(e) {
        var bounds = e.layer.getBounds();
        var region = self.projectBoundsToIIIFRegion(bounds);

        self.iiifRegionField.val(region.join(','));
      });
    }

    // Get the maximum zoom level for the IIIF Layer (always 1:1 image pixel to canvas?)
    maxZoom() {
      if(this.imageLayer) {
        return this.imageLayer.maxZoom;
      }
    }

    // Take a Leaflet LatLngBounds object and transform it into a IIIF [x, y, w, h] region
    projectBoundsToIIIFRegion(bounds) {
      var min = this.cropperMap.project(bounds.getNorthWest(), this.maxZoom());
      var max = this.cropperMap.project(bounds.getSouthEast(), this.maxZoom());
      return [
        Math.max(Math.floor(min.x), 0),
        Math.max(Math.floor(min.y), 0),
        Math.floor(max.x - min.x),
        Math.floor(max.y - min.y)
      ];
    }

    // Take a IIIF [x, y, w, h] region and transform it into a Leaflet LatLngBounds
    unprojectIIIFRegionToBounds(region) {
      var minPoint = L.point(parseInt(region[0]), parseInt(region[1]));
      var maxPoint = L.point(parseInt(region[0]) + parseInt(region[2]), parseInt(region[1]) + parseInt(region[3]));

      var min = this.cropperMap.unproject(minPoint, this.maxZoom());
      var max = this.cropperMap.unproject(maxPoint, this.maxZoom());
      return L.latLngBounds(min, max);
    }

    // TODO: Add accessors to update hidden inputs with IIIF uri/ids?

    // Setup autocomplete inputs to have the iiif_cropper context
    setupAutoCompletes() {
      var input = $('[data-behavior="autocomplete"]', this.cropTool);
      input.data('iiifCropper', this);
    }

    setupAjaxFileUpload() {
      this.fileInput = $('input[type="file"]', this.cropTool);
      this.fileInput.change(() => this.uploadFile());
    }

    addImageSelectorToExistingCropTool() {
      if(this.iiifManifestField.val() === '') {
        return;
      }

      var input = $('[data-behavior="autocomplete"]', this.cropTool);
      var panel = $(input.data('target-panel'));

      addImageSelector(input, panel, this.iiifManifestField.val(), !this.iiifImageField.val());
    }

    invalidateMapSizeOnTabToggle() {
      var tabs = $('[role="tablist"]', this.form);
      var self = this;
      tabs.on('shown.bs.tab', function() {
        if(self.cropArea.data('initiallyVisible') === false && self.cropArea.is(':visible')) {
          self.cropperMap.invalidateSize();
          // Because the map size is 0,0 when image is loading (not visible) we need to refit the bounds of the layer
          self.imageLayer._fitBounds();
          self.cropArea.data('initiallyVisible', null);
        }
      });
    }

    // Get all the form data with the exception of the _method field.
    getData() {
      var data = new FormData(this.form[0]);
      data.append('_method', null);
      return data;
    }

    uploadFile() {
      var url = this.fileInput.data('endpoint');
      // Every post creates a new image/masthead.
      // Because they create IIIF urls which are heavily cached.
      $.ajax({
        url: url,  //Server script to process data
        type: 'POST',
        success: (data, stat, xhr) => this.successHandler(data, stat, xhr),
        // error: errorHandler,
        // Form data
        data: this.getData(),
        headers: {
          'X-CSRF-Token': Spotlight$1.csrfToken() || ''
        },
        //Options to tell jQuery not to process data or worry about content-type.
        cache: false,
        contentType: false,
        processData: false
      });
    }

    successHandler(data, stat, xhr) {
      this.setIiifFields({ tilesource: data.tilesource });
      this.setUploadId(data.id);
    }

    setUploadId(id) {
      $('#' + this.formPrefix + "_upload_id").val(id);
    }

    aspectRatioPreservingRectangleEditor(aspect) {
      return L.Editable.RectangleEditor.extend({
        extendBounds: function (e) {
          var index = e.vertex.getIndex(),
              next = e.vertex.getNext(),
              previous = e.vertex.getPrevious(),
              oppositeIndex = (index + 2) % 4,
              opposite = e.vertex.latlngs[oppositeIndex];

          if ((index % 2) == 1) {
            // calculate horiz. displacement
            e.latlng.update([opposite.lat + ((1 / aspect) * (opposite.lng - e.latlng.lng)), e.latlng.lng]);
          } else {
            // calculate vert. displacement
            e.latlng.update([e.latlng.lat, (opposite.lng - (aspect * (opposite.lat - e.latlng.lat)))]);
          }
          var bounds = new L.LatLngBounds(e.latlng, opposite);
          // Update latlngs by hand to preserve order.
          previous.latlng.update([e.latlng.lat, opposite.lng]);
          next.latlng.update([opposite.lat, e.latlng.lng]);
          this.updateBounds(bounds);
          this.refreshVertexMarkers();
        }
      });
    }
  }

  class Croppable {
    connect() {
      $('[data-behavior="iiif-cropper"]').each(function() {
        var cropElement = $(this);
        new Crop(cropElement).render();
      });
    }
  }

  /*
    Simple plugin add edit-in-place behavior
  */
  class EditInPlace {
    connect() {
      $('[data-in-place-edit-target]').each(function() {
        $(this).on('click.inplaceedit', function() {
          var $label = $(this).find($(this).data('in-place-edit-target'));
          var $input = $(this).find($(this).data('in-place-edit-field-target'));

          // hide the edit-in-place affordance icon while in edit mode
          $(this).addClass('hide-edit-icon');
          $label.hide();
          $input.val($label.text());
          $input.attr('type', 'text');
          $input.select();
          $input.focus();

          $input.on('keypress', function(e) {
            if(e.which == 13) {
              $input.trigger('blur.inplaceedit');
              return false;
            }
          });

          $input.on('blur.inplaceedit', function() {
            var value = $input.val();

            if ($.trim(value).length == 0) {
              $input.val($label.text());
            } else {
              $label.text(value);
            }

            $label.show();
            $input.attr('type', 'hidden');
            // when leaving edit mode, should no longer hide edit-in-place affordance icon
            $("[data-in-place-edit-target]").removeClass('hide-edit-icon');

            return false;
          });

          return false;
        });
      });

      $("[data-behavior='restore-default']").each(function(){
        var hidden = $("[data-default-value]", $(this));
        var value = $($("[data-in-place-edit-target]", $(this)).data('in-place-edit-target'), $(this));
        var button = $("[data-restore-default]", $(this));

        hidden.on('keypress', function(e) {
          if(e.which == 13) {
            hidden.trigger('blur');
            return false;
          }
        });

        hidden.on('blur', function(){
          if( $(this).val() == $(this).data('default-value') ) {
            button.addClass('d-none');
          } else {
            button.removeClass('d-none');
          }
        });
        button.on('click', function(e){
          e.preventDefault();
          hidden.val(hidden.data('default-value'));
          value.text(hidden.data('default-value'));
          button.hide();
        });
      });
    }
  }

  class ExhibitTagAutocomplete {
    connect() {
      $('[data-autocomplete-tag="true"]').each(function(_i, el) {
        var $el = $(el);
        // By default tags input binds on page ready to [data-role=tagsinput],
        // however, that doesn't work with Turbolinks. So we init manually:
        $el.tagsinput();

        var tags = new Bloodhound({
          datumTokenizer: function(d) { return Bloodhound.tokenizers.whitespace(d.name); },
          queryTokenizer: Bloodhound.tokenizers.whitespace,
          limit: 100,
          prefetch: {
            url: $el.data('autocomplete-url'),
            ttl: 1,
            filter: function(list) {
              // Let the dom know that the response has been returned
              $el.attr('data-autocomplete-fetched', true);
              return $.map(list, function(tag) { return { name: tag }; });
            }
          }
        });

        tags.initialize();

        $el.tagsinput('input').typeahead({highlight: true, hint: false}, {
          name: 'tags',
          displayKey: 'name',
          source: tags.ttAdapter()
        }).bind('typeahead:selected', $.proxy(function (obj, datum) {
          $el.tagsinput('add', datum.name);
          $el.tagsinput('input').typeahead('val', '');
        })).bind('blur', function() {
          $el.tagsinput('add', $el.tagsinput('input').typeahead('val'));
          $el.tagsinput('input').typeahead('val', '');
        });
      });
    }
  }

  /*
  https://gist.github.com/pjambet/3710461
  */
  var LATIN_MAP = {
    '': 'A', '': 'A', '': 'A', '': 'A', '': 'A', '': 'A', '': 'AE', '':
    'C', '': 'E', '': 'E', '': 'E', '': 'E', '': 'I', '': 'I', '': 'I',
    '': 'I', '': 'D', '': 'N', '': 'O', '': 'O', '': 'O', '': 'O', '':
    'O', '': 'O', '': 'O', '': 'U', '': 'U', '': 'U', '': 'U', '': 'U',
    '': 'Y', '': 'TH', '': 'ss', '':'a', '':'a', '': 'a', '': 'a', '':
    'a', '': 'a', '': 'ae', '': 'c', '': 'e', '': 'e', '': 'e', '': 'e',
    '': 'i', '': 'i', '': 'i', '': 'i', '': 'd', '': 'n', '': 'o', '':
    'o', '': 'o', '': 'o', '': 'o', '': 'o', '': 'o', '': 'u', '': 'u',
    '': 'u', '': 'u', '': 'u', '': 'y', '': 'th', '': 'y'
  };
  var LATIN_SYMBOLS_MAP = {
    '':'(c)'
  };
  var GREEK_MAP = {
    '':'a', '':'b', '':'g', '':'d', '':'e', '':'z', '':'h', '':'8',
    '':'i', '':'k', '':'l', '':'m', '':'n', '':'3', '':'o', '':'p',
    '':'r', '':'s', '':'t', '':'y', '':'f', '':'x', '':'ps', '':'w',
    '':'a', '':'e', '':'i', '':'o', '':'y', '':'h', '':'w', '':'s',
    '':'i', '':'y', '':'y', '':'i',
    '':'A', '':'B', '':'G', '':'D', '':'E', '':'Z', '':'H', '':'8',
    '':'I', '':'K', '':'L', '':'M', '':'N', '':'3', '':'O', '':'P',
    '':'R', '':'S', '':'T', '':'Y', '':'F', '':'X', '':'PS', '':'W',
    '':'A', '':'E', '':'I', '':'O', '':'Y', '':'H', '':'W', '':'I',
    '':'Y'
  };
  var TURKISH_MAP = {
    '':'s', '':'S', '':'i', '':'I', '':'c', '':'C', '':'u', '':'U',
    '':'o', '':'O', '':'g', '':'G'
  };
  var RUSSIAN_MAP = {
    '':'a', '':'b', '':'v', '':'g', '':'d', '':'e', '':'yo', '':'zh',
    '':'z', '':'i', '':'j', '':'k', '':'l', '':'m', '':'n', '':'o',
    '':'p', '':'r', '':'s', '':'t', '':'u', '':'f', '':'h', '':'c',
    '':'ch', '':'sh', '':'sh', '':'', '':'y', '':'', '':'e', '':'yu',
    '':'ya',
    '':'A', '':'B', '':'V', '':'G', '':'D', '':'E', '':'Yo', '':'Zh',
    '':'Z', '':'I', '':'J', '':'K', '':'L', '':'M', '':'N', '':'O',
    '':'P', '':'R', '':'S', '':'T', '':'U', '':'F', '':'H', '':'C',
    '':'Ch', '':'Sh', '':'Sh', '':'', '':'Y', '':'', '':'E', '':'Yu',
    '':'Ya'
  };
  var UKRAINIAN_MAP = {
    '':'Ye', '':'I', '':'Yi', '':'G', '':'ye', '':'i', '':'yi', '':'g'
  };
  var CZECH_MAP = {
    '':'c', '':'d', '':'e', '': 'n', '':'r', '':'s', '':'t', '':'u',
    '':'z', '':'C', '':'D', '':'E', '': 'N', '':'R', '':'S', '':'T',
    '':'U', '':'Z'
  };

  var POLISH_MAP = {
    '':'a', '':'c', '':'e', '':'l', '':'n', '':'o', '':'s', '':'z',
    '':'z', '':'A', '':'C', '':'e', '':'L', '':'N', '':'o', '':'S',
    '':'Z', '':'Z'
  };

  var LATVIAN_MAP = {
    '':'a', '':'c', '':'e', '':'g', '':'i', '':'k', '':'l', '':'n',
    '':'s', '':'u', '':'z', '':'A', '':'C', '':'E', '':'G', '':'i',
    '':'k', '':'L', '':'N', '':'S', '':'u', '':'Z'
  };

  var ALL_DOWNCODE_MAPS=new Array();
  ALL_DOWNCODE_MAPS[0]=LATIN_MAP;
  ALL_DOWNCODE_MAPS[1]=LATIN_SYMBOLS_MAP;
  ALL_DOWNCODE_MAPS[2]=GREEK_MAP;
  ALL_DOWNCODE_MAPS[3]=TURKISH_MAP;
  ALL_DOWNCODE_MAPS[4]=RUSSIAN_MAP;
  ALL_DOWNCODE_MAPS[5]=UKRAINIAN_MAP;
  ALL_DOWNCODE_MAPS[6]=CZECH_MAP;
  ALL_DOWNCODE_MAPS[7]=POLISH_MAP;
  ALL_DOWNCODE_MAPS[8]=LATVIAN_MAP;

  var Downcoder = new Object();
  Downcoder.Initialize = function()
  {
    if (Downcoder.map) // already made
      return ;
      Downcoder.map ={};
      Downcoder.chars = '' ;
      for(var i in ALL_DOWNCODE_MAPS)
      {
        var lookup = ALL_DOWNCODE_MAPS[i];
        for (var c in lookup)
        {
          Downcoder.map[c] = lookup[c] ;
          Downcoder.chars += c ;
        }
      }
      Downcoder.regex = new RegExp('[' + Downcoder.chars + ']|[^' + Downcoder.chars + ']+','g') ;
    };
    
  const downcode = function( slug )
  {
    Downcoder.Initialize() ;
    var downcoded ="";
    var pieces = slug.match(Downcoder.regex);
    if(pieces)
    {
      for (var i = 0 ; i < pieces.length ; i++)
      {
        if (pieces[i].length == 1)
        {
          var mapped = Downcoder.map[pieces[i]] ;
          if (mapped != null)
          {
            downcoded+=mapped;
            continue ;
          }
        }
        downcoded+=pieces[i];
      }
    }
    else
    {
      downcoded = slug;
    }
    return downcoded;
  };


  function URLify(s, num_chars) {
    // changes, e.g., "Petty theft" to "petty_theft"
    // remove all these words from the string before urlifying
    s = downcode(s);
    //
    // if downcode doesn't hit, the char will be stripped here
    s = s.replace(/[^-\w\s]/g, ' ');  // remove unneeded chars
    s = s.replace(/^\s+|\s+$/g, ''); // trim leading/trailing spaces
    s = s.replace(/[-\s]+/g, '-');   // convert spaces to hyphens
    s = s.toLowerCase();             // convert to lowercase
    return s.substring(0, num_chars);// trim to first num_chars chars
  }

  class Exhibits {
    connect() {
      // auto-fill the exhibit slug on the new exhibit form
      $('#new_exhibit').each(function() {
        $('#exhibit_title').on('change keyup', function() {
          $('#exhibit_slug').attr('placeholder', URLify($(this).val(), $(this).val().length));
        });

        $('#exhibit_slug').on('focus', function() {
          if ($(this).val() === '') {
            $(this).val($(this).attr('placeholder'));
          }
        });
      });

      $("#another-email").on("click", function(e) {
        e.preventDefault();

        var container = $(this).closest('.form-group');
        var contacts = container.find('.contact');
        var inputContainer = contacts.first().clone();

        // wipe out any values from the inputs
        inputContainer.find('input').each(function() {
          $(this).val('');
          $(this).attr('id', $(this).attr('id').replace('0', contacts.length));
          $(this).attr('name', $(this).attr('name').replace('0', contacts.length));
          if ($(this).attr('aria-label')) {
            $(this).attr('aria-label', $(this).attr('aria-label').replace('1', contacts.length + 1));
          }
        });

        inputContainer.find('.contact-email-delete-wrapper').remove();
        inputContainer.find('.confirmation-status').remove();

        // bootstrap does not render input-groups with only one value in them correctly.
        inputContainer.find('.input-group input:only-child').closest('.input-group').removeClass('input-group');

        $(inputContainer).insertAfter(contacts.last());
      });

      $('.contact-email-delete').on('ajax:success', function() {
        $(this).closest('.contact').fadeOut(250, function() { $(this).remove(); });
      });

      $('.contact-email-delete').on('ajax:error', function(event, _xhr, _status, error) {
        var errSpan = $(this).closest('.contact').find('.contact-email-delete-error');
        errSpan.show();
        errSpan.find('.error-msg').first().text(error || event.detail[1]);
      });

      document.addEventListener('turbo:submit-end', (event) => {
        const response = event.detail.fetchResponse;
        if (!response.succeeded && response.response.status === 404) {
          const path = new URL(event.target.action).pathname;
          const deleteButton = document.querySelector(`.contact-email-delete[href="${path}"]`);
          if (deleteButton) {
            const errSpan = deleteButton.closest('.contact').querySelector('.contact-email-delete-error');
            const errorMsg = errSpan.querySelector('.error-msg');
            errSpan.style.display = 'block';
            errorMsg.textContent = 'Not Found';
          }
        }
      });

      if ($.fn.tooltip) {
        $('.btn-with-tooltip').tooltip();
      }

      // Put focus in saved search title input when Save this search modal is shown
      $('#save-modal').on('shown.bs.modal', function () {
          $('#search_title').focus();
      });
    }
  }

  (function($, _) {

    /*
    * SerializedForm is built as a singleton jQuery plugin. It needs to be able to
    * handle instantiation from multiple sources, and use the [data-form-observer]
    * as global state object.
    */
    $.SerializedForm = function () {
      var $serializedForm;
      var plugin = this;

      // Store form serialization in data attribute
      function serializeFormStatus () {
        $serializedForm.data('serialized-form', formSerialization($serializedForm));
      }

      // Do custom serialization of the sir-trevor form data. This needs to be a
      // passed in argument for comparison later on.
      function formSerialization (form) {
        var content_editable = [];
        var i = 0;
        $("[contenteditable='true']", form).each(function(){
          content_editable.push('&contenteditable_' + i + '=' + $(this).text());
        });
        return form.serialize() + content_editable.join();
      }

      // Unbind observing form on submit (which we have to do because of turbolinks)
      function unbindObservedFormSubmit () {
        $serializedForm.on('submit', function () {
          $(this).data('being-submitted', true);
        });
      }

      // Get the stored serialized form status
      function serializedFormStatus () {
        return $serializedForm.data('serialized-form');
      }

      // Check all observed forms on page for status change
      plugin.observedFormsStatusHasChanged = function () {
        var unsaved_changes = false;
        $('[data-form-observer]').each(function (){
          if ( !$(this).data("being-submitted") ) {
            if (serializedFormStatus() != formSerialization($(this))) {
              unsaved_changes = true;
            }
          }
        });
        return unsaved_changes;
      };

      function init () {
        $serializedForm = $('[data-form-observer]');
        serializeFormStatus();
        unbindObservedFormSubmit();
      }

      init();

      return plugin;
    };
  })(jQuery);

  class FormObserver {
    connect() {
      // Instantiate the singleton SerializedForm plugin
      var serializedForm = $.SerializedForm();
      $(window).on('beforeunload page:before-change turbolinks:before-visit', function(event) {
        // Don't handle the same event twice #turbolinks
        if (event.handled !== true) {
          if ( serializedForm.observedFormsStatusHasChanged() ) {
            event.handled = true;
            var message = "You have unsaved changes. Are you sure you want to leave this page?";
            // There are variations in how Webkit browsers may handle this:
            // https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload
            if ( event.type == "beforeunload" ) {
              return message;
            } else {
              return confirm(message)
            }
          }
        }
      });
    }
  }

  class Locks {
    delete_lock(el) {
      $.ajax({ url: $(el).data('lock'), type: 'POST', data: { _method: "delete" }, async: false});
      $(el).removeAttr('data-lock');
    }

    connect() {
      $('[data-lock]').on('click', (e) => {
        this.delete_lock(e.target);
      });
    }
  }

  // Module to add multi-image selector to widget panels

  (function($, _){
    $.fn.multiImageSelector = function(image_versions, clickCallback, activeImageId) {
      var changeLink          = $("<a href='javascript:;'>Change</a>"),
          thumbsListContainer = $("<div class='thumbs-list' style='display:none'></div>"),
          thumbList           = $("<ul></ul>"),
          panel;

      var imageIds = $.map(image_versions, function(e) { return e['imageId']; });

      return init(this);

      function init(el) {
        panel = el;

        destroyExistingImageSelector();
        if(image_versions && image_versions.length > 1) {
          addChangeLink();
          addThumbsList();
        }
      }
      function addChangeLink() {
        $('[data-panel-image-pagination]', panel)
          .html("Image <span data-current-image='true'>" + indexOf(activeImageId) + "</span> of " + image_versions.length)
          .show()
          .append(" ")
          .append(changeLink);
        addChangeLinkBehavior();
      }

      function destroyExistingImageSelector() {
        var pagination = $('[data-panel-image-pagination]', panel);
        pagination.html('');
        pagination.next('.' + thumbsListContainer.attr('class')).remove();
      }

      function indexOf(thumb){
        const index = imageIds.indexOf(thumb);
        if (index > -1) {
          return index + 1;
        } else {
          return 1;
        }
      }
      function addChangeLinkBehavior() {
        changeLink.on('click', function(){
          thumbsListContainer.slideToggle();
          updateThumbListWidth();
          addScrollBehavior();
          scrollToActiveThumb();
          loadVisibleThumbs();
          swapChangeLinkText($(this));
        });
      }
      function updateThumbListWidth() {
        var width = 0;
        $('li', thumbList).each(function(){
          width += $(this).outerWidth();
        });
        thumbList.width(width + 5);
      }
      function loadVisibleThumbs(){
        var viewportWidth = thumbsListContainer.width();
        var width = 0;
        $('li', thumbList).each(function(){
          var thisThumb  = $(this),
              image      = $('img', thisThumb),
              totalWidth = width += thisThumb.width(),
              position   = (thumbList.position().left + totalWidth) - thisThumb.width();

          if(position >= 0 && position < viewportWidth) {
            image.prop('src', image.data('src'));
          }
        });
      }
      function addScrollBehavior(){
        thumbsListContainer.scrollStop(function(){
          loadVisibleThumbs();
        });
      }
      function scrollToActiveThumb(){
        var halfContainerWidth      = (thumbsListContainer.width() / 2),
            activeThumbLeftPosition = ($('.active', thumbList).position() || $('li', thumbList).first().position()).left,
            halfActiveThumbWidth    = ($('.active', thumbList).width() / 2);
        thumbsListContainer.scrollLeft(
          (activeThumbLeftPosition - halfContainerWidth) + halfActiveThumbWidth
        );
      }
      function addThumbsList() {
        addThumbsToList();
        updateActiveThumb();
        $('.card-header', panel).append(
          thumbsListContainer.append(
            thumbList
          )
        );
      }
      function updateActiveThumb(){
        $('li', thumbList).each(function(){
          var item = $(this);
          if($('img', item).data('image-id') == activeImageId){
            item.addClass('active');
          }
        });
      }
      function swapChangeLinkText(link){
        link.text(
          link.text() == 'Change' ? 'Close' : 'Change'
        );
      }

      function addThumbsToList(){
        $.each(image_versions, function(i){
          var listItem = $('<li data-index="' + i + '"><a href="javascript:;"><img src="' + image_versions[i]['thumb'] +'" data-image-id="' + image_versions[i]['imageId'] +'" /></a></li>');
          listItem.on('click', function(){
            // get the current image id
            $('img', $(this)).data('image-id');
            var src = $('img', $(this)).attr('src');

            if (typeof clickCallback === 'function' ) {
              clickCallback(image_versions[i]);
            }

            // mark the current selection as active
            $('li.active', thumbList).removeClass('active');
            $(this).addClass('active');

            // update the multi-image selector image
            $(".pic img.img-thumbnail", panel).attr("src", src);

            $('[data-panel-image-pagination] [data-current-image]', panel).text(
              $('li', thumbList).index($(this)) + 1
            );
            scrollToActiveThumb();
          });
          $("img", listItem).on('load', function() {
            updateThumbListWidth();
          });
          thumbList.append(listItem);
        });
      }
    };

  })(jQuery);

  // source: http://stackoverflow.com/questions/14035083/jquery-bind-event-on-scroll-stops
  jQuery.fn.scrollStop = function(callback) {
    $(this).scroll(function() {
      var self  = this,
      $this = $(self);

      if ($this.data('scrollTimeout')) {
        clearTimeout($this.data('scrollTimeout'));
      }

      $this.data('scrollTimeout', setTimeout(callback, 250, self));
    });
  };

  var sirTrevor = {exports: {}};

  (function (module, exports) {
  	(function webpackUniversalModuleDefinition(root, factory) {
  		module.exports = factory();
  	})(window, function() {
  	return /******/ (function(modules) { // webpackBootstrap
  	/******/ 	// The module cache
  	/******/ 	var installedModules = {};
  	/******/
  	/******/ 	// The require function
  	/******/ 	function __webpack_require__(moduleId) {
  	/******/
  	/******/ 		// Check if module is in cache
  	/******/ 		if(installedModules[moduleId]) {
  	/******/ 			return installedModules[moduleId].exports;
  	/******/ 		}
  	/******/ 		// Create a new module (and put it into the cache)
  	/******/ 		var module = installedModules[moduleId] = {
  	/******/ 			i: moduleId,
  	/******/ 			l: false,
  	/******/ 			exports: {}
  	/******/ 		};
  	/******/
  	/******/ 		// Execute the module function
  	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  	/******/
  	/******/ 		// Flag the module as loaded
  	/******/ 		module.l = true;
  	/******/
  	/******/ 		// Return the exports of the module
  	/******/ 		return module.exports;
  	/******/ 	}
  	/******/
  	/******/
  	/******/ 	// expose the modules object (__webpack_modules__)
  	/******/ 	__webpack_require__.m = modules;
  	/******/
  	/******/ 	// expose the module cache
  	/******/ 	__webpack_require__.c = installedModules;
  	/******/
  	/******/ 	// define getter function for harmony exports
  	/******/ 	__webpack_require__.d = function(exports, name, getter) {
  	/******/ 		if(!__webpack_require__.o(exports, name)) {
  	/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
  	/******/ 		}
  	/******/ 	};
  	/******/
  	/******/ 	// define __esModule on exports
  	/******/ 	__webpack_require__.r = function(exports) {
  	/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  	/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  	/******/ 		}
  	/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
  	/******/ 	};
  	/******/
  	/******/ 	// create a fake namespace object
  	/******/ 	// mode & 1: value is a module id, require it
  	/******/ 	// mode & 2: merge all properties of value into the ns
  	/******/ 	// mode & 4: return value when already ns object
  	/******/ 	// mode & 8|1: behave like require
  	/******/ 	__webpack_require__.t = function(value, mode) {
  	/******/ 		if(mode & 1) value = __webpack_require__(value);
  	/******/ 		if(mode & 8) return value;
  	/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  	/******/ 		var ns = Object.create(null);
  	/******/ 		__webpack_require__.r(ns);
  	/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  	/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  	/******/ 		return ns;
  	/******/ 	};
  	/******/
  	/******/ 	// getDefaultExport function for compatibility with non-harmony modules
  	/******/ 	__webpack_require__.n = function(module) {
  	/******/ 		var getter = module && module.__esModule ?
  	/******/ 			function getDefault() { return module['default']; } :
  	/******/ 			function getModuleExports() { return module; };
  	/******/ 		__webpack_require__.d(getter, 'a', getter);
  	/******/ 		return getter;
  	/******/ 	};
  	/******/
  	/******/ 	// Object.prototype.hasOwnProperty.call
  	/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  	/******/
  	/******/ 	// __webpack_public_path__
  	/******/ 	__webpack_require__.p = "";
  	/******/
  	/******/
  	/******/ 	// Load entry module and return exports
  	/******/ 	return __webpack_require__(__webpack_require__.s = 93);
  	/******/ })
  	/************************************************************************/
  	/******/ ([
  	/* 0 */
  	/***/ (function(module, exports, __webpack_require__) {


  	exports.isEmpty = __webpack_require__(119);
  	exports.isFunction = __webpack_require__(28);
  	exports.isObject = __webpack_require__(18);
  	exports.isString = __webpack_require__(129);
  	exports.isUndefined = __webpack_require__(130);
  	exports.result = __webpack_require__(131);
  	exports.template = __webpack_require__(132);
  	exports.uniqueId = __webpack_require__(139);

  	/***/ }),
  	/* 1 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var config = __webpack_require__(2);

  	var Dom = __webpack_require__(3);

  	var urlRegex = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
  	var utils = {
  	  getInstance: function getInstance(identifier) {
  	    if (_.isUndefined(identifier)) {
  	      return config.instances[0];
  	    }

  	    if (_.isString(identifier)) {
  	      return config.instances.find(function (editor) {
  	        return editor.ID === identifier;
  	      });
  	    }

  	    return config.instances[identifier];
  	  },
  	  getInstanceBySelection: function getInstanceBySelection() {
  	    return utils.getInstance(Dom.getClosest(window.getSelection().anchorNode.parentNode, '.st-block').getAttribute('data-instance'));
  	  },
  	  getBlockBySelection: function getBlockBySelection() {
  	    var instance = utils.getInstanceBySelection();
  	    if (!instance) return;
  	    return instance.findBlockById(Dom.getClosest(window.getSelection().anchorNode.parentNode, '.st-block').id);
  	  },
  	  log: function log() {
  	    if (!_.isUndefined(console) && config.debug) {
  	      console.log.apply(console, arguments);
  	    }
  	  },
  	  isURI: function isURI(string) {
  	    return urlRegex.test(string);
  	  },
  	  titleize: function titleize(str) {
  	    if (str === null) {
  	      return '';
  	    }

  	    str = String(str).toLowerCase();
  	    return str.replace(/(?:^|\s|-)\S/g, function (c) {
  	      return c.toUpperCase();
  	    });
  	  },
  	  classify: function classify(str) {
  	    return utils.titleize(String(str).replace(/[\W_]/g, ' ')).replace(/\s/g, '');
  	  },
  	  capitalize: function capitalize(string) {
  	    return string.charAt(0).toUpperCase() + string.substring(1).toLowerCase();
  	  },
  	  flatten: function flatten(obj) {
  	    var x = {};
  	    (Array.isArray(obj) ? obj : Object.keys(obj)).forEach(function (i) {
  	      x[i] = true;
  	    });
  	    return x;
  	  },
  	  underscored: function underscored(str) {
  	    return str.trim().replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
  	  },
  	  reverse: function reverse(str) {
  	    return str.split("").reverse().join("");
  	  },
  	  toSlug: function toSlug(str) {
  	    return str.toLowerCase().replace(/[^\w ]+/g, '').replace(/ +/g, '-');
  	  },
  	  leftTrim: function leftTrim(str) {
  	    return str.replace(/^\s+/, '');
  	  }
  	};
  	module.exports = utils;

  	/***/ }),
  	/* 2 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var drop_options = {
  	  html: ['<div class="st-block__dropzone">', '<svg role="img" class="st-icon"><use xlink:href="<%= config.defaults.iconUrl %>#<%= _.result(block, "icon_name") %>"/></svg>', '<p><%= i18n.t("general:drop", { block: "<span>" + _.result(block, "title") + "</span>" }) %>', '</p></div>'].join('\n'),
  	  re_render_on_reorder: false
  	};
  	var paste_options = {
  	  html: ['<input type="text" placeholder="<%= i18n.t("general:paste") %>"', ' class="st-block__paste-input st-paste-block">'].join('')
  	};
  	var upload_options = {
  	  html: ['<div class="st-block__upload-container">', '<input type="file" type="st-file-upload">', '<button class="st-upload-btn"><%= i18n.t("general:upload") %></button>', '</div>'].join('\n')
  	};
  	module.exports = {
  	  debug: false,
  	  scribeDebug: false,
  	  skipValidation: false,
  	  version: "0.4.0",
  	  language: "en",
  	  instances: [],
  	  defaults: {
  	    defaultType: false,
  	    spinner: {
  	      className: 'st-spinner',
  	      lines: 9,
  	      length: 8,
  	      width: 3,
  	      radius: 6,
  	      color: '#000',
  	      speed: 1.4,
  	      trail: 57,
  	      shadow: false,
  	      left: '50%',
  	      top: '50%'
  	    },
  	    Block: {
  	      drop_options: drop_options,
  	      paste_options: paste_options,
  	      upload_options: upload_options
  	    },
  	    blockLimit: 0,
  	    blockTypeLimits: {},
  	    required: [],
  	    uploadUrl: '/attachments',
  	    attachmentName: 'attachment[name]',
  	    attachmentFile: 'attachment[file]',
  	    attachmentUid: 'attachment[uid]',
  	    baseImageUrl: '/sir-trevor-uploads/',
  	    iconUrl: '../src/icons/sir-trevor-icons.svg',
  	    errorsContainer: undefined,
  	    convertFromMarkdown: true,
  	    joinListBlocksOnBlockRemove: false,
  	    formatBar: {
  	      commands: [{
  	        name: "Bold",
  	        title: "bold",
  	        iconName: "fmt-bold",
  	        cmd: "bold",
  	        keyCode: 66,
  	        text: "B"
  	      }, {
  	        name: "Italic",
  	        title: "italic",
  	        iconName: "fmt-italic",
  	        cmd: "italic",
  	        keyCode: 73,
  	        text: "i"
  	      }, {
  	        name: "Link",
  	        title: "link",
  	        iconName: "fmt-link",
  	        cmd: "linkPrompt",
  	        keyCode: 75,
  	        text: "link"
  	      }, {
  	        name: "Unlink",
  	        title: "unlink",
  	        iconName: "fmt-unlink",
  	        cmd: "unlink",
  	        text: "link"
  	      }, {
  	        name: "Heading",
  	        title: "heading",
  	        iconName: "fmt-heading",
  	        cmd: "heading",
  	        text: "heading"
  	      }, {
  	        name: "Quote",
  	        title: "quote",
  	        iconName: "fmt-quote",
  	        cmd: "quote",
  	        text: "quote"
  	      }]
  	    },
  	    ajaxOptions: {
  	      headers: {}
  	    },
  	    focusOnInit: true,
  	    selectionMouse: true,
  	    selectionCopy: true,
  	    selectionCut: true,
  	    selectionPaste: true,
  	    selectionLimitToEditor: true
  	  }
  	};

  	/***/ }),
  	/* 3 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0); // disabling undefined warnings until jshint can handle argument destructing


  	var Dom = Object.create(null);

  	Dom.setAttributes = function (el) {
  	  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  	  if (attributes.html) {
  	    el.innerHTML = _.result(attributes, 'html');
  	    delete attributes.html;
  	  }

  	  if (attributes.text) {
  	    el.textContent = attributes.text;
  	    delete attributes.text;
  	  }

  	  Object.keys(attributes).forEach(function (key) {
  	    el.setAttribute(key, attributes[key]);
  	  });
  	  return el;
  	};

  	Dom.createElement = function (tagName) {
  	  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	  var el = document.createElement(tagName);
  	  Dom.setAttributes(el, attributes);
  	  return el;
  	};

  	Dom.insertAfter = function (el, referenceNode) {
  	  referenceNode.parentNode.insertBefore(el, referenceNode.nextSibling);
  	};

  	Dom.remove = function (el) {
  	  if (el && el.parentNode) {
  	    el.parentNode.removeChild(el);
  	  }
  	};

  	Dom.replaceWith = function (el, referenceNode) {
  	  Dom.remove(referenceNode);
  	  el.parentNode.replaceChild(referenceNode, el);
  	};

  	Dom.hide = function (el) {
  	  el.style.display = 'none';
  	};

  	Dom.show = function (el) {
  	  el.style.display = '';
  	};

  	Dom.matches = function (proto) {
  	  var matcher = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector || function (selector) {
  	    var element = this;
  	    var matches = (element.document || element.ownerDocument).querySelectorAll(selector);
  	    var i = 0;

  	    while (matches[i] && matches[i] !== element) {
  	      i++;
  	    }

  	    return matches[i] ? true : false;
  	  };

  	  return function (el, selector) {
  	    return matcher.call(el, selector);
  	  };
  	}(Element.prototype);

  	Dom.getClosest = function (elem, selector) {
  	  for (elem; elem && elem !== document.body; elem = elem.parentNode) {
  	    if (Dom.matches(elem, selector)) {
  	      break;
  	    }
  	  }

  	  return elem;
  	};

  	Dom.wrap = function (toWrap, wrapper) {
  	  wrapper = wrapper || document.createElement('div');

  	  if (toWrap.nextSibling) {
  	    toWrap.parentNode.insertBefore(wrapper, toWrap.nextSibling);
  	  } else {
  	    toWrap.parentNode.appendChild(wrapper);
  	  }

  	  return wrapper.appendChild(toWrap);
  	};

  	Dom.createDocumentFragmentFromString = function (html) {
  	  var frag = document.createDocumentFragment();
  	  var elem = document.createElement('div');
  	  elem.innerHTML = html;

  	  while (elem.childNodes[0]) {
  	    frag.appendChild(elem.childNodes[0]);
  	  }

  	  return frag;
  	};

  	module.exports = Dom;

  	/***/ }),
  	/* 4 */
  	/***/ (function(module, exports, __webpack_require__) {


  	module.exports = Object.assign({}, __webpack_require__(9));

  	/***/ }),
  	/* 5 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Copyright (c) 2014-present, Facebook, Inc.
  	 *
  	 * This source code is licensed under the MIT license found in the
  	 * LICENSE file in the root directory of this source tree.
  	 */

  	(function (global, factory) {
  	   module.exports = factory() ;
  	}(this, function () {var SLICE$0 = Array.prototype.slice;

  	  function createClass(ctor, superClass) {
  	    if (superClass) {
  	      ctor.prototype = Object.create(superClass.prototype);
  	    }
  	    ctor.prototype.constructor = ctor;
  	  }

  	  function Iterable(value) {
  	      return isIterable(value) ? value : Seq(value);
  	    }


  	  createClass(KeyedIterable, Iterable);
  	    function KeyedIterable(value) {
  	      return isKeyed(value) ? value : KeyedSeq(value);
  	    }


  	  createClass(IndexedIterable, Iterable);
  	    function IndexedIterable(value) {
  	      return isIndexed(value) ? value : IndexedSeq(value);
  	    }


  	  createClass(SetIterable, Iterable);
  	    function SetIterable(value) {
  	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
  	    }



  	  function isIterable(maybeIterable) {
  	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
  	  }

  	  function isKeyed(maybeKeyed) {
  	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
  	  }

  	  function isIndexed(maybeIndexed) {
  	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
  	  }

  	  function isAssociative(maybeAssociative) {
  	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  	  }

  	  function isOrdered(maybeOrdered) {
  	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
  	  }

  	  Iterable.isIterable = isIterable;
  	  Iterable.isKeyed = isKeyed;
  	  Iterable.isIndexed = isIndexed;
  	  Iterable.isAssociative = isAssociative;
  	  Iterable.isOrdered = isOrdered;

  	  Iterable.Keyed = KeyedIterable;
  	  Iterable.Indexed = IndexedIterable;
  	  Iterable.Set = SetIterable;


  	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  	  // Used for setting prototype methods that IE8 chokes on.
  	  var DELETE = 'delete';

  	  // Constants describing the size of trie nodes.
  	  var SHIFT = 5; // Resulted in best performance after ______?
  	  var SIZE = 1 << SHIFT;
  	  var MASK = SIZE - 1;

  	  // A consistent shared value representing "not set" which equals nothing other
  	  // than itself, and nothing that could be provided externally.
  	  var NOT_SET = {};

  	  // Boolean references, Rough equivalent of `bool &`.
  	  var CHANGE_LENGTH = { value: false };
  	  var DID_ALTER = { value: false };

  	  function MakeRef(ref) {
  	    ref.value = false;
  	    return ref;
  	  }

  	  function SetRef(ref) {
  	    ref && (ref.value = true);
  	  }

  	  // A function which returns a value representing an "owner" for transient writes
  	  // to tries. The return value will only ever equal itself, and will not equal
  	  // the return of any subsequent call of this function.
  	  function OwnerID() {}

  	  // http://jsperf.com/copy-array-inline
  	  function arrCopy(arr, offset) {
  	    offset = offset || 0;
  	    var len = Math.max(0, arr.length - offset);
  	    var newArr = new Array(len);
  	    for (var ii = 0; ii < len; ii++) {
  	      newArr[ii] = arr[ii + offset];
  	    }
  	    return newArr;
  	  }

  	  function ensureSize(iter) {
  	    if (iter.size === undefined) {
  	      iter.size = iter.__iterate(returnTrue);
  	    }
  	    return iter.size;
  	  }

  	  function wrapIndex(iter, index) {
  	    // This implements "is array index" which the ECMAString spec defines as:
  	    //
  	    //     A String property name P is an array index if and only if
  	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
  	    //     to 2^321.
  	    //
  	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
  	    if (typeof index !== 'number') {
  	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
  	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
  	        return NaN;
  	      }
  	      index = uint32Index;
  	    }
  	    return index < 0 ? ensureSize(iter) + index : index;
  	  }

  	  function returnTrue() {
  	    return true;
  	  }

  	  function wholeSlice(begin, end, size) {
  	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
  	      (end === undefined || (size !== undefined && end >= size));
  	  }

  	  function resolveBegin(begin, size) {
  	    return resolveIndex(begin, size, 0);
  	  }

  	  function resolveEnd(end, size) {
  	    return resolveIndex(end, size, size);
  	  }

  	  function resolveIndex(index, size, defaultIndex) {
  	    return index === undefined ?
  	      defaultIndex :
  	      index < 0 ?
  	        Math.max(0, size + index) :
  	        size === undefined ?
  	          index :
  	          Math.min(size, index);
  	  }

  	  /* global Symbol */

  	  var ITERATE_KEYS = 0;
  	  var ITERATE_VALUES = 1;
  	  var ITERATE_ENTRIES = 2;

  	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


  	  function Iterator(next) {
  	      this.next = next;
  	    }

  	    Iterator.prototype.toString = function() {
  	      return '[Iterator]';
  	    };


  	  Iterator.KEYS = ITERATE_KEYS;
  	  Iterator.VALUES = ITERATE_VALUES;
  	  Iterator.ENTRIES = ITERATE_ENTRIES;

  	  Iterator.prototype.inspect =
  	  Iterator.prototype.toSource = function () { return this.toString(); };
  	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
  	    return this;
  	  };


  	  function iteratorValue(type, k, v, iteratorResult) {
  	    var value = type === 0 ? k : type === 1 ? v : [k, v];
  	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
  	      value: value, done: false
  	    });
  	    return iteratorResult;
  	  }

  	  function iteratorDone() {
  	    return { value: undefined, done: true };
  	  }

  	  function hasIterator(maybeIterable) {
  	    return !!getIteratorFn(maybeIterable);
  	  }

  	  function isIterator(maybeIterator) {
  	    return maybeIterator && typeof maybeIterator.next === 'function';
  	  }

  	  function getIterator(iterable) {
  	    var iteratorFn = getIteratorFn(iterable);
  	    return iteratorFn && iteratorFn.call(iterable);
  	  }

  	  function getIteratorFn(iterable) {
  	    var iteratorFn = iterable && (
  	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
  	      iterable[FAUX_ITERATOR_SYMBOL]
  	    );
  	    if (typeof iteratorFn === 'function') {
  	      return iteratorFn;
  	    }
  	  }

  	  function isArrayLike(value) {
  	    return value && typeof value.length === 'number';
  	  }

  	  createClass(Seq, Iterable);
  	    function Seq(value) {
  	      return value === null || value === undefined ? emptySequence() :
  	        isIterable(value) ? value.toSeq() : seqFromValue(value);
  	    }

  	    Seq.of = function(/*...values*/) {
  	      return Seq(arguments);
  	    };

  	    Seq.prototype.toSeq = function() {
  	      return this;
  	    };

  	    Seq.prototype.toString = function() {
  	      return this.__toString('Seq {', '}');
  	    };

  	    Seq.prototype.cacheResult = function() {
  	      if (!this._cache && this.__iterateUncached) {
  	        this._cache = this.entrySeq().toArray();
  	        this.size = this._cache.length;
  	      }
  	      return this;
  	    };

  	    // abstract __iterateUncached(fn, reverse)

  	    Seq.prototype.__iterate = function(fn, reverse) {
  	      return seqIterate(this, fn, reverse, true);
  	    };

  	    // abstract __iteratorUncached(type, reverse)

  	    Seq.prototype.__iterator = function(type, reverse) {
  	      return seqIterator(this, type, reverse, true);
  	    };



  	  createClass(KeyedSeq, Seq);
  	    function KeyedSeq(value) {
  	      return value === null || value === undefined ?
  	        emptySequence().toKeyedSeq() :
  	        isIterable(value) ?
  	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
  	          keyedSeqFromValue(value);
  	    }

  	    KeyedSeq.prototype.toKeyedSeq = function() {
  	      return this;
  	    };



  	  createClass(IndexedSeq, Seq);
  	    function IndexedSeq(value) {
  	      return value === null || value === undefined ? emptySequence() :
  	        !isIterable(value) ? indexedSeqFromValue(value) :
  	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
  	    }

  	    IndexedSeq.of = function(/*...values*/) {
  	      return IndexedSeq(arguments);
  	    };

  	    IndexedSeq.prototype.toIndexedSeq = function() {
  	      return this;
  	    };

  	    IndexedSeq.prototype.toString = function() {
  	      return this.__toString('Seq [', ']');
  	    };

  	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
  	      return seqIterate(this, fn, reverse, false);
  	    };

  	    IndexedSeq.prototype.__iterator = function(type, reverse) {
  	      return seqIterator(this, type, reverse, false);
  	    };



  	  createClass(SetSeq, Seq);
  	    function SetSeq(value) {
  	      return (
  	        value === null || value === undefined ? emptySequence() :
  	        !isIterable(value) ? indexedSeqFromValue(value) :
  	        isKeyed(value) ? value.entrySeq() : value
  	      ).toSetSeq();
  	    }

  	    SetSeq.of = function(/*...values*/) {
  	      return SetSeq(arguments);
  	    };

  	    SetSeq.prototype.toSetSeq = function() {
  	      return this;
  	    };



  	  Seq.isSeq = isSeq;
  	  Seq.Keyed = KeyedSeq;
  	  Seq.Set = SetSeq;
  	  Seq.Indexed = IndexedSeq;

  	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

  	  Seq.prototype[IS_SEQ_SENTINEL] = true;



  	  createClass(ArraySeq, IndexedSeq);
  	    function ArraySeq(array) {
  	      this._array = array;
  	      this.size = array.length;
  	    }

  	    ArraySeq.prototype.get = function(index, notSetValue) {
  	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
  	    };

  	    ArraySeq.prototype.__iterate = function(fn, reverse) {
  	      var array = this._array;
  	      var maxIndex = array.length - 1;
  	      for (var ii = 0; ii <= maxIndex; ii++) {
  	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
  	          return ii + 1;
  	        }
  	      }
  	      return ii;
  	    };

  	    ArraySeq.prototype.__iterator = function(type, reverse) {
  	      var array = this._array;
  	      var maxIndex = array.length - 1;
  	      var ii = 0;
  	      return new Iterator(function() 
  	        {return ii > maxIndex ?
  	          iteratorDone() :
  	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
  	      );
  	    };



  	  createClass(ObjectSeq, KeyedSeq);
  	    function ObjectSeq(object) {
  	      var keys = Object.keys(object);
  	      this._object = object;
  	      this._keys = keys;
  	      this.size = keys.length;
  	    }

  	    ObjectSeq.prototype.get = function(key, notSetValue) {
  	      if (notSetValue !== undefined && !this.has(key)) {
  	        return notSetValue;
  	      }
  	      return this._object[key];
  	    };

  	    ObjectSeq.prototype.has = function(key) {
  	      return this._object.hasOwnProperty(key);
  	    };

  	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
  	      var object = this._object;
  	      var keys = this._keys;
  	      var maxIndex = keys.length - 1;
  	      for (var ii = 0; ii <= maxIndex; ii++) {
  	        var key = keys[reverse ? maxIndex - ii : ii];
  	        if (fn(object[key], key, this) === false) {
  	          return ii + 1;
  	        }
  	      }
  	      return ii;
  	    };

  	    ObjectSeq.prototype.__iterator = function(type, reverse) {
  	      var object = this._object;
  	      var keys = this._keys;
  	      var maxIndex = keys.length - 1;
  	      var ii = 0;
  	      return new Iterator(function()  {
  	        var key = keys[reverse ? maxIndex - ii : ii];
  	        return ii++ > maxIndex ?
  	          iteratorDone() :
  	          iteratorValue(type, key, object[key]);
  	      });
  	    };

  	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


  	  createClass(IterableSeq, IndexedSeq);
  	    function IterableSeq(iterable) {
  	      this._iterable = iterable;
  	      this.size = iterable.length || iterable.size;
  	    }

  	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
  	      if (reverse) {
  	        return this.cacheResult().__iterate(fn, reverse);
  	      }
  	      var iterable = this._iterable;
  	      var iterator = getIterator(iterable);
  	      var iterations = 0;
  	      if (isIterator(iterator)) {
  	        var step;
  	        while (!(step = iterator.next()).done) {
  	          if (fn(step.value, iterations++, this) === false) {
  	            break;
  	          }
  	        }
  	      }
  	      return iterations;
  	    };

  	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
  	      if (reverse) {
  	        return this.cacheResult().__iterator(type, reverse);
  	      }
  	      var iterable = this._iterable;
  	      var iterator = getIterator(iterable);
  	      if (!isIterator(iterator)) {
  	        return new Iterator(iteratorDone);
  	      }
  	      var iterations = 0;
  	      return new Iterator(function()  {
  	        var step = iterator.next();
  	        return step.done ? step : iteratorValue(type, iterations++, step.value);
  	      });
  	    };



  	  createClass(IteratorSeq, IndexedSeq);
  	    function IteratorSeq(iterator) {
  	      this._iterator = iterator;
  	      this._iteratorCache = [];
  	    }

  	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
  	      if (reverse) {
  	        return this.cacheResult().__iterate(fn, reverse);
  	      }
  	      var iterator = this._iterator;
  	      var cache = this._iteratorCache;
  	      var iterations = 0;
  	      while (iterations < cache.length) {
  	        if (fn(cache[iterations], iterations++, this) === false) {
  	          return iterations;
  	        }
  	      }
  	      var step;
  	      while (!(step = iterator.next()).done) {
  	        var val = step.value;
  	        cache[iterations] = val;
  	        if (fn(val, iterations++, this) === false) {
  	          break;
  	        }
  	      }
  	      return iterations;
  	    };

  	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
  	      if (reverse) {
  	        return this.cacheResult().__iterator(type, reverse);
  	      }
  	      var iterator = this._iterator;
  	      var cache = this._iteratorCache;
  	      var iterations = 0;
  	      return new Iterator(function()  {
  	        if (iterations >= cache.length) {
  	          var step = iterator.next();
  	          if (step.done) {
  	            return step;
  	          }
  	          cache[iterations] = step.value;
  	        }
  	        return iteratorValue(type, iterations, cache[iterations++]);
  	      });
  	    };




  	  // # pragma Helper functions

  	  function isSeq(maybeSeq) {
  	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
  	  }

  	  var EMPTY_SEQ;

  	  function emptySequence() {
  	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  	  }

  	  function keyedSeqFromValue(value) {
  	    var seq =
  	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
  	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
  	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
  	      typeof value === 'object' ? new ObjectSeq(value) :
  	      undefined;
  	    if (!seq) {
  	      throw new TypeError(
  	        'Expected Array or iterable object of [k, v] entries, '+
  	        'or keyed object: ' + value
  	      );
  	    }
  	    return seq;
  	  }

  	  function indexedSeqFromValue(value) {
  	    var seq = maybeIndexedSeqFromValue(value);
  	    if (!seq) {
  	      throw new TypeError(
  	        'Expected Array or iterable object of values: ' + value
  	      );
  	    }
  	    return seq;
  	  }

  	  function seqFromValue(value) {
  	    var seq = maybeIndexedSeqFromValue(value) ||
  	      (typeof value === 'object' && new ObjectSeq(value));
  	    if (!seq) {
  	      throw new TypeError(
  	        'Expected Array or iterable object of values, or keyed object: ' + value
  	      );
  	    }
  	    return seq;
  	  }

  	  function maybeIndexedSeqFromValue(value) {
  	    return (
  	      isArrayLike(value) ? new ArraySeq(value) :
  	      isIterator(value) ? new IteratorSeq(value) :
  	      hasIterator(value) ? new IterableSeq(value) :
  	      undefined
  	    );
  	  }

  	  function seqIterate(seq, fn, reverse, useKeys) {
  	    var cache = seq._cache;
  	    if (cache) {
  	      var maxIndex = cache.length - 1;
  	      for (var ii = 0; ii <= maxIndex; ii++) {
  	        var entry = cache[reverse ? maxIndex - ii : ii];
  	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
  	          return ii + 1;
  	        }
  	      }
  	      return ii;
  	    }
  	    return seq.__iterateUncached(fn, reverse);
  	  }

  	  function seqIterator(seq, type, reverse, useKeys) {
  	    var cache = seq._cache;
  	    if (cache) {
  	      var maxIndex = cache.length - 1;
  	      var ii = 0;
  	      return new Iterator(function()  {
  	        var entry = cache[reverse ? maxIndex - ii : ii];
  	        return ii++ > maxIndex ?
  	          iteratorDone() :
  	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
  	      });
  	    }
  	    return seq.__iteratorUncached(type, reverse);
  	  }

  	  function fromJS(json, converter) {
  	    return converter ?
  	      fromJSWith(converter, json, '', {'': json}) :
  	      fromJSDefault(json);
  	  }

  	  function fromJSWith(converter, json, key, parentJSON) {
  	    if (Array.isArray(json)) {
  	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
  	    }
  	    if (isPlainObj(json)) {
  	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
  	    }
  	    return json;
  	  }

  	  function fromJSDefault(json) {
  	    if (Array.isArray(json)) {
  	      return IndexedSeq(json).map(fromJSDefault).toList();
  	    }
  	    if (isPlainObj(json)) {
  	      return KeyedSeq(json).map(fromJSDefault).toMap();
  	    }
  	    return json;
  	  }

  	  function isPlainObj(value) {
  	    return value && (value.constructor === Object || value.constructor === undefined);
  	  }

  	  /**
  	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
  	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
  	   *
  	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
  	   * value, which is different from the algorithm described by
  	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
  	   *
  	   * This is extended further to allow Objects to describe the values they
  	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
  	   *
  	   * Note: because of this extension, the key equality of Immutable.Map and the
  	   * value equality of Immutable.Set will differ from ES6 Map and Set.
  	   *
  	   * ### Defining custom values
  	   *
  	   * The easiest way to describe the value an object represents is by implementing
  	   * `valueOf`. For example, `Date` represents a value by returning a unix
  	   * timestamp for `valueOf`:
  	   *
  	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
  	   *     var date2 = new Date(1234567890000);
  	   *     date1.valueOf(); // 1234567890000
  	   *     assert( date1 !== date2 );
  	   *     assert( Immutable.is( date1, date2 ) );
  	   *
  	   * Note: overriding `valueOf` may have other implications if you use this object
  	   * where JavaScript expects a primitive, such as implicit string coercion.
  	   *
  	   * For more complex types, especially collections, implementing `valueOf` may
  	   * not be performant. An alternative is to implement `equals` and `hashCode`.
  	   *
  	   * `equals` takes another object, presumably of similar type, and returns true
  	   * if the it is equal. Equality is symmetrical, so the same result should be
  	   * returned if this and the argument are flipped.
  	   *
  	   *     assert( a.equals(b) === b.equals(a) );
  	   *
  	   * `hashCode` returns a 32bit integer number representing the object which will
  	   * be used to determine how to store the value object in a Map or Set. You must
  	   * provide both or neither methods, one must not exist without the other.
  	   *
  	   * Also, an important relationship between these methods must be upheld: if two
  	   * values are equal, they *must* return the same hashCode. If the values are not
  	   * equal, they might have the same hashCode; this is called a hash collision,
  	   * and while undesirable for performance reasons, it is acceptable.
  	   *
  	   *     if (a.equals(b)) {
  	   *       assert( a.hashCode() === b.hashCode() );
  	   *     }
  	   *
  	   * All Immutable collections implement `equals` and `hashCode`.
  	   *
  	   */
  	  function is(valueA, valueB) {
  	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
  	      return true;
  	    }
  	    if (!valueA || !valueB) {
  	      return false;
  	    }
  	    if (typeof valueA.valueOf === 'function' &&
  	        typeof valueB.valueOf === 'function') {
  	      valueA = valueA.valueOf();
  	      valueB = valueB.valueOf();
  	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
  	        return true;
  	      }
  	      if (!valueA || !valueB) {
  	        return false;
  	      }
  	    }
  	    if (typeof valueA.equals === 'function' &&
  	        typeof valueB.equals === 'function' &&
  	        valueA.equals(valueB)) {
  	      return true;
  	    }
  	    return false;
  	  }

  	  function deepEqual(a, b) {
  	    if (a === b) {
  	      return true;
  	    }

  	    if (
  	      !isIterable(b) ||
  	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
  	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
  	      isKeyed(a) !== isKeyed(b) ||
  	      isIndexed(a) !== isIndexed(b) ||
  	      isOrdered(a) !== isOrdered(b)
  	    ) {
  	      return false;
  	    }

  	    if (a.size === 0 && b.size === 0) {
  	      return true;
  	    }

  	    var notAssociative = !isAssociative(a);

  	    if (isOrdered(a)) {
  	      var entries = a.entries();
  	      return b.every(function(v, k)  {
  	        var entry = entries.next().value;
  	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
  	      }) && entries.next().done;
  	    }

  	    var flipped = false;

  	    if (a.size === undefined) {
  	      if (b.size === undefined) {
  	        if (typeof a.cacheResult === 'function') {
  	          a.cacheResult();
  	        }
  	      } else {
  	        flipped = true;
  	        var _ = a;
  	        a = b;
  	        b = _;
  	      }
  	    }

  	    var allEqual = true;
  	    var bSize = b.__iterate(function(v, k)  {
  	      if (notAssociative ? !a.has(v) :
  	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
  	        allEqual = false;
  	        return false;
  	      }
  	    });

  	    return allEqual && a.size === bSize;
  	  }

  	  createClass(Repeat, IndexedSeq);

  	    function Repeat(value, times) {
  	      if (!(this instanceof Repeat)) {
  	        return new Repeat(value, times);
  	      }
  	      this._value = value;
  	      this.size = times === undefined ? Infinity : Math.max(0, times);
  	      if (this.size === 0) {
  	        if (EMPTY_REPEAT) {
  	          return EMPTY_REPEAT;
  	        }
  	        EMPTY_REPEAT = this;
  	      }
  	    }

  	    Repeat.prototype.toString = function() {
  	      if (this.size === 0) {
  	        return 'Repeat []';
  	      }
  	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
  	    };

  	    Repeat.prototype.get = function(index, notSetValue) {
  	      return this.has(index) ? this._value : notSetValue;
  	    };

  	    Repeat.prototype.includes = function(searchValue) {
  	      return is(this._value, searchValue);
  	    };

  	    Repeat.prototype.slice = function(begin, end) {
  	      var size = this.size;
  	      return wholeSlice(begin, end, size) ? this :
  	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
  	    };

  	    Repeat.prototype.reverse = function() {
  	      return this;
  	    };

  	    Repeat.prototype.indexOf = function(searchValue) {
  	      if (is(this._value, searchValue)) {
  	        return 0;
  	      }
  	      return -1;
  	    };

  	    Repeat.prototype.lastIndexOf = function(searchValue) {
  	      if (is(this._value, searchValue)) {
  	        return this.size;
  	      }
  	      return -1;
  	    };

  	    Repeat.prototype.__iterate = function(fn, reverse) {
  	      for (var ii = 0; ii < this.size; ii++) {
  	        if (fn(this._value, ii, this) === false) {
  	          return ii + 1;
  	        }
  	      }
  	      return ii;
  	    };

  	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
  	      var ii = 0;
  	      return new Iterator(function() 
  	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
  	      );
  	    };

  	    Repeat.prototype.equals = function(other) {
  	      return other instanceof Repeat ?
  	        is(this._value, other._value) :
  	        deepEqual(other);
  	    };


  	  var EMPTY_REPEAT;

  	  function invariant(condition, error) {
  	    if (!condition) throw new Error(error);
  	  }

  	  createClass(Range, IndexedSeq);

  	    function Range(start, end, step) {
  	      if (!(this instanceof Range)) {
  	        return new Range(start, end, step);
  	      }
  	      invariant(step !== 0, 'Cannot step a Range by 0');
  	      start = start || 0;
  	      if (end === undefined) {
  	        end = Infinity;
  	      }
  	      step = step === undefined ? 1 : Math.abs(step);
  	      if (end < start) {
  	        step = -step;
  	      }
  	      this._start = start;
  	      this._end = end;
  	      this._step = step;
  	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
  	      if (this.size === 0) {
  	        if (EMPTY_RANGE) {
  	          return EMPTY_RANGE;
  	        }
  	        EMPTY_RANGE = this;
  	      }
  	    }

  	    Range.prototype.toString = function() {
  	      if (this.size === 0) {
  	        return 'Range []';
  	      }
  	      return 'Range [ ' +
  	        this._start + '...' + this._end +
  	        (this._step !== 1 ? ' by ' + this._step : '') +
  	      ' ]';
  	    };

  	    Range.prototype.get = function(index, notSetValue) {
  	      return this.has(index) ?
  	        this._start + wrapIndex(this, index) * this._step :
  	        notSetValue;
  	    };

  	    Range.prototype.includes = function(searchValue) {
  	      var possibleIndex = (searchValue - this._start) / this._step;
  	      return possibleIndex >= 0 &&
  	        possibleIndex < this.size &&
  	        possibleIndex === Math.floor(possibleIndex);
  	    };

  	    Range.prototype.slice = function(begin, end) {
  	      if (wholeSlice(begin, end, this.size)) {
  	        return this;
  	      }
  	      begin = resolveBegin(begin, this.size);
  	      end = resolveEnd(end, this.size);
  	      if (end <= begin) {
  	        return new Range(0, 0);
  	      }
  	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
  	    };

  	    Range.prototype.indexOf = function(searchValue) {
  	      var offsetValue = searchValue - this._start;
  	      if (offsetValue % this._step === 0) {
  	        var index = offsetValue / this._step;
  	        if (index >= 0 && index < this.size) {
  	          return index
  	        }
  	      }
  	      return -1;
  	    };

  	    Range.prototype.lastIndexOf = function(searchValue) {
  	      return this.indexOf(searchValue);
  	    };

  	    Range.prototype.__iterate = function(fn, reverse) {
  	      var maxIndex = this.size - 1;
  	      var step = this._step;
  	      var value = reverse ? this._start + maxIndex * step : this._start;
  	      for (var ii = 0; ii <= maxIndex; ii++) {
  	        if (fn(value, ii, this) === false) {
  	          return ii + 1;
  	        }
  	        value += reverse ? -step : step;
  	      }
  	      return ii;
  	    };

  	    Range.prototype.__iterator = function(type, reverse) {
  	      var maxIndex = this.size - 1;
  	      var step = this._step;
  	      var value = reverse ? this._start + maxIndex * step : this._start;
  	      var ii = 0;
  	      return new Iterator(function()  {
  	        var v = value;
  	        value += reverse ? -step : step;
  	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
  	      });
  	    };

  	    Range.prototype.equals = function(other) {
  	      return other instanceof Range ?
  	        this._start === other._start &&
  	        this._end === other._end &&
  	        this._step === other._step :
  	        deepEqual(this, other);
  	    };


  	  var EMPTY_RANGE;

  	  createClass(Collection, Iterable);
  	    function Collection() {
  	      throw TypeError('Abstract');
  	    }


  	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

  	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

  	  createClass(SetCollection, Collection);function SetCollection() {}


  	  Collection.Keyed = KeyedCollection;
  	  Collection.Indexed = IndexedCollection;
  	  Collection.Set = SetCollection;

  	  var imul =
  	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
  	    Math.imul :
  	    function imul(a, b) {
  	      a = a | 0; // int
  	      b = b | 0; // int
  	      var c = a & 0xffff;
  	      var d = b & 0xffff;
  	      // Shift by 0 fixes the sign on the high part.
  	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
  	    };

  	  // v8 has an optimization for storing 31-bit signed numbers.
  	  // Values which have either 00 or 11 as the high order bits qualify.
  	  // This function drops the highest order bit in a signed number, maintaining
  	  // the sign bit.
  	  function smi(i32) {
  	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
  	  }

  	  function hash(o) {
  	    if (o === false || o === null || o === undefined) {
  	      return 0;
  	    }
  	    if (typeof o.valueOf === 'function') {
  	      o = o.valueOf();
  	      if (o === false || o === null || o === undefined) {
  	        return 0;
  	      }
  	    }
  	    if (o === true) {
  	      return 1;
  	    }
  	    var type = typeof o;
  	    if (type === 'number') {
  	      if (o !== o || o === Infinity) {
  	        return 0;
  	      }
  	      var h = o | 0;
  	      if (h !== o) {
  	        h ^= o * 0xFFFFFFFF;
  	      }
  	      while (o > 0xFFFFFFFF) {
  	        o /= 0xFFFFFFFF;
  	        h ^= o;
  	      }
  	      return smi(h);
  	    }
  	    if (type === 'string') {
  	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
  	    }
  	    if (typeof o.hashCode === 'function') {
  	      return o.hashCode();
  	    }
  	    if (type === 'object') {
  	      return hashJSObj(o);
  	    }
  	    if (typeof o.toString === 'function') {
  	      return hashString(o.toString());
  	    }
  	    throw new Error('Value type ' + type + ' cannot be hashed.');
  	  }

  	  function cachedHashString(string) {
  	    var hash = stringHashCache[string];
  	    if (hash === undefined) {
  	      hash = hashString(string);
  	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
  	        STRING_HASH_CACHE_SIZE = 0;
  	        stringHashCache = {};
  	      }
  	      STRING_HASH_CACHE_SIZE++;
  	      stringHashCache[string] = hash;
  	    }
  	    return hash;
  	  }

  	  // http://jsperf.com/hashing-strings
  	  function hashString(string) {
  	    // This is the hash from JVM
  	    // The hash code for a string is computed as
  	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
  	    // where s[i] is the ith character of the string and n is the length of
  	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
  	    // (exclusive) by dropping high bits.
  	    var hash = 0;
  	    for (var ii = 0; ii < string.length; ii++) {
  	      hash = 31 * hash + string.charCodeAt(ii) | 0;
  	    }
  	    return smi(hash);
  	  }

  	  function hashJSObj(obj) {
  	    var hash;
  	    if (usingWeakMap) {
  	      hash = weakMap.get(obj);
  	      if (hash !== undefined) {
  	        return hash;
  	      }
  	    }

  	    hash = obj[UID_HASH_KEY];
  	    if (hash !== undefined) {
  	      return hash;
  	    }

  	    if (!canDefineProperty) {
  	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
  	      if (hash !== undefined) {
  	        return hash;
  	      }

  	      hash = getIENodeHash(obj);
  	      if (hash !== undefined) {
  	        return hash;
  	      }
  	    }

  	    hash = ++objHashUID;
  	    if (objHashUID & 0x40000000) {
  	      objHashUID = 0;
  	    }

  	    if (usingWeakMap) {
  	      weakMap.set(obj, hash);
  	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
  	      throw new Error('Non-extensible objects are not allowed as keys.');
  	    } else if (canDefineProperty) {
  	      Object.defineProperty(obj, UID_HASH_KEY, {
  	        'enumerable': false,
  	        'configurable': false,
  	        'writable': false,
  	        'value': hash
  	      });
  	    } else if (obj.propertyIsEnumerable !== undefined &&
  	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
  	      // Since we can't define a non-enumerable property on the object
  	      // we'll hijack one of the less-used non-enumerable properties to
  	      // save our hash on it. Since this is a function it will not show up in
  	      // `JSON.stringify` which is what we want.
  	      obj.propertyIsEnumerable = function() {
  	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
  	      };
  	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
  	    } else if (obj.nodeType !== undefined) {
  	      // At this point we couldn't get the IE `uniqueID` to use as a hash
  	      // and we couldn't use a non-enumerable property to exploit the
  	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
  	      // itself.
  	      obj[UID_HASH_KEY] = hash;
  	    } else {
  	      throw new Error('Unable to set a non-enumerable property on object.');
  	    }

  	    return hash;
  	  }

  	  // Get references to ES5 object methods.
  	  var isExtensible = Object.isExtensible;

  	  // True if Object.defineProperty works as expected. IE8 fails this test.
  	  var canDefineProperty = (function() {
  	    try {
  	      Object.defineProperty({}, '@', {});
  	      return true;
  	    } catch (e) {
  	      return false;
  	    }
  	  }());

  	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  	  // and avoid memory leaks from the IE cloneNode bug.
  	  function getIENodeHash(node) {
  	    if (node && node.nodeType > 0) {
  	      switch (node.nodeType) {
  	        case 1: // Element
  	          return node.uniqueID;
  	        case 9: // Document
  	          return node.documentElement && node.documentElement.uniqueID;
  	      }
  	    }
  	  }

  	  // If possible, use a WeakMap.
  	  var usingWeakMap = typeof WeakMap === 'function';
  	  var weakMap;
  	  if (usingWeakMap) {
  	    weakMap = new WeakMap();
  	  }

  	  var objHashUID = 0;

  	  var UID_HASH_KEY = '__immutablehash__';
  	  if (typeof Symbol === 'function') {
  	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  	  }

  	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  	  var STRING_HASH_CACHE_MAX_SIZE = 255;
  	  var STRING_HASH_CACHE_SIZE = 0;
  	  var stringHashCache = {};

  	  function assertNotInfinite(size) {
  	    invariant(
  	      size !== Infinity,
  	      'Cannot perform this action with an infinite size.'
  	    );
  	  }

  	  createClass(Map, KeyedCollection);

  	    // @pragma Construction

  	    function Map(value) {
  	      return value === null || value === undefined ? emptyMap() :
  	        isMap(value) && !isOrdered(value) ? value :
  	        emptyMap().withMutations(function(map ) {
  	          var iter = KeyedIterable(value);
  	          assertNotInfinite(iter.size);
  	          iter.forEach(function(v, k)  {return map.set(k, v)});
  	        });
  	    }

  	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
  	      return emptyMap().withMutations(function(map ) {
  	        for (var i = 0; i < keyValues.length; i += 2) {
  	          if (i + 1 >= keyValues.length) {
  	            throw new Error('Missing value for key: ' + keyValues[i]);
  	          }
  	          map.set(keyValues[i], keyValues[i + 1]);
  	        }
  	      });
  	    };

  	    Map.prototype.toString = function() {
  	      return this.__toString('Map {', '}');
  	    };

  	    // @pragma Access

  	    Map.prototype.get = function(k, notSetValue) {
  	      return this._root ?
  	        this._root.get(0, undefined, k, notSetValue) :
  	        notSetValue;
  	    };

  	    // @pragma Modification

  	    Map.prototype.set = function(k, v) {
  	      return updateMap(this, k, v);
  	    };

  	    Map.prototype.setIn = function(keyPath, v) {
  	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
  	    };

  	    Map.prototype.remove = function(k) {
  	      return updateMap(this, k, NOT_SET);
  	    };

  	    Map.prototype.deleteIn = function(keyPath) {
  	      return this.updateIn(keyPath, function()  {return NOT_SET});
  	    };

  	    Map.prototype.update = function(k, notSetValue, updater) {
  	      return arguments.length === 1 ?
  	        k(this) :
  	        this.updateIn([k], notSetValue, updater);
  	    };

  	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
  	      if (!updater) {
  	        updater = notSetValue;
  	        notSetValue = undefined;
  	      }
  	      var updatedValue = updateInDeepMap(
  	        this,
  	        forceIterator(keyPath),
  	        notSetValue,
  	        updater
  	      );
  	      return updatedValue === NOT_SET ? undefined : updatedValue;
  	    };

  	    Map.prototype.clear = function() {
  	      if (this.size === 0) {
  	        return this;
  	      }
  	      if (this.__ownerID) {
  	        this.size = 0;
  	        this._root = null;
  	        this.__hash = undefined;
  	        this.__altered = true;
  	        return this;
  	      }
  	      return emptyMap();
  	    };

  	    // @pragma Composition

  	    Map.prototype.merge = function(/*...iters*/) {
  	      return mergeIntoMapWith(this, undefined, arguments);
  	    };

  	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
  	      return mergeIntoMapWith(this, merger, iters);
  	    };

  	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
  	      return this.updateIn(
  	        keyPath,
  	        emptyMap(),
  	        function(m ) {return typeof m.merge === 'function' ?
  	          m.merge.apply(m, iters) :
  	          iters[iters.length - 1]}
  	      );
  	    };

  	    Map.prototype.mergeDeep = function(/*...iters*/) {
  	      return mergeIntoMapWith(this, deepMerger, arguments);
  	    };

  	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
  	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
  	    };

  	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
  	      return this.updateIn(
  	        keyPath,
  	        emptyMap(),
  	        function(m ) {return typeof m.mergeDeep === 'function' ?
  	          m.mergeDeep.apply(m, iters) :
  	          iters[iters.length - 1]}
  	      );
  	    };

  	    Map.prototype.sort = function(comparator) {
  	      // Late binding
  	      return OrderedMap(sortFactory(this, comparator));
  	    };

  	    Map.prototype.sortBy = function(mapper, comparator) {
  	      // Late binding
  	      return OrderedMap(sortFactory(this, comparator, mapper));
  	    };

  	    // @pragma Mutability

  	    Map.prototype.withMutations = function(fn) {
  	      var mutable = this.asMutable();
  	      fn(mutable);
  	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
  	    };

  	    Map.prototype.asMutable = function() {
  	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
  	    };

  	    Map.prototype.asImmutable = function() {
  	      return this.__ensureOwner();
  	    };

  	    Map.prototype.wasAltered = function() {
  	      return this.__altered;
  	    };

  	    Map.prototype.__iterator = function(type, reverse) {
  	      return new MapIterator(this, type, reverse);
  	    };

  	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
  	      var iterations = 0;
  	      this._root && this._root.iterate(function(entry ) {
  	        iterations++;
  	        return fn(entry[1], entry[0], this$0);
  	      }, reverse);
  	      return iterations;
  	    };

  	    Map.prototype.__ensureOwner = function(ownerID) {
  	      if (ownerID === this.__ownerID) {
  	        return this;
  	      }
  	      if (!ownerID) {
  	        this.__ownerID = ownerID;
  	        this.__altered = false;
  	        return this;
  	      }
  	      return makeMap(this.size, this._root, ownerID, this.__hash);
  	    };


  	  function isMap(maybeMap) {
  	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
  	  }

  	  Map.isMap = isMap;

  	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

  	  var MapPrototype = Map.prototype;
  	  MapPrototype[IS_MAP_SENTINEL] = true;
  	  MapPrototype[DELETE] = MapPrototype.remove;
  	  MapPrototype.removeIn = MapPrototype.deleteIn;


  	  // #pragma Trie Nodes



  	    function ArrayMapNode(ownerID, entries) {
  	      this.ownerID = ownerID;
  	      this.entries = entries;
  	    }

  	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
  	      var entries = this.entries;
  	      for (var ii = 0, len = entries.length; ii < len; ii++) {
  	        if (is(key, entries[ii][0])) {
  	          return entries[ii][1];
  	        }
  	      }
  	      return notSetValue;
  	    };

  	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  	      var removed = value === NOT_SET;

  	      var entries = this.entries;
  	      var idx = 0;
  	      for (var len = entries.length; idx < len; idx++) {
  	        if (is(key, entries[idx][0])) {
  	          break;
  	        }
  	      }
  	      var exists = idx < len;

  	      if (exists ? entries[idx][1] === value : removed) {
  	        return this;
  	      }

  	      SetRef(didAlter);
  	      (removed || !exists) && SetRef(didChangeSize);

  	      if (removed && entries.length === 1) {
  	        return; // undefined
  	      }

  	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
  	        return createNodes(ownerID, entries, key, value);
  	      }

  	      var isEditable = ownerID && ownerID === this.ownerID;
  	      var newEntries = isEditable ? entries : arrCopy(entries);

  	      if (exists) {
  	        if (removed) {
  	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
  	        } else {
  	          newEntries[idx] = [key, value];
  	        }
  	      } else {
  	        newEntries.push([key, value]);
  	      }

  	      if (isEditable) {
  	        this.entries = newEntries;
  	        return this;
  	      }

  	      return new ArrayMapNode(ownerID, newEntries);
  	    };




  	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
  	      this.ownerID = ownerID;
  	      this.bitmap = bitmap;
  	      this.nodes = nodes;
  	    }

  	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
  	      if (keyHash === undefined) {
  	        keyHash = hash(key);
  	      }
  	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
  	      var bitmap = this.bitmap;
  	      return (bitmap & bit) === 0 ? notSetValue :
  	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
  	    };

  	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  	      if (keyHash === undefined) {
  	        keyHash = hash(key);
  	      }
  	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  	      var bit = 1 << keyHashFrag;
  	      var bitmap = this.bitmap;
  	      var exists = (bitmap & bit) !== 0;

  	      if (!exists && value === NOT_SET) {
  	        return this;
  	      }

  	      var idx = popCount(bitmap & (bit - 1));
  	      var nodes = this.nodes;
  	      var node = exists ? nodes[idx] : undefined;
  	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

  	      if (newNode === node) {
  	        return this;
  	      }

  	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
  	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
  	      }

  	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
  	        return nodes[idx ^ 1];
  	      }

  	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
  	        return newNode;
  	      }

  	      var isEditable = ownerID && ownerID === this.ownerID;
  	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
  	      var newNodes = exists ? newNode ?
  	        setIn(nodes, idx, newNode, isEditable) :
  	        spliceOut(nodes, idx, isEditable) :
  	        spliceIn(nodes, idx, newNode, isEditable);

  	      if (isEditable) {
  	        this.bitmap = newBitmap;
  	        this.nodes = newNodes;
  	        return this;
  	      }

  	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
  	    };




  	    function HashArrayMapNode(ownerID, count, nodes) {
  	      this.ownerID = ownerID;
  	      this.count = count;
  	      this.nodes = nodes;
  	    }

  	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
  	      if (keyHash === undefined) {
  	        keyHash = hash(key);
  	      }
  	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  	      var node = this.nodes[idx];
  	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
  	    };

  	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  	      if (keyHash === undefined) {
  	        keyHash = hash(key);
  	      }
  	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  	      var removed = value === NOT_SET;
  	      var nodes = this.nodes;
  	      var node = nodes[idx];

  	      if (removed && !node) {
  	        return this;
  	      }

  	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
  	      if (newNode === node) {
  	        return this;
  	      }

  	      var newCount = this.count;
  	      if (!node) {
  	        newCount++;
  	      } else if (!newNode) {
  	        newCount--;
  	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
  	          return packNodes(ownerID, nodes, newCount, idx);
  	        }
  	      }

  	      var isEditable = ownerID && ownerID === this.ownerID;
  	      var newNodes = setIn(nodes, idx, newNode, isEditable);

  	      if (isEditable) {
  	        this.count = newCount;
  	        this.nodes = newNodes;
  	        return this;
  	      }

  	      return new HashArrayMapNode(ownerID, newCount, newNodes);
  	    };




  	    function HashCollisionNode(ownerID, keyHash, entries) {
  	      this.ownerID = ownerID;
  	      this.keyHash = keyHash;
  	      this.entries = entries;
  	    }

  	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
  	      var entries = this.entries;
  	      for (var ii = 0, len = entries.length; ii < len; ii++) {
  	        if (is(key, entries[ii][0])) {
  	          return entries[ii][1];
  	        }
  	      }
  	      return notSetValue;
  	    };

  	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  	      if (keyHash === undefined) {
  	        keyHash = hash(key);
  	      }

  	      var removed = value === NOT_SET;

  	      if (keyHash !== this.keyHash) {
  	        if (removed) {
  	          return this;
  	        }
  	        SetRef(didAlter);
  	        SetRef(didChangeSize);
  	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
  	      }

  	      var entries = this.entries;
  	      var idx = 0;
  	      for (var len = entries.length; idx < len; idx++) {
  	        if (is(key, entries[idx][0])) {
  	          break;
  	        }
  	      }
  	      var exists = idx < len;

  	      if (exists ? entries[idx][1] === value : removed) {
  	        return this;
  	      }

  	      SetRef(didAlter);
  	      (removed || !exists) && SetRef(didChangeSize);

  	      if (removed && len === 2) {
  	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
  	      }

  	      var isEditable = ownerID && ownerID === this.ownerID;
  	      var newEntries = isEditable ? entries : arrCopy(entries);

  	      if (exists) {
  	        if (removed) {
  	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
  	        } else {
  	          newEntries[idx] = [key, value];
  	        }
  	      } else {
  	        newEntries.push([key, value]);
  	      }

  	      if (isEditable) {
  	        this.entries = newEntries;
  	        return this;
  	      }

  	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
  	    };




  	    function ValueNode(ownerID, keyHash, entry) {
  	      this.ownerID = ownerID;
  	      this.keyHash = keyHash;
  	      this.entry = entry;
  	    }

  	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
  	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
  	    };

  	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  	      var removed = value === NOT_SET;
  	      var keyMatch = is(key, this.entry[0]);
  	      if (keyMatch ? value === this.entry[1] : removed) {
  	        return this;
  	      }

  	      SetRef(didAlter);

  	      if (removed) {
  	        SetRef(didChangeSize);
  	        return; // undefined
  	      }

  	      if (keyMatch) {
  	        if (ownerID && ownerID === this.ownerID) {
  	          this.entry[1] = value;
  	          return this;
  	        }
  	        return new ValueNode(ownerID, this.keyHash, [key, value]);
  	      }

  	      SetRef(didChangeSize);
  	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
  	    };



  	  // #pragma Iterators

  	  ArrayMapNode.prototype.iterate =
  	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
  	    var entries = this.entries;
  	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
  	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
  	        return false;
  	      }
  	    }
  	  };

  	  BitmapIndexedNode.prototype.iterate =
  	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
  	    var nodes = this.nodes;
  	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
  	      var node = nodes[reverse ? maxIndex - ii : ii];
  	      if (node && node.iterate(fn, reverse) === false) {
  	        return false;
  	      }
  	    }
  	  };

  	  ValueNode.prototype.iterate = function (fn, reverse) {
  	    return fn(this.entry);
  	  };

  	  createClass(MapIterator, Iterator);

  	    function MapIterator(map, type, reverse) {
  	      this._type = type;
  	      this._reverse = reverse;
  	      this._stack = map._root && mapIteratorFrame(map._root);
  	    }

  	    MapIterator.prototype.next = function() {
  	      var type = this._type;
  	      var stack = this._stack;
  	      while (stack) {
  	        var node = stack.node;
  	        var index = stack.index++;
  	        var maxIndex;
  	        if (node.entry) {
  	          if (index === 0) {
  	            return mapIteratorValue(type, node.entry);
  	          }
  	        } else if (node.entries) {
  	          maxIndex = node.entries.length - 1;
  	          if (index <= maxIndex) {
  	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
  	          }
  	        } else {
  	          maxIndex = node.nodes.length - 1;
  	          if (index <= maxIndex) {
  	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
  	            if (subNode) {
  	              if (subNode.entry) {
  	                return mapIteratorValue(type, subNode.entry);
  	              }
  	              stack = this._stack = mapIteratorFrame(subNode, stack);
  	            }
  	            continue;
  	          }
  	        }
  	        stack = this._stack = this._stack.__prev;
  	      }
  	      return iteratorDone();
  	    };


  	  function mapIteratorValue(type, entry) {
  	    return iteratorValue(type, entry[0], entry[1]);
  	  }

  	  function mapIteratorFrame(node, prev) {
  	    return {
  	      node: node,
  	      index: 0,
  	      __prev: prev
  	    };
  	  }

  	  function makeMap(size, root, ownerID, hash) {
  	    var map = Object.create(MapPrototype);
  	    map.size = size;
  	    map._root = root;
  	    map.__ownerID = ownerID;
  	    map.__hash = hash;
  	    map.__altered = false;
  	    return map;
  	  }

  	  var EMPTY_MAP;
  	  function emptyMap() {
  	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  	  }

  	  function updateMap(map, k, v) {
  	    var newRoot;
  	    var newSize;
  	    if (!map._root) {
  	      if (v === NOT_SET) {
  	        return map;
  	      }
  	      newSize = 1;
  	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
  	    } else {
  	      var didChangeSize = MakeRef(CHANGE_LENGTH);
  	      var didAlter = MakeRef(DID_ALTER);
  	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
  	      if (!didAlter.value) {
  	        return map;
  	      }
  	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  	    }
  	    if (map.__ownerID) {
  	      map.size = newSize;
  	      map._root = newRoot;
  	      map.__hash = undefined;
  	      map.__altered = true;
  	      return map;
  	    }
  	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  	  }

  	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  	    if (!node) {
  	      if (value === NOT_SET) {
  	        return node;
  	      }
  	      SetRef(didAlter);
  	      SetRef(didChangeSize);
  	      return new ValueNode(ownerID, keyHash, [key, value]);
  	    }
  	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
  	  }

  	  function isLeafNode(node) {
  	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
  	  }

  	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  	    if (node.keyHash === keyHash) {
  	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  	    }

  	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

  	    var newNode;
  	    var nodes = idx1 === idx2 ?
  	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
  	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

  	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
  	  }

  	  function createNodes(ownerID, entries, key, value) {
  	    if (!ownerID) {
  	      ownerID = new OwnerID();
  	    }
  	    var node = new ValueNode(ownerID, hash(key), [key, value]);
  	    for (var ii = 0; ii < entries.length; ii++) {
  	      var entry = entries[ii];
  	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
  	    }
  	    return node;
  	  }

  	  function packNodes(ownerID, nodes, count, excluding) {
  	    var bitmap = 0;
  	    var packedII = 0;
  	    var packedNodes = new Array(count);
  	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
  	      var node = nodes[ii];
  	      if (node !== undefined && ii !== excluding) {
  	        bitmap |= bit;
  	        packedNodes[packedII++] = node;
  	      }
  	    }
  	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  	  }

  	  function expandNodes(ownerID, nodes, bitmap, including, node) {
  	    var count = 0;
  	    var expandedNodes = new Array(SIZE);
  	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
  	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
  	    }
  	    expandedNodes[including] = node;
  	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  	  }

  	  function mergeIntoMapWith(map, merger, iterables) {
  	    var iters = [];
  	    for (var ii = 0; ii < iterables.length; ii++) {
  	      var value = iterables[ii];
  	      var iter = KeyedIterable(value);
  	      if (!isIterable(value)) {
  	        iter = iter.map(function(v ) {return fromJS(v)});
  	      }
  	      iters.push(iter);
  	    }
  	    return mergeIntoCollectionWith(map, merger, iters);
  	  }

  	  function deepMerger(existing, value, key) {
  	    return existing && existing.mergeDeep && isIterable(value) ?
  	      existing.mergeDeep(value) :
  	      is(existing, value) ? existing : value;
  	  }

  	  function deepMergerWith(merger) {
  	    return function(existing, value, key)  {
  	      if (existing && existing.mergeDeepWith && isIterable(value)) {
  	        return existing.mergeDeepWith(merger, value);
  	      }
  	      var nextValue = merger(existing, value, key);
  	      return is(existing, nextValue) ? existing : nextValue;
  	    };
  	  }

  	  function mergeIntoCollectionWith(collection, merger, iters) {
  	    iters = iters.filter(function(x ) {return x.size !== 0});
  	    if (iters.length === 0) {
  	      return collection;
  	    }
  	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
  	      return collection.constructor(iters[0]);
  	    }
  	    return collection.withMutations(function(collection ) {
  	      var mergeIntoMap = merger ?
  	        function(value, key)  {
  	          collection.update(key, NOT_SET, function(existing )
  	            {return existing === NOT_SET ? value : merger(existing, value, key)}
  	          );
  	        } :
  	        function(value, key)  {
  	          collection.set(key, value);
  	        };
  	      for (var ii = 0; ii < iters.length; ii++) {
  	        iters[ii].forEach(mergeIntoMap);
  	      }
  	    });
  	  }

  	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
  	    var isNotSet = existing === NOT_SET;
  	    var step = keyPathIter.next();
  	    if (step.done) {
  	      var existingValue = isNotSet ? notSetValue : existing;
  	      var newValue = updater(existingValue);
  	      return newValue === existingValue ? existing : newValue;
  	    }
  	    invariant(
  	      isNotSet || (existing && existing.set),
  	      'invalid keyPath'
  	    );
  	    var key = step.value;
  	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
  	    var nextUpdated = updateInDeepMap(
  	      nextExisting,
  	      keyPathIter,
  	      notSetValue,
  	      updater
  	    );
  	    return nextUpdated === nextExisting ? existing :
  	      nextUpdated === NOT_SET ? existing.remove(key) :
  	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
  	  }

  	  function popCount(x) {
  	    x = x - ((x >> 1) & 0x55555555);
  	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
  	    x = (x + (x >> 4)) & 0x0f0f0f0f;
  	    x = x + (x >> 8);
  	    x = x + (x >> 16);
  	    return x & 0x7f;
  	  }

  	  function setIn(array, idx, val, canEdit) {
  	    var newArray = canEdit ? array : arrCopy(array);
  	    newArray[idx] = val;
  	    return newArray;
  	  }

  	  function spliceIn(array, idx, val, canEdit) {
  	    var newLen = array.length + 1;
  	    if (canEdit && idx + 1 === newLen) {
  	      array[idx] = val;
  	      return array;
  	    }
  	    var newArray = new Array(newLen);
  	    var after = 0;
  	    for (var ii = 0; ii < newLen; ii++) {
  	      if (ii === idx) {
  	        newArray[ii] = val;
  	        after = -1;
  	      } else {
  	        newArray[ii] = array[ii + after];
  	      }
  	    }
  	    return newArray;
  	  }

  	  function spliceOut(array, idx, canEdit) {
  	    var newLen = array.length - 1;
  	    if (canEdit && idx === newLen) {
  	      array.pop();
  	      return array;
  	    }
  	    var newArray = new Array(newLen);
  	    var after = 0;
  	    for (var ii = 0; ii < newLen; ii++) {
  	      if (ii === idx) {
  	        after = 1;
  	      }
  	      newArray[ii] = array[ii + after];
  	    }
  	    return newArray;
  	  }

  	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

  	  createClass(List, IndexedCollection);

  	    // @pragma Construction

  	    function List(value) {
  	      var empty = emptyList();
  	      if (value === null || value === undefined) {
  	        return empty;
  	      }
  	      if (isList(value)) {
  	        return value;
  	      }
  	      var iter = IndexedIterable(value);
  	      var size = iter.size;
  	      if (size === 0) {
  	        return empty;
  	      }
  	      assertNotInfinite(size);
  	      if (size > 0 && size < SIZE) {
  	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
  	      }
  	      return empty.withMutations(function(list ) {
  	        list.setSize(size);
  	        iter.forEach(function(v, i)  {return list.set(i, v)});
  	      });
  	    }

  	    List.of = function(/*...values*/) {
  	      return this(arguments);
  	    };

  	    List.prototype.toString = function() {
  	      return this.__toString('List [', ']');
  	    };

  	    // @pragma Access

  	    List.prototype.get = function(index, notSetValue) {
  	      index = wrapIndex(this, index);
  	      if (index >= 0 && index < this.size) {
  	        index += this._origin;
  	        var node = listNodeFor(this, index);
  	        return node && node.array[index & MASK];
  	      }
  	      return notSetValue;
  	    };

  	    // @pragma Modification

  	    List.prototype.set = function(index, value) {
  	      return updateList(this, index, value);
  	    };

  	    List.prototype.remove = function(index) {
  	      return !this.has(index) ? this :
  	        index === 0 ? this.shift() :
  	        index === this.size - 1 ? this.pop() :
  	        this.splice(index, 1);
  	    };

  	    List.prototype.insert = function(index, value) {
  	      return this.splice(index, 0, value);
  	    };

  	    List.prototype.clear = function() {
  	      if (this.size === 0) {
  	        return this;
  	      }
  	      if (this.__ownerID) {
  	        this.size = this._origin = this._capacity = 0;
  	        this._level = SHIFT;
  	        this._root = this._tail = null;
  	        this.__hash = undefined;
  	        this.__altered = true;
  	        return this;
  	      }
  	      return emptyList();
  	    };

  	    List.prototype.push = function(/*...values*/) {
  	      var values = arguments;
  	      var oldSize = this.size;
  	      return this.withMutations(function(list ) {
  	        setListBounds(list, 0, oldSize + values.length);
  	        for (var ii = 0; ii < values.length; ii++) {
  	          list.set(oldSize + ii, values[ii]);
  	        }
  	      });
  	    };

  	    List.prototype.pop = function() {
  	      return setListBounds(this, 0, -1);
  	    };

  	    List.prototype.unshift = function(/*...values*/) {
  	      var values = arguments;
  	      return this.withMutations(function(list ) {
  	        setListBounds(list, -values.length);
  	        for (var ii = 0; ii < values.length; ii++) {
  	          list.set(ii, values[ii]);
  	        }
  	      });
  	    };

  	    List.prototype.shift = function() {
  	      return setListBounds(this, 1);
  	    };

  	    // @pragma Composition

  	    List.prototype.merge = function(/*...iters*/) {
  	      return mergeIntoListWith(this, undefined, arguments);
  	    };

  	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
  	      return mergeIntoListWith(this, merger, iters);
  	    };

  	    List.prototype.mergeDeep = function(/*...iters*/) {
  	      return mergeIntoListWith(this, deepMerger, arguments);
  	    };

  	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
  	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
  	    };

  	    List.prototype.setSize = function(size) {
  	      return setListBounds(this, 0, size);
  	    };

  	    // @pragma Iteration

  	    List.prototype.slice = function(begin, end) {
  	      var size = this.size;
  	      if (wholeSlice(begin, end, size)) {
  	        return this;
  	      }
  	      return setListBounds(
  	        this,
  	        resolveBegin(begin, size),
  	        resolveEnd(end, size)
  	      );
  	    };

  	    List.prototype.__iterator = function(type, reverse) {
  	      var index = 0;
  	      var values = iterateList(this, reverse);
  	      return new Iterator(function()  {
  	        var value = values();
  	        return value === DONE ?
  	          iteratorDone() :
  	          iteratorValue(type, index++, value);
  	      });
  	    };

  	    List.prototype.__iterate = function(fn, reverse) {
  	      var index = 0;
  	      var values = iterateList(this, reverse);
  	      var value;
  	      while ((value = values()) !== DONE) {
  	        if (fn(value, index++, this) === false) {
  	          break;
  	        }
  	      }
  	      return index;
  	    };

  	    List.prototype.__ensureOwner = function(ownerID) {
  	      if (ownerID === this.__ownerID) {
  	        return this;
  	      }
  	      if (!ownerID) {
  	        this.__ownerID = ownerID;
  	        return this;
  	      }
  	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
  	    };


  	  function isList(maybeList) {
  	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
  	  }

  	  List.isList = isList;

  	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

  	  var ListPrototype = List.prototype;
  	  ListPrototype[IS_LIST_SENTINEL] = true;
  	  ListPrototype[DELETE] = ListPrototype.remove;
  	  ListPrototype.setIn = MapPrototype.setIn;
  	  ListPrototype.deleteIn =
  	  ListPrototype.removeIn = MapPrototype.removeIn;
  	  ListPrototype.update = MapPrototype.update;
  	  ListPrototype.updateIn = MapPrototype.updateIn;
  	  ListPrototype.mergeIn = MapPrototype.mergeIn;
  	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  	  ListPrototype.withMutations = MapPrototype.withMutations;
  	  ListPrototype.asMutable = MapPrototype.asMutable;
  	  ListPrototype.asImmutable = MapPrototype.asImmutable;
  	  ListPrototype.wasAltered = MapPrototype.wasAltered;



  	    function VNode(array, ownerID) {
  	      this.array = array;
  	      this.ownerID = ownerID;
  	    }

  	    // TODO: seems like these methods are very similar

  	    VNode.prototype.removeBefore = function(ownerID, level, index) {
  	      if (index === level ? 1 << level :  this.array.length === 0) {
  	        return this;
  	      }
  	      var originIndex = (index >>> level) & MASK;
  	      if (originIndex >= this.array.length) {
  	        return new VNode([], ownerID);
  	      }
  	      var removingFirst = originIndex === 0;
  	      var newChild;
  	      if (level > 0) {
  	        var oldChild = this.array[originIndex];
  	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
  	        if (newChild === oldChild && removingFirst) {
  	          return this;
  	        }
  	      }
  	      if (removingFirst && !newChild) {
  	        return this;
  	      }
  	      var editable = editableVNode(this, ownerID);
  	      if (!removingFirst) {
  	        for (var ii = 0; ii < originIndex; ii++) {
  	          editable.array[ii] = undefined;
  	        }
  	      }
  	      if (newChild) {
  	        editable.array[originIndex] = newChild;
  	      }
  	      return editable;
  	    };

  	    VNode.prototype.removeAfter = function(ownerID, level, index) {
  	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
  	        return this;
  	      }
  	      var sizeIndex = ((index - 1) >>> level) & MASK;
  	      if (sizeIndex >= this.array.length) {
  	        return this;
  	      }

  	      var newChild;
  	      if (level > 0) {
  	        var oldChild = this.array[sizeIndex];
  	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
  	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
  	          return this;
  	        }
  	      }

  	      var editable = editableVNode(this, ownerID);
  	      editable.array.splice(sizeIndex + 1);
  	      if (newChild) {
  	        editable.array[sizeIndex] = newChild;
  	      }
  	      return editable;
  	    };



  	  var DONE = {};

  	  function iterateList(list, reverse) {
  	    var left = list._origin;
  	    var right = list._capacity;
  	    var tailPos = getTailOffset(right);
  	    var tail = list._tail;

  	    return iterateNodeOrLeaf(list._root, list._level, 0);

  	    function iterateNodeOrLeaf(node, level, offset) {
  	      return level === 0 ?
  	        iterateLeaf(node, offset) :
  	        iterateNode(node, level, offset);
  	    }

  	    function iterateLeaf(node, offset) {
  	      var array = offset === tailPos ? tail && tail.array : node && node.array;
  	      var from = offset > left ? 0 : left - offset;
  	      var to = right - offset;
  	      if (to > SIZE) {
  	        to = SIZE;
  	      }
  	      return function()  {
  	        if (from === to) {
  	          return DONE;
  	        }
  	        var idx = reverse ? --to : from++;
  	        return array && array[idx];
  	      };
  	    }

  	    function iterateNode(node, level, offset) {
  	      var values;
  	      var array = node && node.array;
  	      var from = offset > left ? 0 : (left - offset) >> level;
  	      var to = ((right - offset) >> level) + 1;
  	      if (to > SIZE) {
  	        to = SIZE;
  	      }
  	      return function()  {
  	        do {
  	          if (values) {
  	            var value = values();
  	            if (value !== DONE) {
  	              return value;
  	            }
  	            values = null;
  	          }
  	          if (from === to) {
  	            return DONE;
  	          }
  	          var idx = reverse ? --to : from++;
  	          values = iterateNodeOrLeaf(
  	            array && array[idx], level - SHIFT, offset + (idx << level)
  	          );
  	        } while (true);
  	      };
  	    }
  	  }

  	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
  	    var list = Object.create(ListPrototype);
  	    list.size = capacity - origin;
  	    list._origin = origin;
  	    list._capacity = capacity;
  	    list._level = level;
  	    list._root = root;
  	    list._tail = tail;
  	    list.__ownerID = ownerID;
  	    list.__hash = hash;
  	    list.__altered = false;
  	    return list;
  	  }

  	  var EMPTY_LIST;
  	  function emptyList() {
  	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  	  }

  	  function updateList(list, index, value) {
  	    index = wrapIndex(list, index);

  	    if (index !== index) {
  	      return list;
  	    }

  	    if (index >= list.size || index < 0) {
  	      return list.withMutations(function(list ) {
  	        index < 0 ?
  	          setListBounds(list, index).set(0, value) :
  	          setListBounds(list, 0, index + 1).set(index, value);
  	      });
  	    }

  	    index += list._origin;

  	    var newTail = list._tail;
  	    var newRoot = list._root;
  	    var didAlter = MakeRef(DID_ALTER);
  	    if (index >= getTailOffset(list._capacity)) {
  	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
  	    } else {
  	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
  	    }

  	    if (!didAlter.value) {
  	      return list;
  	    }

  	    if (list.__ownerID) {
  	      list._root = newRoot;
  	      list._tail = newTail;
  	      list.__hash = undefined;
  	      list.__altered = true;
  	      return list;
  	    }
  	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  	  }

  	  function updateVNode(node, ownerID, level, index, value, didAlter) {
  	    var idx = (index >>> level) & MASK;
  	    var nodeHas = node && idx < node.array.length;
  	    if (!nodeHas && value === undefined) {
  	      return node;
  	    }

  	    var newNode;

  	    if (level > 0) {
  	      var lowerNode = node && node.array[idx];
  	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
  	      if (newLowerNode === lowerNode) {
  	        return node;
  	      }
  	      newNode = editableVNode(node, ownerID);
  	      newNode.array[idx] = newLowerNode;
  	      return newNode;
  	    }

  	    if (nodeHas && node.array[idx] === value) {
  	      return node;
  	    }

  	    SetRef(didAlter);

  	    newNode = editableVNode(node, ownerID);
  	    if (value === undefined && idx === newNode.array.length - 1) {
  	      newNode.array.pop();
  	    } else {
  	      newNode.array[idx] = value;
  	    }
  	    return newNode;
  	  }

  	  function editableVNode(node, ownerID) {
  	    if (ownerID && node && ownerID === node.ownerID) {
  	      return node;
  	    }
  	    return new VNode(node ? node.array.slice() : [], ownerID);
  	  }

  	  function listNodeFor(list, rawIndex) {
  	    if (rawIndex >= getTailOffset(list._capacity)) {
  	      return list._tail;
  	    }
  	    if (rawIndex < 1 << (list._level + SHIFT)) {
  	      var node = list._root;
  	      var level = list._level;
  	      while (node && level > 0) {
  	        node = node.array[(rawIndex >>> level) & MASK];
  	        level -= SHIFT;
  	      }
  	      return node;
  	    }
  	  }

  	  function setListBounds(list, begin, end) {
  	    // Sanitize begin & end using this shorthand for ToInt32(argument)
  	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
  	    if (begin !== undefined) {
  	      begin = begin | 0;
  	    }
  	    if (end !== undefined) {
  	      end = end | 0;
  	    }
  	    var owner = list.__ownerID || new OwnerID();
  	    var oldOrigin = list._origin;
  	    var oldCapacity = list._capacity;
  	    var newOrigin = oldOrigin + begin;
  	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
  	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
  	      return list;
  	    }

  	    // If it's going to end after it starts, it's empty.
  	    if (newOrigin >= newCapacity) {
  	      return list.clear();
  	    }

  	    var newLevel = list._level;
  	    var newRoot = list._root;

  	    // New origin might need creating a higher root.
  	    var offsetShift = 0;
  	    while (newOrigin + offsetShift < 0) {
  	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
  	      newLevel += SHIFT;
  	      offsetShift += 1 << newLevel;
  	    }
  	    if (offsetShift) {
  	      newOrigin += offsetShift;
  	      oldOrigin += offsetShift;
  	      newCapacity += offsetShift;
  	      oldCapacity += offsetShift;
  	    }

  	    var oldTailOffset = getTailOffset(oldCapacity);
  	    var newTailOffset = getTailOffset(newCapacity);

  	    // New size might need creating a higher root.
  	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
  	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
  	      newLevel += SHIFT;
  	    }

  	    // Locate or create the new tail.
  	    var oldTail = list._tail;
  	    var newTail = newTailOffset < oldTailOffset ?
  	      listNodeFor(list, newCapacity - 1) :
  	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

  	    // Merge Tail into tree.
  	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
  	      newRoot = editableVNode(newRoot, owner);
  	      var node = newRoot;
  	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
  	        var idx = (oldTailOffset >>> level) & MASK;
  	        node = node.array[idx] = editableVNode(node.array[idx], owner);
  	      }
  	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
  	    }

  	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
  	    if (newCapacity < oldCapacity) {
  	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  	    }

  	    // If the new origin is within the tail, then we do not need a root.
  	    if (newOrigin >= newTailOffset) {
  	      newOrigin -= newTailOffset;
  	      newCapacity -= newTailOffset;
  	      newLevel = SHIFT;
  	      newRoot = null;
  	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

  	    // Otherwise, if the root has been trimmed, garbage collect.
  	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
  	      offsetShift = 0;

  	      // Identify the new top root node of the subtree of the old root.
  	      while (newRoot) {
  	        var beginIndex = (newOrigin >>> newLevel) & MASK;
  	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
  	          break;
  	        }
  	        if (beginIndex) {
  	          offsetShift += (1 << newLevel) * beginIndex;
  	        }
  	        newLevel -= SHIFT;
  	        newRoot = newRoot.array[beginIndex];
  	      }

  	      // Trim the new sides of the new root.
  	      if (newRoot && newOrigin > oldOrigin) {
  	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
  	      }
  	      if (newRoot && newTailOffset < oldTailOffset) {
  	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
  	      }
  	      if (offsetShift) {
  	        newOrigin -= offsetShift;
  	        newCapacity -= offsetShift;
  	      }
  	    }

  	    if (list.__ownerID) {
  	      list.size = newCapacity - newOrigin;
  	      list._origin = newOrigin;
  	      list._capacity = newCapacity;
  	      list._level = newLevel;
  	      list._root = newRoot;
  	      list._tail = newTail;
  	      list.__hash = undefined;
  	      list.__altered = true;
  	      return list;
  	    }
  	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  	  }

  	  function mergeIntoListWith(list, merger, iterables) {
  	    var iters = [];
  	    var maxSize = 0;
  	    for (var ii = 0; ii < iterables.length; ii++) {
  	      var value = iterables[ii];
  	      var iter = IndexedIterable(value);
  	      if (iter.size > maxSize) {
  	        maxSize = iter.size;
  	      }
  	      if (!isIterable(value)) {
  	        iter = iter.map(function(v ) {return fromJS(v)});
  	      }
  	      iters.push(iter);
  	    }
  	    if (maxSize > list.size) {
  	      list = list.setSize(maxSize);
  	    }
  	    return mergeIntoCollectionWith(list, merger, iters);
  	  }

  	  function getTailOffset(size) {
  	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
  	  }

  	  createClass(OrderedMap, Map);

  	    // @pragma Construction

  	    function OrderedMap(value) {
  	      return value === null || value === undefined ? emptyOrderedMap() :
  	        isOrderedMap(value) ? value :
  	        emptyOrderedMap().withMutations(function(map ) {
  	          var iter = KeyedIterable(value);
  	          assertNotInfinite(iter.size);
  	          iter.forEach(function(v, k)  {return map.set(k, v)});
  	        });
  	    }

  	    OrderedMap.of = function(/*...values*/) {
  	      return this(arguments);
  	    };

  	    OrderedMap.prototype.toString = function() {
  	      return this.__toString('OrderedMap {', '}');
  	    };

  	    // @pragma Access

  	    OrderedMap.prototype.get = function(k, notSetValue) {
  	      var index = this._map.get(k);
  	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
  	    };

  	    // @pragma Modification

  	    OrderedMap.prototype.clear = function() {
  	      if (this.size === 0) {
  	        return this;
  	      }
  	      if (this.__ownerID) {
  	        this.size = 0;
  	        this._map.clear();
  	        this._list.clear();
  	        return this;
  	      }
  	      return emptyOrderedMap();
  	    };

  	    OrderedMap.prototype.set = function(k, v) {
  	      return updateOrderedMap(this, k, v);
  	    };

  	    OrderedMap.prototype.remove = function(k) {
  	      return updateOrderedMap(this, k, NOT_SET);
  	    };

  	    OrderedMap.prototype.wasAltered = function() {
  	      return this._map.wasAltered() || this._list.wasAltered();
  	    };

  	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
  	      return this._list.__iterate(
  	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
  	        reverse
  	      );
  	    };

  	    OrderedMap.prototype.__iterator = function(type, reverse) {
  	      return this._list.fromEntrySeq().__iterator(type, reverse);
  	    };

  	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
  	      if (ownerID === this.__ownerID) {
  	        return this;
  	      }
  	      var newMap = this._map.__ensureOwner(ownerID);
  	      var newList = this._list.__ensureOwner(ownerID);
  	      if (!ownerID) {
  	        this.__ownerID = ownerID;
  	        this._map = newMap;
  	        this._list = newList;
  	        return this;
  	      }
  	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  	    };


  	  function isOrderedMap(maybeOrderedMap) {
  	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  	  }

  	  OrderedMap.isOrderedMap = isOrderedMap;

  	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
  	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



  	  function makeOrderedMap(map, list, ownerID, hash) {
  	    var omap = Object.create(OrderedMap.prototype);
  	    omap.size = map ? map.size : 0;
  	    omap._map = map;
  	    omap._list = list;
  	    omap.__ownerID = ownerID;
  	    omap.__hash = hash;
  	    return omap;
  	  }

  	  var EMPTY_ORDERED_MAP;
  	  function emptyOrderedMap() {
  	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
  	  }

  	  function updateOrderedMap(omap, k, v) {
  	    var map = omap._map;
  	    var list = omap._list;
  	    var i = map.get(k);
  	    var has = i !== undefined;
  	    var newMap;
  	    var newList;
  	    if (v === NOT_SET) { // removed
  	      if (!has) {
  	        return omap;
  	      }
  	      if (list.size >= SIZE && list.size >= map.size * 2) {
  	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
  	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
  	        if (omap.__ownerID) {
  	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
  	        }
  	      } else {
  	        newMap = map.remove(k);
  	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
  	      }
  	    } else {
  	      if (has) {
  	        if (v === list.get(i)[1]) {
  	          return omap;
  	        }
  	        newMap = map;
  	        newList = list.set(i, [k, v]);
  	      } else {
  	        newMap = map.set(k, list.size);
  	        newList = list.set(list.size, [k, v]);
  	      }
  	    }
  	    if (omap.__ownerID) {
  	      omap.size = newMap.size;
  	      omap._map = newMap;
  	      omap._list = newList;
  	      omap.__hash = undefined;
  	      return omap;
  	    }
  	    return makeOrderedMap(newMap, newList);
  	  }

  	  createClass(ToKeyedSequence, KeyedSeq);
  	    function ToKeyedSequence(indexed, useKeys) {
  	      this._iter = indexed;
  	      this._useKeys = useKeys;
  	      this.size = indexed.size;
  	    }

  	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
  	      return this._iter.get(key, notSetValue);
  	    };

  	    ToKeyedSequence.prototype.has = function(key) {
  	      return this._iter.has(key);
  	    };

  	    ToKeyedSequence.prototype.valueSeq = function() {
  	      return this._iter.valueSeq();
  	    };

  	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
  	      var reversedSequence = reverseFactory(this, true);
  	      if (!this._useKeys) {
  	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
  	      }
  	      return reversedSequence;
  	    };

  	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
  	      var mappedSequence = mapFactory(this, mapper, context);
  	      if (!this._useKeys) {
  	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
  	      }
  	      return mappedSequence;
  	    };

  	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
  	      var ii;
  	      return this._iter.__iterate(
  	        this._useKeys ?
  	          function(v, k)  {return fn(v, k, this$0)} :
  	          ((ii = reverse ? resolveSize(this) : 0),
  	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
  	        reverse
  	      );
  	    };

  	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
  	      if (this._useKeys) {
  	        return this._iter.__iterator(type, reverse);
  	      }
  	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
  	      var ii = reverse ? resolveSize(this) : 0;
  	      return new Iterator(function()  {
  	        var step = iterator.next();
  	        return step.done ? step :
  	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
  	      });
  	    };

  	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


  	  createClass(ToIndexedSequence, IndexedSeq);
  	    function ToIndexedSequence(iter) {
  	      this._iter = iter;
  	      this.size = iter.size;
  	    }

  	    ToIndexedSequence.prototype.includes = function(value) {
  	      return this._iter.includes(value);
  	    };

  	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
  	      var iterations = 0;
  	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
  	    };

  	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
  	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
  	      var iterations = 0;
  	      return new Iterator(function()  {
  	        var step = iterator.next();
  	        return step.done ? step :
  	          iteratorValue(type, iterations++, step.value, step)
  	      });
  	    };



  	  createClass(ToSetSequence, SetSeq);
  	    function ToSetSequence(iter) {
  	      this._iter = iter;
  	      this.size = iter.size;
  	    }

  	    ToSetSequence.prototype.has = function(key) {
  	      return this._iter.includes(key);
  	    };

  	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
  	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
  	    };

  	    ToSetSequence.prototype.__iterator = function(type, reverse) {
  	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
  	      return new Iterator(function()  {
  	        var step = iterator.next();
  	        return step.done ? step :
  	          iteratorValue(type, step.value, step.value, step);
  	      });
  	    };



  	  createClass(FromEntriesSequence, KeyedSeq);
  	    function FromEntriesSequence(entries) {
  	      this._iter = entries;
  	      this.size = entries.size;
  	    }

  	    FromEntriesSequence.prototype.entrySeq = function() {
  	      return this._iter.toSeq();
  	    };

  	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
  	      return this._iter.__iterate(function(entry ) {
  	        // Check if entry exists first so array access doesn't throw for holes
  	        // in the parent iteration.
  	        if (entry) {
  	          validateEntry(entry);
  	          var indexedIterable = isIterable(entry);
  	          return fn(
  	            indexedIterable ? entry.get(1) : entry[1],
  	            indexedIterable ? entry.get(0) : entry[0],
  	            this$0
  	          );
  	        }
  	      }, reverse);
  	    };

  	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
  	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
  	      return new Iterator(function()  {
  	        while (true) {
  	          var step = iterator.next();
  	          if (step.done) {
  	            return step;
  	          }
  	          var entry = step.value;
  	          // Check if entry exists first so array access doesn't throw for holes
  	          // in the parent iteration.
  	          if (entry) {
  	            validateEntry(entry);
  	            var indexedIterable = isIterable(entry);
  	            return iteratorValue(
  	              type,
  	              indexedIterable ? entry.get(0) : entry[0],
  	              indexedIterable ? entry.get(1) : entry[1],
  	              step
  	            );
  	          }
  	        }
  	      });
  	    };


  	  ToIndexedSequence.prototype.cacheResult =
  	  ToKeyedSequence.prototype.cacheResult =
  	  ToSetSequence.prototype.cacheResult =
  	  FromEntriesSequence.prototype.cacheResult =
  	    cacheResultThrough;


  	  function flipFactory(iterable) {
  	    var flipSequence = makeSequence(iterable);
  	    flipSequence._iter = iterable;
  	    flipSequence.size = iterable.size;
  	    flipSequence.flip = function()  {return iterable};
  	    flipSequence.reverse = function () {
  	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
  	      reversedSequence.flip = function()  {return iterable.reverse()};
  	      return reversedSequence;
  	    };
  	    flipSequence.has = function(key ) {return iterable.includes(key)};
  	    flipSequence.includes = function(key ) {return iterable.has(key)};
  	    flipSequence.cacheResult = cacheResultThrough;
  	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
  	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
  	    };
  	    flipSequence.__iteratorUncached = function(type, reverse) {
  	      if (type === ITERATE_ENTRIES) {
  	        var iterator = iterable.__iterator(type, reverse);
  	        return new Iterator(function()  {
  	          var step = iterator.next();
  	          if (!step.done) {
  	            var k = step.value[0];
  	            step.value[0] = step.value[1];
  	            step.value[1] = k;
  	          }
  	          return step;
  	        });
  	      }
  	      return iterable.__iterator(
  	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
  	        reverse
  	      );
  	    };
  	    return flipSequence;
  	  }


  	  function mapFactory(iterable, mapper, context) {
  	    var mappedSequence = makeSequence(iterable);
  	    mappedSequence.size = iterable.size;
  	    mappedSequence.has = function(key ) {return iterable.has(key)};
  	    mappedSequence.get = function(key, notSetValue)  {
  	      var v = iterable.get(key, NOT_SET);
  	      return v === NOT_SET ?
  	        notSetValue :
  	        mapper.call(context, v, key, iterable);
  	    };
  	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
  	      return iterable.__iterate(
  	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
  	        reverse
  	      );
  	    };
  	    mappedSequence.__iteratorUncached = function (type, reverse) {
  	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
  	      return new Iterator(function()  {
  	        var step = iterator.next();
  	        if (step.done) {
  	          return step;
  	        }
  	        var entry = step.value;
  	        var key = entry[0];
  	        return iteratorValue(
  	          type,
  	          key,
  	          mapper.call(context, entry[1], key, iterable),
  	          step
  	        );
  	      });
  	    };
  	    return mappedSequence;
  	  }


  	  function reverseFactory(iterable, useKeys) {
  	    var reversedSequence = makeSequence(iterable);
  	    reversedSequence._iter = iterable;
  	    reversedSequence.size = iterable.size;
  	    reversedSequence.reverse = function()  {return iterable};
  	    if (iterable.flip) {
  	      reversedSequence.flip = function () {
  	        var flipSequence = flipFactory(iterable);
  	        flipSequence.reverse = function()  {return iterable.flip()};
  	        return flipSequence;
  	      };
  	    }
  	    reversedSequence.get = function(key, notSetValue) 
  	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
  	    reversedSequence.has = function(key )
  	      {return iterable.has(useKeys ? key : -1 - key)};
  	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
  	    reversedSequence.cacheResult = cacheResultThrough;
  	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
  	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
  	    };
  	    reversedSequence.__iterator =
  	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
  	    return reversedSequence;
  	  }


  	  function filterFactory(iterable, predicate, context, useKeys) {
  	    var filterSequence = makeSequence(iterable);
  	    if (useKeys) {
  	      filterSequence.has = function(key ) {
  	        var v = iterable.get(key, NOT_SET);
  	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
  	      };
  	      filterSequence.get = function(key, notSetValue)  {
  	        var v = iterable.get(key, NOT_SET);
  	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
  	          v : notSetValue;
  	      };
  	    }
  	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
  	      var iterations = 0;
  	      iterable.__iterate(function(v, k, c)  {
  	        if (predicate.call(context, v, k, c)) {
  	          iterations++;
  	          return fn(v, useKeys ? k : iterations - 1, this$0);
  	        }
  	      }, reverse);
  	      return iterations;
  	    };
  	    filterSequence.__iteratorUncached = function (type, reverse) {
  	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
  	      var iterations = 0;
  	      return new Iterator(function()  {
  	        while (true) {
  	          var step = iterator.next();
  	          if (step.done) {
  	            return step;
  	          }
  	          var entry = step.value;
  	          var key = entry[0];
  	          var value = entry[1];
  	          if (predicate.call(context, value, key, iterable)) {
  	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
  	          }
  	        }
  	      });
  	    };
  	    return filterSequence;
  	  }


  	  function countByFactory(iterable, grouper, context) {
  	    var groups = Map().asMutable();
  	    iterable.__iterate(function(v, k)  {
  	      groups.update(
  	        grouper.call(context, v, k, iterable),
  	        0,
  	        function(a ) {return a + 1}
  	      );
  	    });
  	    return groups.asImmutable();
  	  }


  	  function groupByFactory(iterable, grouper, context) {
  	    var isKeyedIter = isKeyed(iterable);
  	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
  	    iterable.__iterate(function(v, k)  {
  	      groups.update(
  	        grouper.call(context, v, k, iterable),
  	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
  	      );
  	    });
  	    var coerce = iterableClass(iterable);
  	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
  	  }


  	  function sliceFactory(iterable, begin, end, useKeys) {
  	    var originalSize = iterable.size;

  	    // Sanitize begin & end using this shorthand for ToInt32(argument)
  	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
  	    if (begin !== undefined) {
  	      begin = begin | 0;
  	    }
  	    if (end !== undefined) {
  	      if (end === Infinity) {
  	        end = originalSize;
  	      } else {
  	        end = end | 0;
  	      }
  	    }

  	    if (wholeSlice(begin, end, originalSize)) {
  	      return iterable;
  	    }

  	    var resolvedBegin = resolveBegin(begin, originalSize);
  	    var resolvedEnd = resolveEnd(end, originalSize);

  	    // begin or end will be NaN if they were provided as negative numbers and
  	    // this iterable's size is unknown. In that case, cache first so there is
  	    // a known size and these do not resolve to NaN.
  	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
  	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
  	    }

  	    // Note: resolvedEnd is undefined when the original sequence's length is
  	    // unknown and this slice did not supply an end and should contain all
  	    // elements after resolvedBegin.
  	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
  	    var resolvedSize = resolvedEnd - resolvedBegin;
  	    var sliceSize;
  	    if (resolvedSize === resolvedSize) {
  	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  	    }

  	    var sliceSeq = makeSequence(iterable);

  	    // If iterable.size is undefined, the size of the realized sliceSeq is
  	    // unknown at this point unless the number of items to slice is 0
  	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

  	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
  	      sliceSeq.get = function (index, notSetValue) {
  	        index = wrapIndex(this, index);
  	        return index >= 0 && index < sliceSize ?
  	          iterable.get(index + resolvedBegin, notSetValue) :
  	          notSetValue;
  	      };
  	    }

  	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
  	      if (sliceSize === 0) {
  	        return 0;
  	      }
  	      if (reverse) {
  	        return this.cacheResult().__iterate(fn, reverse);
  	      }
  	      var skipped = 0;
  	      var isSkipping = true;
  	      var iterations = 0;
  	      iterable.__iterate(function(v, k)  {
  	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
  	          iterations++;
  	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
  	                 iterations !== sliceSize;
  	        }
  	      });
  	      return iterations;
  	    };

  	    sliceSeq.__iteratorUncached = function(type, reverse) {
  	      if (sliceSize !== 0 && reverse) {
  	        return this.cacheResult().__iterator(type, reverse);
  	      }
  	      // Don't bother instantiating parent iterator if taking 0.
  	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
  	      var skipped = 0;
  	      var iterations = 0;
  	      return new Iterator(function()  {
  	        while (skipped++ < resolvedBegin) {
  	          iterator.next();
  	        }
  	        if (++iterations > sliceSize) {
  	          return iteratorDone();
  	        }
  	        var step = iterator.next();
  	        if (useKeys || type === ITERATE_VALUES) {
  	          return step;
  	        } else if (type === ITERATE_KEYS) {
  	          return iteratorValue(type, iterations - 1, undefined, step);
  	        } else {
  	          return iteratorValue(type, iterations - 1, step.value[1], step);
  	        }
  	      });
  	    };

  	    return sliceSeq;
  	  }


  	  function takeWhileFactory(iterable, predicate, context) {
  	    var takeSequence = makeSequence(iterable);
  	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
  	      if (reverse) {
  	        return this.cacheResult().__iterate(fn, reverse);
  	      }
  	      var iterations = 0;
  	      iterable.__iterate(function(v, k, c) 
  	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
  	      );
  	      return iterations;
  	    };
  	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
  	      if (reverse) {
  	        return this.cacheResult().__iterator(type, reverse);
  	      }
  	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
  	      var iterating = true;
  	      return new Iterator(function()  {
  	        if (!iterating) {
  	          return iteratorDone();
  	        }
  	        var step = iterator.next();
  	        if (step.done) {
  	          return step;
  	        }
  	        var entry = step.value;
  	        var k = entry[0];
  	        var v = entry[1];
  	        if (!predicate.call(context, v, k, this$0)) {
  	          iterating = false;
  	          return iteratorDone();
  	        }
  	        return type === ITERATE_ENTRIES ? step :
  	          iteratorValue(type, k, v, step);
  	      });
  	    };
  	    return takeSequence;
  	  }


  	  function skipWhileFactory(iterable, predicate, context, useKeys) {
  	    var skipSequence = makeSequence(iterable);
  	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
  	      if (reverse) {
  	        return this.cacheResult().__iterate(fn, reverse);
  	      }
  	      var isSkipping = true;
  	      var iterations = 0;
  	      iterable.__iterate(function(v, k, c)  {
  	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
  	          iterations++;
  	          return fn(v, useKeys ? k : iterations - 1, this$0);
  	        }
  	      });
  	      return iterations;
  	    };
  	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
  	      if (reverse) {
  	        return this.cacheResult().__iterator(type, reverse);
  	      }
  	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
  	      var skipping = true;
  	      var iterations = 0;
  	      return new Iterator(function()  {
  	        var step, k, v;
  	        do {
  	          step = iterator.next();
  	          if (step.done) {
  	            if (useKeys || type === ITERATE_VALUES) {
  	              return step;
  	            } else if (type === ITERATE_KEYS) {
  	              return iteratorValue(type, iterations++, undefined, step);
  	            } else {
  	              return iteratorValue(type, iterations++, step.value[1], step);
  	            }
  	          }
  	          var entry = step.value;
  	          k = entry[0];
  	          v = entry[1];
  	          skipping && (skipping = predicate.call(context, v, k, this$0));
  	        } while (skipping);
  	        return type === ITERATE_ENTRIES ? step :
  	          iteratorValue(type, k, v, step);
  	      });
  	    };
  	    return skipSequence;
  	  }


  	  function concatFactory(iterable, values) {
  	    var isKeyedIterable = isKeyed(iterable);
  	    var iters = [iterable].concat(values).map(function(v ) {
  	      if (!isIterable(v)) {
  	        v = isKeyedIterable ?
  	          keyedSeqFromValue(v) :
  	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
  	      } else if (isKeyedIterable) {
  	        v = KeyedIterable(v);
  	      }
  	      return v;
  	    }).filter(function(v ) {return v.size !== 0});

  	    if (iters.length === 0) {
  	      return iterable;
  	    }

  	    if (iters.length === 1) {
  	      var singleton = iters[0];
  	      if (singleton === iterable ||
  	          isKeyedIterable && isKeyed(singleton) ||
  	          isIndexed(iterable) && isIndexed(singleton)) {
  	        return singleton;
  	      }
  	    }

  	    var concatSeq = new ArraySeq(iters);
  	    if (isKeyedIterable) {
  	      concatSeq = concatSeq.toKeyedSeq();
  	    } else if (!isIndexed(iterable)) {
  	      concatSeq = concatSeq.toSetSeq();
  	    }
  	    concatSeq = concatSeq.flatten(true);
  	    concatSeq.size = iters.reduce(
  	      function(sum, seq)  {
  	        if (sum !== undefined) {
  	          var size = seq.size;
  	          if (size !== undefined) {
  	            return sum + size;
  	          }
  	        }
  	      },
  	      0
  	    );
  	    return concatSeq;
  	  }


  	  function flattenFactory(iterable, depth, useKeys) {
  	    var flatSequence = makeSequence(iterable);
  	    flatSequence.__iterateUncached = function(fn, reverse) {
  	      var iterations = 0;
  	      var stopped = false;
  	      function flatDeep(iter, currentDepth) {var this$0 = this;
  	        iter.__iterate(function(v, k)  {
  	          if ((!depth || currentDepth < depth) && isIterable(v)) {
  	            flatDeep(v, currentDepth + 1);
  	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
  	            stopped = true;
  	          }
  	          return !stopped;
  	        }, reverse);
  	      }
  	      flatDeep(iterable, 0);
  	      return iterations;
  	    };
  	    flatSequence.__iteratorUncached = function(type, reverse) {
  	      var iterator = iterable.__iterator(type, reverse);
  	      var stack = [];
  	      var iterations = 0;
  	      return new Iterator(function()  {
  	        while (iterator) {
  	          var step = iterator.next();
  	          if (step.done !== false) {
  	            iterator = stack.pop();
  	            continue;
  	          }
  	          var v = step.value;
  	          if (type === ITERATE_ENTRIES) {
  	            v = v[1];
  	          }
  	          if ((!depth || stack.length < depth) && isIterable(v)) {
  	            stack.push(iterator);
  	            iterator = v.__iterator(type, reverse);
  	          } else {
  	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
  	          }
  	        }
  	        return iteratorDone();
  	      });
  	    };
  	    return flatSequence;
  	  }


  	  function flatMapFactory(iterable, mapper, context) {
  	    var coerce = iterableClass(iterable);
  	    return iterable.toSeq().map(
  	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
  	    ).flatten(true);
  	  }


  	  function interposeFactory(iterable, separator) {
  	    var interposedSequence = makeSequence(iterable);
  	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
  	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
  	      var iterations = 0;
  	      iterable.__iterate(function(v, k) 
  	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
  	        fn(v, iterations++, this$0) !== false},
  	        reverse
  	      );
  	      return iterations;
  	    };
  	    interposedSequence.__iteratorUncached = function(type, reverse) {
  	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
  	      var iterations = 0;
  	      var step;
  	      return new Iterator(function()  {
  	        if (!step || iterations % 2) {
  	          step = iterator.next();
  	          if (step.done) {
  	            return step;
  	          }
  	        }
  	        return iterations % 2 ?
  	          iteratorValue(type, iterations++, separator) :
  	          iteratorValue(type, iterations++, step.value, step);
  	      });
  	    };
  	    return interposedSequence;
  	  }


  	  function sortFactory(iterable, comparator, mapper) {
  	    if (!comparator) {
  	      comparator = defaultComparator;
  	    }
  	    var isKeyedIterable = isKeyed(iterable);
  	    var index = 0;
  	    var entries = iterable.toSeq().map(
  	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
  	    ).toArray();
  	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
  	      isKeyedIterable ?
  	      function(v, i)  { entries[i].length = 2; } :
  	      function(v, i)  { entries[i] = v[1]; }
  	    );
  	    return isKeyedIterable ? KeyedSeq(entries) :
  	      isIndexed(iterable) ? IndexedSeq(entries) :
  	      SetSeq(entries);
  	  }


  	  function maxFactory(iterable, comparator, mapper) {
  	    if (!comparator) {
  	      comparator = defaultComparator;
  	    }
  	    if (mapper) {
  	      var entry = iterable.toSeq()
  	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
  	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
  	      return entry && entry[0];
  	    } else {
  	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
  	    }
  	  }

  	  function maxCompare(comparator, a, b) {
  	    var comp = comparator(b, a);
  	    // b is considered the new max if the comparator declares them equal, but
  	    // they are not equal and b is in fact a nullish value.
  	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
  	  }


  	  function zipWithFactory(keyIter, zipper, iters) {
  	    var zipSequence = makeSequence(keyIter);
  	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
  	    // Note: this a generic base implementation of __iterate in terms of
  	    // __iterator which may be more generically useful in the future.
  	    zipSequence.__iterate = function(fn, reverse) {
  	      /* generic:
  	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
  	      var step;
  	      var iterations = 0;
  	      while (!(step = iterator.next()).done) {
  	        iterations++;
  	        if (fn(step.value[1], step.value[0], this) === false) {
  	          break;
  	        }
  	      }
  	      return iterations;
  	      */
  	      // indexed:
  	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
  	      var step;
  	      var iterations = 0;
  	      while (!(step = iterator.next()).done) {
  	        if (fn(step.value, iterations++, this) === false) {
  	          break;
  	        }
  	      }
  	      return iterations;
  	    };
  	    zipSequence.__iteratorUncached = function(type, reverse) {
  	      var iterators = iters.map(function(i )
  	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
  	      );
  	      var iterations = 0;
  	      var isDone = false;
  	      return new Iterator(function()  {
  	        var steps;
  	        if (!isDone) {
  	          steps = iterators.map(function(i ) {return i.next()});
  	          isDone = steps.some(function(s ) {return s.done});
  	        }
  	        if (isDone) {
  	          return iteratorDone();
  	        }
  	        return iteratorValue(
  	          type,
  	          iterations++,
  	          zipper.apply(null, steps.map(function(s ) {return s.value}))
  	        );
  	      });
  	    };
  	    return zipSequence
  	  }


  	  // #pragma Helper Functions

  	  function reify(iter, seq) {
  	    return isSeq(iter) ? seq : iter.constructor(seq);
  	  }

  	  function validateEntry(entry) {
  	    if (entry !== Object(entry)) {
  	      throw new TypeError('Expected [K, V] tuple: ' + entry);
  	    }
  	  }

  	  function resolveSize(iter) {
  	    assertNotInfinite(iter.size);
  	    return ensureSize(iter);
  	  }

  	  function iterableClass(iterable) {
  	    return isKeyed(iterable) ? KeyedIterable :
  	      isIndexed(iterable) ? IndexedIterable :
  	      SetIterable;
  	  }

  	  function makeSequence(iterable) {
  	    return Object.create(
  	      (
  	        isKeyed(iterable) ? KeyedSeq :
  	        isIndexed(iterable) ? IndexedSeq :
  	        SetSeq
  	      ).prototype
  	    );
  	  }

  	  function cacheResultThrough() {
  	    if (this._iter.cacheResult) {
  	      this._iter.cacheResult();
  	      this.size = this._iter.size;
  	      return this;
  	    } else {
  	      return Seq.prototype.cacheResult.call(this);
  	    }
  	  }

  	  function defaultComparator(a, b) {
  	    return a > b ? 1 : a < b ? -1 : 0;
  	  }

  	  function forceIterator(keyPath) {
  	    var iter = getIterator(keyPath);
  	    if (!iter) {
  	      // Array might not be iterable in this environment, so we need a fallback
  	      // to our wrapped type.
  	      if (!isArrayLike(keyPath)) {
  	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
  	      }
  	      iter = getIterator(Iterable(keyPath));
  	    }
  	    return iter;
  	  }

  	  createClass(Record, KeyedCollection);

  	    function Record(defaultValues, name) {
  	      var hasInitialized;

  	      var RecordType = function Record(values) {
  	        if (values instanceof RecordType) {
  	          return values;
  	        }
  	        if (!(this instanceof RecordType)) {
  	          return new RecordType(values);
  	        }
  	        if (!hasInitialized) {
  	          hasInitialized = true;
  	          var keys = Object.keys(defaultValues);
  	          setProps(RecordTypePrototype, keys);
  	          RecordTypePrototype.size = keys.length;
  	          RecordTypePrototype._name = name;
  	          RecordTypePrototype._keys = keys;
  	          RecordTypePrototype._defaultValues = defaultValues;
  	        }
  	        this._map = Map(values);
  	      };

  	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
  	      RecordTypePrototype.constructor = RecordType;

  	      return RecordType;
  	    }

  	    Record.prototype.toString = function() {
  	      return this.__toString(recordName(this) + ' {', '}');
  	    };

  	    // @pragma Access

  	    Record.prototype.has = function(k) {
  	      return this._defaultValues.hasOwnProperty(k);
  	    };

  	    Record.prototype.get = function(k, notSetValue) {
  	      if (!this.has(k)) {
  	        return notSetValue;
  	      }
  	      var defaultVal = this._defaultValues[k];
  	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
  	    };

  	    // @pragma Modification

  	    Record.prototype.clear = function() {
  	      if (this.__ownerID) {
  	        this._map && this._map.clear();
  	        return this;
  	      }
  	      var RecordType = this.constructor;
  	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
  	    };

  	    Record.prototype.set = function(k, v) {
  	      if (!this.has(k)) {
  	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
  	      }
  	      if (this._map && !this._map.has(k)) {
  	        var defaultVal = this._defaultValues[k];
  	        if (v === defaultVal) {
  	          return this;
  	        }
  	      }
  	      var newMap = this._map && this._map.set(k, v);
  	      if (this.__ownerID || newMap === this._map) {
  	        return this;
  	      }
  	      return makeRecord(this, newMap);
  	    };

  	    Record.prototype.remove = function(k) {
  	      if (!this.has(k)) {
  	        return this;
  	      }
  	      var newMap = this._map && this._map.remove(k);
  	      if (this.__ownerID || newMap === this._map) {
  	        return this;
  	      }
  	      return makeRecord(this, newMap);
  	    };

  	    Record.prototype.wasAltered = function() {
  	      return this._map.wasAltered();
  	    };

  	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
  	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
  	    };

  	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
  	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
  	    };

  	    Record.prototype.__ensureOwner = function(ownerID) {
  	      if (ownerID === this.__ownerID) {
  	        return this;
  	      }
  	      var newMap = this._map && this._map.__ensureOwner(ownerID);
  	      if (!ownerID) {
  	        this.__ownerID = ownerID;
  	        this._map = newMap;
  	        return this;
  	      }
  	      return makeRecord(this, newMap, ownerID);
  	    };


  	  var RecordPrototype = Record.prototype;
  	  RecordPrototype[DELETE] = RecordPrototype.remove;
  	  RecordPrototype.deleteIn =
  	  RecordPrototype.removeIn = MapPrototype.removeIn;
  	  RecordPrototype.merge = MapPrototype.merge;
  	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
  	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
  	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
  	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
  	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  	  RecordPrototype.setIn = MapPrototype.setIn;
  	  RecordPrototype.update = MapPrototype.update;
  	  RecordPrototype.updateIn = MapPrototype.updateIn;
  	  RecordPrototype.withMutations = MapPrototype.withMutations;
  	  RecordPrototype.asMutable = MapPrototype.asMutable;
  	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


  	  function makeRecord(likeRecord, map, ownerID) {
  	    var record = Object.create(Object.getPrototypeOf(likeRecord));
  	    record._map = map;
  	    record.__ownerID = ownerID;
  	    return record;
  	  }

  	  function recordName(record) {
  	    return record._name || record.constructor.name || 'Record';
  	  }

  	  function setProps(prototype, names) {
  	    try {
  	      names.forEach(setProp.bind(undefined, prototype));
  	    } catch (error) {
  	      // Object.defineProperty failed. Probably IE8.
  	    }
  	  }

  	  function setProp(prototype, name) {
  	    Object.defineProperty(prototype, name, {
  	      get: function() {
  	        return this.get(name);
  	      },
  	      set: function(value) {
  	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
  	        this.set(name, value);
  	      }
  	    });
  	  }

  	  createClass(Set, SetCollection);

  	    // @pragma Construction

  	    function Set(value) {
  	      return value === null || value === undefined ? emptySet() :
  	        isSet(value) && !isOrdered(value) ? value :
  	        emptySet().withMutations(function(set ) {
  	          var iter = SetIterable(value);
  	          assertNotInfinite(iter.size);
  	          iter.forEach(function(v ) {return set.add(v)});
  	        });
  	    }

  	    Set.of = function(/*...values*/) {
  	      return this(arguments);
  	    };

  	    Set.fromKeys = function(value) {
  	      return this(KeyedIterable(value).keySeq());
  	    };

  	    Set.prototype.toString = function() {
  	      return this.__toString('Set {', '}');
  	    };

  	    // @pragma Access

  	    Set.prototype.has = function(value) {
  	      return this._map.has(value);
  	    };

  	    // @pragma Modification

  	    Set.prototype.add = function(value) {
  	      return updateSet(this, this._map.set(value, true));
  	    };

  	    Set.prototype.remove = function(value) {
  	      return updateSet(this, this._map.remove(value));
  	    };

  	    Set.prototype.clear = function() {
  	      return updateSet(this, this._map.clear());
  	    };

  	    // @pragma Composition

  	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
  	      iters = iters.filter(function(x ) {return x.size !== 0});
  	      if (iters.length === 0) {
  	        return this;
  	      }
  	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
  	        return this.constructor(iters[0]);
  	      }
  	      return this.withMutations(function(set ) {
  	        for (var ii = 0; ii < iters.length; ii++) {
  	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
  	        }
  	      });
  	    };

  	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
  	      if (iters.length === 0) {
  	        return this;
  	      }
  	      iters = iters.map(function(iter ) {return SetIterable(iter)});
  	      var originalSet = this;
  	      return this.withMutations(function(set ) {
  	        originalSet.forEach(function(value ) {
  	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
  	            set.remove(value);
  	          }
  	        });
  	      });
  	    };

  	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
  	      if (iters.length === 0) {
  	        return this;
  	      }
  	      iters = iters.map(function(iter ) {return SetIterable(iter)});
  	      var originalSet = this;
  	      return this.withMutations(function(set ) {
  	        originalSet.forEach(function(value ) {
  	          if (iters.some(function(iter ) {return iter.includes(value)})) {
  	            set.remove(value);
  	          }
  	        });
  	      });
  	    };

  	    Set.prototype.merge = function() {
  	      return this.union.apply(this, arguments);
  	    };

  	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
  	      return this.union.apply(this, iters);
  	    };

  	    Set.prototype.sort = function(comparator) {
  	      // Late binding
  	      return OrderedSet(sortFactory(this, comparator));
  	    };

  	    Set.prototype.sortBy = function(mapper, comparator) {
  	      // Late binding
  	      return OrderedSet(sortFactory(this, comparator, mapper));
  	    };

  	    Set.prototype.wasAltered = function() {
  	      return this._map.wasAltered();
  	    };

  	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
  	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
  	    };

  	    Set.prototype.__iterator = function(type, reverse) {
  	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
  	    };

  	    Set.prototype.__ensureOwner = function(ownerID) {
  	      if (ownerID === this.__ownerID) {
  	        return this;
  	      }
  	      var newMap = this._map.__ensureOwner(ownerID);
  	      if (!ownerID) {
  	        this.__ownerID = ownerID;
  	        this._map = newMap;
  	        return this;
  	      }
  	      return this.__make(newMap, ownerID);
  	    };


  	  function isSet(maybeSet) {
  	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
  	  }

  	  Set.isSet = isSet;

  	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

  	  var SetPrototype = Set.prototype;
  	  SetPrototype[IS_SET_SENTINEL] = true;
  	  SetPrototype[DELETE] = SetPrototype.remove;
  	  SetPrototype.mergeDeep = SetPrototype.merge;
  	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
  	  SetPrototype.withMutations = MapPrototype.withMutations;
  	  SetPrototype.asMutable = MapPrototype.asMutable;
  	  SetPrototype.asImmutable = MapPrototype.asImmutable;

  	  SetPrototype.__empty = emptySet;
  	  SetPrototype.__make = makeSet;

  	  function updateSet(set, newMap) {
  	    if (set.__ownerID) {
  	      set.size = newMap.size;
  	      set._map = newMap;
  	      return set;
  	    }
  	    return newMap === set._map ? set :
  	      newMap.size === 0 ? set.__empty() :
  	      set.__make(newMap);
  	  }

  	  function makeSet(map, ownerID) {
  	    var set = Object.create(SetPrototype);
  	    set.size = map ? map.size : 0;
  	    set._map = map;
  	    set.__ownerID = ownerID;
  	    return set;
  	  }

  	  var EMPTY_SET;
  	  function emptySet() {
  	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  	  }

  	  createClass(OrderedSet, Set);

  	    // @pragma Construction

  	    function OrderedSet(value) {
  	      return value === null || value === undefined ? emptyOrderedSet() :
  	        isOrderedSet(value) ? value :
  	        emptyOrderedSet().withMutations(function(set ) {
  	          var iter = SetIterable(value);
  	          assertNotInfinite(iter.size);
  	          iter.forEach(function(v ) {return set.add(v)});
  	        });
  	    }

  	    OrderedSet.of = function(/*...values*/) {
  	      return this(arguments);
  	    };

  	    OrderedSet.fromKeys = function(value) {
  	      return this(KeyedIterable(value).keySeq());
  	    };

  	    OrderedSet.prototype.toString = function() {
  	      return this.__toString('OrderedSet {', '}');
  	    };


  	  function isOrderedSet(maybeOrderedSet) {
  	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  	  }

  	  OrderedSet.isOrderedSet = isOrderedSet;

  	  var OrderedSetPrototype = OrderedSet.prototype;
  	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

  	  OrderedSetPrototype.__empty = emptyOrderedSet;
  	  OrderedSetPrototype.__make = makeOrderedSet;

  	  function makeOrderedSet(map, ownerID) {
  	    var set = Object.create(OrderedSetPrototype);
  	    set.size = map ? map.size : 0;
  	    set._map = map;
  	    set.__ownerID = ownerID;
  	    return set;
  	  }

  	  var EMPTY_ORDERED_SET;
  	  function emptyOrderedSet() {
  	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
  	  }

  	  createClass(Stack, IndexedCollection);

  	    // @pragma Construction

  	    function Stack(value) {
  	      return value === null || value === undefined ? emptyStack() :
  	        isStack(value) ? value :
  	        emptyStack().unshiftAll(value);
  	    }

  	    Stack.of = function(/*...values*/) {
  	      return this(arguments);
  	    };

  	    Stack.prototype.toString = function() {
  	      return this.__toString('Stack [', ']');
  	    };

  	    // @pragma Access

  	    Stack.prototype.get = function(index, notSetValue) {
  	      var head = this._head;
  	      index = wrapIndex(this, index);
  	      while (head && index--) {
  	        head = head.next;
  	      }
  	      return head ? head.value : notSetValue;
  	    };

  	    Stack.prototype.peek = function() {
  	      return this._head && this._head.value;
  	    };

  	    // @pragma Modification

  	    Stack.prototype.push = function(/*...values*/) {
  	      if (arguments.length === 0) {
  	        return this;
  	      }
  	      var newSize = this.size + arguments.length;
  	      var head = this._head;
  	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
  	        head = {
  	          value: arguments[ii],
  	          next: head
  	        };
  	      }
  	      if (this.__ownerID) {
  	        this.size = newSize;
  	        this._head = head;
  	        this.__hash = undefined;
  	        this.__altered = true;
  	        return this;
  	      }
  	      return makeStack(newSize, head);
  	    };

  	    Stack.prototype.pushAll = function(iter) {
  	      iter = IndexedIterable(iter);
  	      if (iter.size === 0) {
  	        return this;
  	      }
  	      assertNotInfinite(iter.size);
  	      var newSize = this.size;
  	      var head = this._head;
  	      iter.reverse().forEach(function(value ) {
  	        newSize++;
  	        head = {
  	          value: value,
  	          next: head
  	        };
  	      });
  	      if (this.__ownerID) {
  	        this.size = newSize;
  	        this._head = head;
  	        this.__hash = undefined;
  	        this.__altered = true;
  	        return this;
  	      }
  	      return makeStack(newSize, head);
  	    };

  	    Stack.prototype.pop = function() {
  	      return this.slice(1);
  	    };

  	    Stack.prototype.unshift = function(/*...values*/) {
  	      return this.push.apply(this, arguments);
  	    };

  	    Stack.prototype.unshiftAll = function(iter) {
  	      return this.pushAll(iter);
  	    };

  	    Stack.prototype.shift = function() {
  	      return this.pop.apply(this, arguments);
  	    };

  	    Stack.prototype.clear = function() {
  	      if (this.size === 0) {
  	        return this;
  	      }
  	      if (this.__ownerID) {
  	        this.size = 0;
  	        this._head = undefined;
  	        this.__hash = undefined;
  	        this.__altered = true;
  	        return this;
  	      }
  	      return emptyStack();
  	    };

  	    Stack.prototype.slice = function(begin, end) {
  	      if (wholeSlice(begin, end, this.size)) {
  	        return this;
  	      }
  	      var resolvedBegin = resolveBegin(begin, this.size);
  	      var resolvedEnd = resolveEnd(end, this.size);
  	      if (resolvedEnd !== this.size) {
  	        // super.slice(begin, end);
  	        return IndexedCollection.prototype.slice.call(this, begin, end);
  	      }
  	      var newSize = this.size - resolvedBegin;
  	      var head = this._head;
  	      while (resolvedBegin--) {
  	        head = head.next;
  	      }
  	      if (this.__ownerID) {
  	        this.size = newSize;
  	        this._head = head;
  	        this.__hash = undefined;
  	        this.__altered = true;
  	        return this;
  	      }
  	      return makeStack(newSize, head);
  	    };

  	    // @pragma Mutability

  	    Stack.prototype.__ensureOwner = function(ownerID) {
  	      if (ownerID === this.__ownerID) {
  	        return this;
  	      }
  	      if (!ownerID) {
  	        this.__ownerID = ownerID;
  	        this.__altered = false;
  	        return this;
  	      }
  	      return makeStack(this.size, this._head, ownerID, this.__hash);
  	    };

  	    // @pragma Iteration

  	    Stack.prototype.__iterate = function(fn, reverse) {
  	      if (reverse) {
  	        return this.reverse().__iterate(fn);
  	      }
  	      var iterations = 0;
  	      var node = this._head;
  	      while (node) {
  	        if (fn(node.value, iterations++, this) === false) {
  	          break;
  	        }
  	        node = node.next;
  	      }
  	      return iterations;
  	    };

  	    Stack.prototype.__iterator = function(type, reverse) {
  	      if (reverse) {
  	        return this.reverse().__iterator(type);
  	      }
  	      var iterations = 0;
  	      var node = this._head;
  	      return new Iterator(function()  {
  	        if (node) {
  	          var value = node.value;
  	          node = node.next;
  	          return iteratorValue(type, iterations++, value);
  	        }
  	        return iteratorDone();
  	      });
  	    };


  	  function isStack(maybeStack) {
  	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
  	  }

  	  Stack.isStack = isStack;

  	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

  	  var StackPrototype = Stack.prototype;
  	  StackPrototype[IS_STACK_SENTINEL] = true;
  	  StackPrototype.withMutations = MapPrototype.withMutations;
  	  StackPrototype.asMutable = MapPrototype.asMutable;
  	  StackPrototype.asImmutable = MapPrototype.asImmutable;
  	  StackPrototype.wasAltered = MapPrototype.wasAltered;


  	  function makeStack(size, head, ownerID, hash) {
  	    var map = Object.create(StackPrototype);
  	    map.size = size;
  	    map._head = head;
  	    map.__ownerID = ownerID;
  	    map.__hash = hash;
  	    map.__altered = false;
  	    return map;
  	  }

  	  var EMPTY_STACK;
  	  function emptyStack() {
  	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  	  }

  	  /**
  	   * Contributes additional methods to a constructor
  	   */
  	  function mixin(ctor, methods) {
  	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
  	    Object.keys(methods).forEach(keyCopier);
  	    Object.getOwnPropertySymbols &&
  	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
  	    return ctor;
  	  }

  	  Iterable.Iterator = Iterator;

  	  mixin(Iterable, {

  	    // ### Conversion to other types

  	    toArray: function() {
  	      assertNotInfinite(this.size);
  	      var array = new Array(this.size || 0);
  	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
  	      return array;
  	    },

  	    toIndexedSeq: function() {
  	      return new ToIndexedSequence(this);
  	    },

  	    toJS: function() {
  	      return this.toSeq().map(
  	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
  	      ).__toJS();
  	    },

  	    toJSON: function() {
  	      return this.toSeq().map(
  	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
  	      ).__toJS();
  	    },

  	    toKeyedSeq: function() {
  	      return new ToKeyedSequence(this, true);
  	    },

  	    toMap: function() {
  	      // Use Late Binding here to solve the circular dependency.
  	      return Map(this.toKeyedSeq());
  	    },

  	    toObject: function() {
  	      assertNotInfinite(this.size);
  	      var object = {};
  	      this.__iterate(function(v, k)  { object[k] = v; });
  	      return object;
  	    },

  	    toOrderedMap: function() {
  	      // Use Late Binding here to solve the circular dependency.
  	      return OrderedMap(this.toKeyedSeq());
  	    },

  	    toOrderedSet: function() {
  	      // Use Late Binding here to solve the circular dependency.
  	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
  	    },

  	    toSet: function() {
  	      // Use Late Binding here to solve the circular dependency.
  	      return Set(isKeyed(this) ? this.valueSeq() : this);
  	    },

  	    toSetSeq: function() {
  	      return new ToSetSequence(this);
  	    },

  	    toSeq: function() {
  	      return isIndexed(this) ? this.toIndexedSeq() :
  	        isKeyed(this) ? this.toKeyedSeq() :
  	        this.toSetSeq();
  	    },

  	    toStack: function() {
  	      // Use Late Binding here to solve the circular dependency.
  	      return Stack(isKeyed(this) ? this.valueSeq() : this);
  	    },

  	    toList: function() {
  	      // Use Late Binding here to solve the circular dependency.
  	      return List(isKeyed(this) ? this.valueSeq() : this);
  	    },


  	    // ### Common JavaScript methods and properties

  	    toString: function() {
  	      return '[Iterable]';
  	    },

  	    __toString: function(head, tail) {
  	      if (this.size === 0) {
  	        return head + tail;
  	      }
  	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
  	    },


  	    // ### ES6 Collection methods (ES6 Array and Map)

  	    concat: function() {var values = SLICE$0.call(arguments, 0);
  	      return reify(this, concatFactory(this, values));
  	    },

  	    includes: function(searchValue) {
  	      return this.some(function(value ) {return is(value, searchValue)});
  	    },

  	    entries: function() {
  	      return this.__iterator(ITERATE_ENTRIES);
  	    },

  	    every: function(predicate, context) {
  	      assertNotInfinite(this.size);
  	      var returnValue = true;
  	      this.__iterate(function(v, k, c)  {
  	        if (!predicate.call(context, v, k, c)) {
  	          returnValue = false;
  	          return false;
  	        }
  	      });
  	      return returnValue;
  	    },

  	    filter: function(predicate, context) {
  	      return reify(this, filterFactory(this, predicate, context, true));
  	    },

  	    find: function(predicate, context, notSetValue) {
  	      var entry = this.findEntry(predicate, context);
  	      return entry ? entry[1] : notSetValue;
  	    },

  	    forEach: function(sideEffect, context) {
  	      assertNotInfinite(this.size);
  	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
  	    },

  	    join: function(separator) {
  	      assertNotInfinite(this.size);
  	      separator = separator !== undefined ? '' + separator : ',';
  	      var joined = '';
  	      var isFirst = true;
  	      this.__iterate(function(v ) {
  	        isFirst ? (isFirst = false) : (joined += separator);
  	        joined += v !== null && v !== undefined ? v.toString() : '';
  	      });
  	      return joined;
  	    },

  	    keys: function() {
  	      return this.__iterator(ITERATE_KEYS);
  	    },

  	    map: function(mapper, context) {
  	      return reify(this, mapFactory(this, mapper, context));
  	    },

  	    reduce: function(reducer, initialReduction, context) {
  	      assertNotInfinite(this.size);
  	      var reduction;
  	      var useFirst;
  	      if (arguments.length < 2) {
  	        useFirst = true;
  	      } else {
  	        reduction = initialReduction;
  	      }
  	      this.__iterate(function(v, k, c)  {
  	        if (useFirst) {
  	          useFirst = false;
  	          reduction = v;
  	        } else {
  	          reduction = reducer.call(context, reduction, v, k, c);
  	        }
  	      });
  	      return reduction;
  	    },

  	    reduceRight: function(reducer, initialReduction, context) {
  	      var reversed = this.toKeyedSeq().reverse();
  	      return reversed.reduce.apply(reversed, arguments);
  	    },

  	    reverse: function() {
  	      return reify(this, reverseFactory(this, true));
  	    },

  	    slice: function(begin, end) {
  	      return reify(this, sliceFactory(this, begin, end, true));
  	    },

  	    some: function(predicate, context) {
  	      return !this.every(not(predicate), context);
  	    },

  	    sort: function(comparator) {
  	      return reify(this, sortFactory(this, comparator));
  	    },

  	    values: function() {
  	      return this.__iterator(ITERATE_VALUES);
  	    },


  	    // ### More sequential methods

  	    butLast: function() {
  	      return this.slice(0, -1);
  	    },

  	    isEmpty: function() {
  	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
  	    },

  	    count: function(predicate, context) {
  	      return ensureSize(
  	        predicate ? this.toSeq().filter(predicate, context) : this
  	      );
  	    },

  	    countBy: function(grouper, context) {
  	      return countByFactory(this, grouper, context);
  	    },

  	    equals: function(other) {
  	      return deepEqual(this, other);
  	    },

  	    entrySeq: function() {
  	      var iterable = this;
  	      if (iterable._cache) {
  	        // We cache as an entries array, so we can just return the cache!
  	        return new ArraySeq(iterable._cache);
  	      }
  	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
  	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
  	      return entriesSequence;
  	    },

  	    filterNot: function(predicate, context) {
  	      return this.filter(not(predicate), context);
  	    },

  	    findEntry: function(predicate, context, notSetValue) {
  	      var found = notSetValue;
  	      this.__iterate(function(v, k, c)  {
  	        if (predicate.call(context, v, k, c)) {
  	          found = [k, v];
  	          return false;
  	        }
  	      });
  	      return found;
  	    },

  	    findKey: function(predicate, context) {
  	      var entry = this.findEntry(predicate, context);
  	      return entry && entry[0];
  	    },

  	    findLast: function(predicate, context, notSetValue) {
  	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
  	    },

  	    findLastEntry: function(predicate, context, notSetValue) {
  	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
  	    },

  	    findLastKey: function(predicate, context) {
  	      return this.toKeyedSeq().reverse().findKey(predicate, context);
  	    },

  	    first: function() {
  	      return this.find(returnTrue);
  	    },

  	    flatMap: function(mapper, context) {
  	      return reify(this, flatMapFactory(this, mapper, context));
  	    },

  	    flatten: function(depth) {
  	      return reify(this, flattenFactory(this, depth, true));
  	    },

  	    fromEntrySeq: function() {
  	      return new FromEntriesSequence(this);
  	    },

  	    get: function(searchKey, notSetValue) {
  	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
  	    },

  	    getIn: function(searchKeyPath, notSetValue) {
  	      var nested = this;
  	      // Note: in an ES6 environment, we would prefer:
  	      // for (var key of searchKeyPath) {
  	      var iter = forceIterator(searchKeyPath);
  	      var step;
  	      while (!(step = iter.next()).done) {
  	        var key = step.value;
  	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
  	        if (nested === NOT_SET) {
  	          return notSetValue;
  	        }
  	      }
  	      return nested;
  	    },

  	    groupBy: function(grouper, context) {
  	      return groupByFactory(this, grouper, context);
  	    },

  	    has: function(searchKey) {
  	      return this.get(searchKey, NOT_SET) !== NOT_SET;
  	    },

  	    hasIn: function(searchKeyPath) {
  	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
  	    },

  	    isSubset: function(iter) {
  	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
  	      return this.every(function(value ) {return iter.includes(value)});
  	    },

  	    isSuperset: function(iter) {
  	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
  	      return iter.isSubset(this);
  	    },

  	    keyOf: function(searchValue) {
  	      return this.findKey(function(value ) {return is(value, searchValue)});
  	    },

  	    keySeq: function() {
  	      return this.toSeq().map(keyMapper).toIndexedSeq();
  	    },

  	    last: function() {
  	      return this.toSeq().reverse().first();
  	    },

  	    lastKeyOf: function(searchValue) {
  	      return this.toKeyedSeq().reverse().keyOf(searchValue);
  	    },

  	    max: function(comparator) {
  	      return maxFactory(this, comparator);
  	    },

  	    maxBy: function(mapper, comparator) {
  	      return maxFactory(this, comparator, mapper);
  	    },

  	    min: function(comparator) {
  	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
  	    },

  	    minBy: function(mapper, comparator) {
  	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
  	    },

  	    rest: function() {
  	      return this.slice(1);
  	    },

  	    skip: function(amount) {
  	      return this.slice(Math.max(0, amount));
  	    },

  	    skipLast: function(amount) {
  	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
  	    },

  	    skipWhile: function(predicate, context) {
  	      return reify(this, skipWhileFactory(this, predicate, context, true));
  	    },

  	    skipUntil: function(predicate, context) {
  	      return this.skipWhile(not(predicate), context);
  	    },

  	    sortBy: function(mapper, comparator) {
  	      return reify(this, sortFactory(this, comparator, mapper));
  	    },

  	    take: function(amount) {
  	      return this.slice(0, Math.max(0, amount));
  	    },

  	    takeLast: function(amount) {
  	      return reify(this, this.toSeq().reverse().take(amount).reverse());
  	    },

  	    takeWhile: function(predicate, context) {
  	      return reify(this, takeWhileFactory(this, predicate, context));
  	    },

  	    takeUntil: function(predicate, context) {
  	      return this.takeWhile(not(predicate), context);
  	    },

  	    valueSeq: function() {
  	      return this.toIndexedSeq();
  	    },


  	    // ### Hashable Object

  	    hashCode: function() {
  	      return this.__hash || (this.__hash = hashIterable(this));
  	    }


  	    // ### Internal

  	    // abstract __iterate(fn, reverse)

  	    // abstract __iterator(type, reverse)
  	  });

  	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  	  var IterablePrototype = Iterable.prototype;
  	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
  	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
  	  IterablePrototype.__toJS = IterablePrototype.toArray;
  	  IterablePrototype.__toStringMapper = quoteString;
  	  IterablePrototype.inspect =
  	  IterablePrototype.toSource = function() { return this.toString(); };
  	  IterablePrototype.chain = IterablePrototype.flatMap;
  	  IterablePrototype.contains = IterablePrototype.includes;

  	  mixin(KeyedIterable, {

  	    // ### More sequential methods

  	    flip: function() {
  	      return reify(this, flipFactory(this));
  	    },

  	    mapEntries: function(mapper, context) {var this$0 = this;
  	      var iterations = 0;
  	      return reify(this,
  	        this.toSeq().map(
  	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
  	        ).fromEntrySeq()
  	      );
  	    },

  	    mapKeys: function(mapper, context) {var this$0 = this;
  	      return reify(this,
  	        this.toSeq().flip().map(
  	          function(k, v)  {return mapper.call(context, k, v, this$0)}
  	        ).flip()
  	      );
  	    }

  	  });

  	  var KeyedIterablePrototype = KeyedIterable.prototype;
  	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
  	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
  	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
  	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



  	  mixin(IndexedIterable, {

  	    // ### Conversion to other types

  	    toKeyedSeq: function() {
  	      return new ToKeyedSequence(this, false);
  	    },


  	    // ### ES6 Collection methods (ES6 Array and Map)

  	    filter: function(predicate, context) {
  	      return reify(this, filterFactory(this, predicate, context, false));
  	    },

  	    findIndex: function(predicate, context) {
  	      var entry = this.findEntry(predicate, context);
  	      return entry ? entry[0] : -1;
  	    },

  	    indexOf: function(searchValue) {
  	      var key = this.keyOf(searchValue);
  	      return key === undefined ? -1 : key;
  	    },

  	    lastIndexOf: function(searchValue) {
  	      var key = this.lastKeyOf(searchValue);
  	      return key === undefined ? -1 : key;
  	    },

  	    reverse: function() {
  	      return reify(this, reverseFactory(this, false));
  	    },

  	    slice: function(begin, end) {
  	      return reify(this, sliceFactory(this, begin, end, false));
  	    },

  	    splice: function(index, removeNum /*, ...values*/) {
  	      var numArgs = arguments.length;
  	      removeNum = Math.max(removeNum | 0, 0);
  	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
  	        return this;
  	      }
  	      // If index is negative, it should resolve relative to the size of the
  	      // collection. However size may be expensive to compute if not cached, so
  	      // only call count() if the number is in fact negative.
  	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
  	      var spliced = this.slice(0, index);
  	      return reify(
  	        this,
  	        numArgs === 1 ?
  	          spliced :
  	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
  	      );
  	    },


  	    // ### More collection methods

  	    findLastIndex: function(predicate, context) {
  	      var entry = this.findLastEntry(predicate, context);
  	      return entry ? entry[0] : -1;
  	    },

  	    first: function() {
  	      return this.get(0);
  	    },

  	    flatten: function(depth) {
  	      return reify(this, flattenFactory(this, depth, false));
  	    },

  	    get: function(index, notSetValue) {
  	      index = wrapIndex(this, index);
  	      return (index < 0 || (this.size === Infinity ||
  	          (this.size !== undefined && index > this.size))) ?
  	        notSetValue :
  	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
  	    },

  	    has: function(index) {
  	      index = wrapIndex(this, index);
  	      return index >= 0 && (this.size !== undefined ?
  	        this.size === Infinity || index < this.size :
  	        this.indexOf(index) !== -1
  	      );
  	    },

  	    interpose: function(separator) {
  	      return reify(this, interposeFactory(this, separator));
  	    },

  	    interleave: function(/*...iterables*/) {
  	      var iterables = [this].concat(arrCopy(arguments));
  	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
  	      var interleaved = zipped.flatten(true);
  	      if (zipped.size) {
  	        interleaved.size = zipped.size * iterables.length;
  	      }
  	      return reify(this, interleaved);
  	    },

  	    keySeq: function() {
  	      return Range(0, this.size);
  	    },

  	    last: function() {
  	      return this.get(-1);
  	    },

  	    skipWhile: function(predicate, context) {
  	      return reify(this, skipWhileFactory(this, predicate, context, false));
  	    },

  	    zip: function(/*, ...iterables */) {
  	      var iterables = [this].concat(arrCopy(arguments));
  	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
  	    },

  	    zipWith: function(zipper/*, ...iterables */) {
  	      var iterables = arrCopy(arguments);
  	      iterables[0] = this;
  	      return reify(this, zipWithFactory(this, zipper, iterables));
  	    }

  	  });

  	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
  	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



  	  mixin(SetIterable, {

  	    // ### ES6 Collection methods (ES6 Array and Map)

  	    get: function(value, notSetValue) {
  	      return this.has(value) ? value : notSetValue;
  	    },

  	    includes: function(value) {
  	      return this.has(value);
  	    },


  	    // ### More sequential methods

  	    keySeq: function() {
  	      return this.valueSeq();
  	    }

  	  });

  	  SetIterable.prototype.has = IterablePrototype.includes;
  	  SetIterable.prototype.contains = SetIterable.prototype.includes;


  	  // Mixin subclasses

  	  mixin(KeyedSeq, KeyedIterable.prototype);
  	  mixin(IndexedSeq, IndexedIterable.prototype);
  	  mixin(SetSeq, SetIterable.prototype);

  	  mixin(KeyedCollection, KeyedIterable.prototype);
  	  mixin(IndexedCollection, IndexedIterable.prototype);
  	  mixin(SetCollection, SetIterable.prototype);


  	  // #pragma Helper functions

  	  function keyMapper(v, k) {
  	    return k;
  	  }

  	  function entryMapper(v, k) {
  	    return [k, v];
  	  }

  	  function not(predicate) {
  	    return function() {
  	      return !predicate.apply(this, arguments);
  	    }
  	  }

  	  function neg(predicate) {
  	    return function() {
  	      return -predicate.apply(this, arguments);
  	    }
  	  }

  	  function quoteString(value) {
  	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  	  }

  	  function defaultZipper() {
  	    return arrCopy(arguments);
  	  }

  	  function defaultNegComparator(a, b) {
  	    return a < b ? 1 : a > b ? -1 : 0;
  	  }

  	  function hashIterable(iterable) {
  	    if (iterable.size === Infinity) {
  	      return 0;
  	    }
  	    var ordered = isOrdered(iterable);
  	    var keyed = isKeyed(iterable);
  	    var h = ordered ? 1 : 0;
  	    var size = iterable.__iterate(
  	      keyed ?
  	        ordered ?
  	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
  	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
  	        ordered ?
  	          function(v ) { h = 31 * h + hash(v) | 0; } :
  	          function(v ) { h = h + hash(v) | 0; }
  	    );
  	    return murmurHashOfSize(size, h);
  	  }

  	  function murmurHashOfSize(size, h) {
  	    h = imul(h, 0xCC9E2D51);
  	    h = imul(h << 15 | h >>> -15, 0x1B873593);
  	    h = imul(h << 13 | h >>> -13, 5);
  	    h = (h + 0xE6546B64 | 0) ^ size;
  	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
  	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
  	    h = smi(h ^ h >>> 16);
  	    return h;
  	  }

  	  function hashMerge(a, b) {
  	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
  	  }

  	  var Immutable = {

  	    Iterable: Iterable,

  	    Seq: Seq,
  	    Collection: Collection,
  	    Map: Map,
  	    OrderedMap: OrderedMap,
  	    List: List,
  	    Stack: Stack,
  	    Set: Set,
  	    OrderedSet: OrderedSet,

  	    Record: Record,
  	    Range: Range,
  	    Repeat: Repeat,

  	    is: is,
  	    fromJS: fromJS

  	  };

  	  return Immutable;

  	}));

  	/***/ }),
  	/* 6 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/* Generic function binding utility, used by lots of our classes */

  	module.exports = {
  	  bound: [],
  	  _bindFunctions: function _bindFunctions() {
  	    this.bound.forEach(function (f) {
  	      this[f] = this[f].bind(this);
  	    }, this);
  	  }
  	};

  	/***/ }),
  	/* 7 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /**
  	   * Used as the maximum length of an array-like value.
  	   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
  	   * for more details.
  	   */
  	  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

  	  /**
  	   * Checks if `value` is a valid array-like length.
  	   *
  	   * **Note:** This function is based on ES `ToLength`. See the
  	   * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
  	   * for more details.
  	   *
  	   * @private
  	   * @param {*} value The value to check.
  	   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
  	   */
  	  function isLength(value) {
  	    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  	  }

  	  return isLength;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 8 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var ScribeInterface = __webpack_require__(68);

  	var config = __webpack_require__(2);

  	var utils = __webpack_require__(1);

  	var Dom = __webpack_require__(3);

  	var Events = __webpack_require__(10);

  	var BlockMixins = __webpack_require__(65);

  	var SimpleBlock = __webpack_require__(87);

  	var BlockReorder = __webpack_require__(39);

  	var BlockDeletion = __webpack_require__(83);

  	var BlockPositioner = __webpack_require__(81);

  	var EventBus = __webpack_require__(4);

  	var _require = __webpack_require__(226),
  	    Spinner = _require.Spinner;

  	var _require2 = __webpack_require__(16),
  	    trimScribeContent = _require2.trimScribeContent;

  	var DELETE_TEMPLATE = __webpack_require__(227);

  	var Block = function Block(data, instance_id, mediator, options, editorOptions) {
  	  SimpleBlock.apply(this, arguments);
  	};

  	Block.prototype = Object.create(SimpleBlock.prototype);
  	Block.prototype.constructor = Block;
  	Object.assign(Block.prototype, SimpleBlock.fn, __webpack_require__(84), {
  	  bound: ["_handleContentPaste", "_onFocus", "_onBlur", "onDrop", "onDeleteClick", "clearInsertedStyles", "getSelectionForFormatter", "onBlockRender", "onDeleteConfirm", "onPositionerClick"],
  	  className: 'st-block',
  	  attributes: function attributes() {
  	    return Object.assign(SimpleBlock.fn.attributes.call(this));
  	  },
  	  icon_name: 'default',
  	  validationFailMsg: function validationFailMsg() {
  	    return i18n.t('errors:validation_fail', {
  	      type: _.isFunction(this.title) ? this.title() : this.title
  	    });
  	  },
  	  editorHTML: "<div class=\"st-block__editor\"></div>",
  	  toolbarEnabled: true,
  	  availableMixins: ['droppable', 'pastable', 'uploadable', 'fetchable', 'ajaxable', 'controllable', 'multi_editable', 'textable'],
  	  droppable: false,
  	  pastable: false,
  	  uploadable: false,
  	  fetchable: false,
  	  ajaxable: false,
  	  mergeable: false,
  	  multi_editable: false,
  	  textable: false,
  	  drop_options: {},
  	  paste_options: {},
  	  upload_options: {},
  	  formattable: true,
  	  supressKeyListeners: false,
  	  _previousSelection: '',
  	  initialize: function initialize() {},
  	  toMarkdown: function toMarkdown(markdown) {
  	    return markdown;
  	  },
  	  toHTML: function toHTML(html) {
  	    return html;
  	  },
  	  withMixin: function withMixin(mixin) {
  	    if (!_.isObject(mixin)) {
  	      return;
  	    }

  	    var initializeMethod = "initialize" + mixin.mixinName;

  	    if (_.isUndefined(this[initializeMethod])) {
  	      Object.assign(this, mixin);
  	      this[initializeMethod]();
  	    }
  	  },
  	  render: function render() {
  	    this.beforeBlockRender();

  	    this._setBlockInner();

  	    this.editor = this.inner.children[0];
  	    this.mixinsRequireInputs = false;
  	    this.availableMixins.forEach(function (mixin) {
  	      if (this[mixin]) {
  	        var blockMixin = BlockMixins[utils.classify(mixin)];

  	        if (!_.isUndefined(blockMixin.requireInputs) && blockMixin.requireInputs) {
  	          this.mixinsRequireInputs = true;
  	        }
  	      }
  	    }, this);

  	    if (this.mixinsRequireInputs) {
  	      var input_html = document.createElement("div");
  	      input_html.classList.add('st-block__inputs');
  	      this.inner.appendChild(input_html);
  	      this.inputs = input_html;
  	    }

  	    if (this.hasTextBlock()) {
  	      this._initTextBlocks();
  	    }

  	    this.availableMixins.forEach(function (mixin) {
  	      if (this[mixin]) {
  	        this.withMixin(BlockMixins[utils.classify(mixin)]);
  	      }
  	    }, this);

  	    if (this.formattable) {
  	      this._initFormatting();
  	    }

  	    this._blockPrepare();

  	    return this;
  	  },
  	  remove: function remove() {
  	    if (this.ajaxable) {
  	      this.resolveAllInQueue();
  	    }

  	    Dom.remove(this.el);
  	  },
  	  loading: function loading() {
  	    if (!_.isUndefined(this.spinner)) {
  	      this.ready();
  	    }

  	    this.spinner = new Spinner(config.defaults.spinner);
  	    this.spinner.spin(this.el);
  	    this.el.classList.add('st--is-loading');
  	  },
  	  ready: function ready() {
  	    this.el.classList.remove('st--is-loading');

  	    if (!_.isUndefined(this.spinner)) {
  	      this.spinner.stop();
  	      delete this.spinner;
  	    }
  	  },
  	  //Generic _serializeData implementation to serialize the block into a plain object.
  	  //Can be overwritten, although hopefully this will cover most situations.
  	  //If you want to get the data of your block use block.getBlockData()
  	  // jshint maxdepth:4
  	  _serializeData: function _serializeData() {
  	    utils.log("toData for " + this.blockID);
  	    var data = {}; //[> Simple to start. Add conditions later <]

  	    if (this.hasTextBlock()) {
  	      data.text = this.getTextBlockHTML();
  	      data.format = 'html';
  	    } // Add any inputs to the data attr


  	    var matcher = ['input:not([class="st-paste-block"])', 'textarea:not([class="st-paste-block"])', 'select:not([class="st-paste-block"])', 'button:not([class="st-paste-block"])'].join(",");

  	    if (this.$(matcher).length > 0) {
  	      Array.prototype.forEach.call(this.$('input, textarea, select, button'), function (input) {
  	        // Reference elements by their `name` attribute. For elements such as radio buttons
  	        // which require a unique reference per group of elements a `data-name` attribute can
  	        // be used to provide the same `name` per block.
  	        var name = input.getAttribute('data-name') || input.getAttribute('name');

  	        if (name) {
  	          if (input.getAttribute('type') === 'number') {
  	            data[name] = parseInt(input.value);
  	          } else if (input.getAttribute('type') === 'checkbox') {
  	            var value = "";

  	            if (input.getAttribute('data-toggle') || input.getAttribute('data-bs-toggle')) {
  	              value = "off";

  	              if (input.checked === true) {
  	                value = "on";
  	              }
  	            } else if (input.checked === true) {
  	              value = input.value;
  	            }

  	            data[name] = value;
  	          } else if (input.getAttribute('type') === 'radio') {
  	            if (input.checked === true) {
  	              data[name] = input.value;
  	            }
  	          } else {
  	            data[name] = input.value;
  	          }
  	        }
  	      });
  	    }

  	    return data;
  	  },
  	  //[> Generic implementation to tell us when the block is active <]
  	  focus: function focus() {
  	    Array.prototype.forEach.call(this.getTextBlock(), function (el) {
  	      el.focus();
  	    });
  	  },
  	  focusAtStart: function focusAtStart() {
  	    this.focus();
  	  },
  	  focusAtEnd: function focusAtEnd() {
  	    this.focus();
  	  },
  	  blur: function blur() {
  	    Array.prototype.forEach.call(this.getTextBlock(), function (el) {
  	      el.blur();
  	    });
  	  },
  	  onFocus: function onFocus() {
  	    var _this = this;

  	    Array.prototype.forEach.call(this.getTextBlock(), function (el) {
  	      el.addEventListener('focus', _this._onFocus);
  	    });
  	  },
  	  onBlur: function onBlur() {
  	    var _this2 = this;

  	    Array.prototype.forEach.call(this.getTextBlock(), function (el) {
  	      el.addEventListener('blur', _this2._onBlur);
  	    });
  	  },
  	  //Event handlers
  	  _onFocus: function _onFocus() {
  	    this.trigger('blockFocus', this.el);
  	  },
  	  _onBlur: function _onBlur() {},
  	  onDrop: function onDrop(dataTransferObj) {},
  	  onDeleteConfirm: function onDeleteConfirm(e) {
  	    e.preventDefault();
  	    this.mediator.trigger('block:remove', this.blockID, {
  	      focusOnPrevious: true
  	    });
  	  },
  	  // REFACTOR: have one set of delete controls that moves around like the
  	  // block controls?
  	  addDeleteControls: function addDeleteControls() {
  	    var _this3 = this;

  	    var onDeleteDeny = function onDeleteDeny(e) {
  	      e.preventDefault();

  	      _this3.deleteEl.classList.remove("active");
  	    };

  	    this.ui.insertAdjacentHTML("beforeend", DELETE_TEMPLATE());
  	    Events.delegate(this.el, ".js-st-block-confirm-delete", "click", this.onDeleteConfirm);
  	    Events.delegate(this.el, ".js-st-block-deny-delete", "click", onDeleteDeny);
  	  },
  	  onDeleteClick: function onDeleteClick(e) {
  	    e.preventDefault();
  	    e.stopPropagation();

  	    if (this.isEmpty()) {
  	      this.onDeleteConfirm.call(this, new CustomEvent('click'));
  	      return;
  	    }

  	    this.deleteEl = this.el.querySelector('.st-block__ui-delete-controls');
  	    this.deleteEl.classList.toggle('active');
  	  },
  	  onPositionerClick: function onPositionerClick(e) {
  	    e.preventDefault();
  	    this.positioner.toggle();
  	  },
  	  beforeLoadingData: function beforeLoadingData() {
  	    this.loading();

  	    if (this.mixinsRequireInputs) {
  	      Dom.show(this.editor);
  	      Dom.hide(this.inputs);
  	    }

  	    SimpleBlock.fn.beforeLoadingData.call(this);
  	    this.ready();
  	  },
  	  execTextBlockCommand: function execTextBlockCommand(cmdName) {
  	    if (_.isUndefined(this._scribe)) {
  	      throw "No Scribe instance found to send a command to";
  	    }

  	    return ScribeInterface.execTextBlockCommand(this._scribe, cmdName);
  	  },
  	  queryTextBlockCommandState: function queryTextBlockCommandState(cmdName) {
  	    if (_.isUndefined(this._scribe)) {
  	      throw "No Scribe instance found to query command";
  	    }

  	    return ScribeInterface.queryTextBlockCommandState(this._scribe, cmdName);
  	  },
  	  _handleContentPaste: function _handleContentPaste(ev) {
  	    setTimeout(this.onContentPasted.bind(this, ev, ev.currentTarget), 0);
  	  },
  	  _getBlockClass: function _getBlockClass() {
  	    return 'st-block--' + this.className;
  	  },
  	  //Init functions for adding functionality
  	  _initUIComponents: function _initUIComponents() {
  	    this.addDeleteControls();
  	    this.positioner = new BlockPositioner(this.el, this.mediator);

  	    this._withUIComponent(this.positioner, '.st-block-ui-btn__reorder', this.onPositionerClick);

  	    this._withUIComponent(new BlockReorder(this.el, this.mediator));

  	    this._withUIComponent(new BlockDeletion(), '.st-block-ui-btn__delete', this.onDeleteClick);

  	    this.onFocus();
  	    this.onBlur();
  	  },
  	  _initFormatting: function _initFormatting() {
  	    // Enable formatting keyboard input
  	    var block = this;

  	    if (!this.options.formatBar) {
  	      return;
  	    }

  	    this.options.formatBar.commands.forEach(function (cmd) {
  	      if (_.isUndefined(cmd.keyCode)) {
  	        return;
  	      }

  	      Events.delegate(block.el, '.st-text-block', 'keydown', function (ev) {
  	        if ((ev.metaKey || ev.ctrlKey) && ev.keyCode === cmd.keyCode) {
  	          ev.preventDefault();
  	          block.execTextBlockCommand(cmd.cmd);
  	        }
  	      });
  	    });
  	  },
  	  _initTextBlocks: function _initTextBlocks() {
  	    var _this4 = this;

  	    Array.prototype.forEach.call(this.getTextBlock(), function (el) {
  	      el.addEventListener('keyup', _this4.getSelectionForFormatter);
  	      el.addEventListener('mousedown', _this4.addMouseupListener.bind(_this4));
  	      el.addEventListener('DOMNodeInserted', _this4.clearInsertedStyles);
  	    });
  	    var textBlock = this.getTextBlock()[0];

  	    if (!_.isUndefined(textBlock) && _.isUndefined(this._scribe)) {
  	      var configureScribe = _.isFunction(this.configureScribe) ? this.configureScribe.bind(this) : null;
  	      this._scribe = ScribeInterface.initScribeInstance(textBlock, this.scribeOptions, configureScribe);
  	    }
  	  },
  	  addMouseupListener: function addMouseupListener() {
  	    var _this5 = this;

  	    var listener = function listener() {
  	      _this5.getSelectionForFormatter();

  	      window.removeEventListener('mouseup', listener);
  	    };

  	    window.addEventListener('mouseup', listener);
  	  },
  	  getSelectionForFormatter: function getSelectionForFormatter() {
  	    var _this6 = this;

  	    setTimeout(function () {
  	      var selection = window.getSelection(),
  	          selectionStr = selection.toString().trim(),
  	          en = 'formatter:' + (selectionStr === '' ? 'hide' : 'position');

  	      _this6.mediator.trigger(en, _this6);

  	      EventBus.trigger(en, _this6);
  	    }, 1);
  	  },
  	  clearInsertedStyles: function clearInsertedStyles(e) {
  	    var target = e.target;

  	    if (_.isUndefined(target.tagName)) {
  	      target = target.parentNode;
  	    }

  	    target.removeAttribute('style'); // Hacky fix for Chrome.
  	  },
  	  hasTextBlock: function hasTextBlock() {
  	    return this.getTextBlock().length > 0;
  	  },
  	  getTextBlock: function getTextBlock() {
  	    if (_.isUndefined(this.text_block)) {
  	      this.text_block = this.$('.st-text-block');
  	    }

  	    return this.text_block;
  	  },
  	  getTextBlockHTML: function getTextBlockHTML() {
  	    return this._scribe.getContent();
  	  },
  	  setTextBlockHTML: function setTextBlockHTML(html) {
  	    var returnVal = this._scribe.setContent(html);

  	    trimScribeContent(this._scribe);
  	    return returnVal;
  	  },
  	  isEmpty: function isEmpty() {
  	    return _.isEmpty(this.getBlockData());
  	  },
  	  select: function select(selected) {
  	    this.el.classList.toggle("st-block--is-selected", selected);
  	  },
  	  split: function split() {},
  	  asClipboardHTML: function asClipboardHTML() {}
  	});
  	Block.extend = __webpack_require__(89); // Allow our Block to be extended.

  	module.exports = Block;

  	/***/ }),
  	/* 9 */
  	/***/ (function(module, exports, __webpack_require__) {


  	module.exports = __webpack_require__(141);

  	/***/ }),
  	/* 10 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var Dom = __webpack_require__(3);

  	var fixEvent = function fixEvent(e, target) {
  	  var obj = {}; // Events don't work as normal objects, so need to copy properties directly.
  	  // List and matchers taken from jQuery.Event.fix.
  	  // For other properties refer to the originalEvent object.

  	  var props = {
  	    shared: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),
  	    mouseEvent: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
  	    keyEvent: "char charCode key keyCode".split(" ")
  	  };
  	  var rkeyEvent = /^key/,
  	      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
  	  var propsToCopy = rmouseEvent.test(e.type) ? props.shared.concat(props.mouseEvent) : rkeyEvent.test(e.type) ? props.shared.concat(props.keyEvent) : props.shared;
  	  var prop;

  	  for (var i = 0; i < propsToCopy.length; i++) {
  	    prop = propsToCopy[i];
  	    obj[prop] = e[prop];
  	  }

  	  obj.currentTarget = target;
  	  obj.originalEvent = e;

  	  obj.preventDefault = function () {
  	    if (this.originalEvent) {
  	      this.originalEvent.preventDefault();
  	    }
  	  };

  	  obj.stopPropagation = function () {
  	    if (this.originalEvent) {
  	      this.originalEvent.stopPropagation();
  	    }
  	  };

  	  return obj;
  	};

  	module.exports.delegate = function delegate(el, selector, event, fn) {
  	  var useCapture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  	  el.addEventListener(event, function (e) {
  	    var target = e.target;

  	    for (target; target && target !== el; target = target.parentNode) {
  	      if (Dom.matches(target, selector)) {
  	        fn.call(target, fixEvent(e, target));
  	        break;
  	      }
  	    }

  	    target = null;
  	  }, useCapture);
  	};

  	/***/ }),
  	/* 11 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var Dom = __webpack_require__(3);

  	module.exports = {
  	  tagName: 'div',
  	  className: 'sir-trevor__view',
  	  attributes: {},
  	  $: function $(selector) {
  	    return this.el.querySelectorAll(selector);
  	  },
  	  render: function render() {
  	    return this;
  	  },
  	  destroy: function destroy() {
  	    if (!_.isUndefined(this.stopListening)) {
  	      this.stopListening();
  	    }

  	    Dom.remove(this.el);
  	  },
  	  _ensureElement: function _ensureElement() {
  	    if (!this.el) {
  	      var attrs = Object.assign({}, _.result(this, 'attributes'));

  	      if (this.id) {
  	        attrs.id = this.id;
  	      }

  	      if (this.className) {
  	        attrs['class'] = this.className;
  	      }

  	      var el = Dom.createElement(this.tagName, attrs);

  	      this._setElement(el);
  	    } else {
  	      this._setElement(this.el);
  	    }
  	  },
  	  _setElement: function _setElement(element) {
  	    this.el = element;
  	    return this;
  	  }
  	};

  	/***/ }),
  	/* 12 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var isNative = __webpack_require__(25),
  	    isObject = __webpack_require__(18),
  	    shimKeys = __webpack_require__(128);

  	/* Native method shortcuts for methods with the same name as other `lodash` methods */
  	var nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;

  	/**
  	 * Creates an array composed of the own enumerable property names of an object.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Objects
  	 * @param {Object} object The object to inspect.
  	 * @returns {Array} Returns an array of property names.
  	 * @example
  	 *
  	 * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
  	 * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
  	 */
  	var keys = !nativeKeys ? shimKeys : function(object) {
  	  if (!isObject(object)) {
  	    return [];
  	  }
  	  return nativeKeys(object);
  	};

  	module.exports = keys;


  	/***/ }),
  	/* 13 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Module Dependencies
  	 */

  	var iterator = __webpack_require__(151);
  	var selection = window.getSelection();

  	/**
  	 * Expose position fn
  	 */

  	module.exports = position;

  	/**
  	 * Get or set cursor, selection, relative to
  	 * an element.
  	 *
  	 * @param  {Element} el
  	 * @param  {Object} pos selection range
  	 * @return {Object|Undefined}
  	 */

  	function position(el, pos){

  	  /**
  	   * Get cursor or selection position
  	   */

  	  if (1 == arguments.length) {
  	    if (!selection.rangeCount) return;
  	    var indexes = {};
  	    var range = selection.getRangeAt(0);
  	    var clone = range.cloneRange();
  	    clone.selectNodeContents(el);
  	    clone.setEnd(range.endContainer, range.endOffset);
  	    indexes.end = clone.toString().length;
  	    clone.setStart(range.startContainer, range.startOffset);
  	    indexes.start = indexes.end - clone.toString().length;
  	    indexes.atStart = clone.startOffset === 0;
  	    return indexes;
  	  }

  	  /**
  	   * Set cursor or selection position
  	   */

  	  var setSelection = pos.end && (pos.end !== pos.start);
  	  var length = 0;
  	  var range = document.createRange();
  	  var it = iterator(el).select(Node.TEXT_NODE).revisit(false);
  	  var next;
  	  var startindex;
  	  var start = pos.start > el.textContent.length ? el.textContent.length : pos.start;
  	  var end = pos.end > el.textContent.length ? el.textContent.length : pos.end;
  	  var atStart = pos.atStart;

  	  while (next = it.next()){
  	    var olen = length;
  	    length += next.textContent.length;

  	    // Set start point of selection
  	    var atLength = atStart ? length > start : length >= start;
  	    if (!startindex && atLength) {
  	      startindex = true;
  	      range.setStart(next, start - olen);
  	      if (!setSelection) {
  	        range.collapse(true);
  	        makeSelection(el, range);
  	        break;
  	      }
  	    }

  	    // Set end point of selection
  	    if (setSelection && (length >= end)) {
  	      range.setEnd(next, end - olen);
  	      makeSelection(el, range);
  	      break;
  	    }
  	  }
  	}

  	/**
  	 * add selection / insert cursor.
  	 *
  	 * @param  {Element} el
  	 * @param  {Range} range
  	 */

  	function makeSelection(el, range){
  	  el.focus();
  	  selection.removeAllRanges();
  	  selection.addRange(range);
  	}


  	/***/ }),
  	/* 14 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /**
  	   * Checks if `value` is the language type of `Object`.
  	   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
  	   *
  	   * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Lang
  	   * @param {*} value The value to check.
  	   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
  	   * @example
  	   *
  	   * _.isObject({});
  	   * // => true
  	   *
  	   * _.isObject([1, 2, 3]);
  	   * // => true
  	   *
  	   * _.isObject(1);
  	   * // => false
  	   */
  	  function isObject(value) {
  	    // Avoid a V8 JIT bug in Chrome 19-20.
  	    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  	    var type = typeof value;
  	    return type == 'function' || (value && type == 'object') || false;
  	  }

  	  return isObject;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 15 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /**
  	   * Checks if `value` is object-like.
  	   *
  	   * @private
  	   * @param {*} value The value to check.
  	   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
  	   */
  	  function isObjectLike(value) {
  	    return (value && typeof value == 'object') || false;
  	  }

  	  return isObjectLike;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 16 */
  	/***/ (function(module, __webpack_exports__, __webpack_require__) {
  	__webpack_require__.r(__webpack_exports__);
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBlocksFromParagraphs", function() { return createBlocksFromParagraphs; });
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTotalLength", function() { return getTotalLength; });
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAtStart", function() { return isAtStart; });
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAtEnd", function() { return isAtEnd; });
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectToEnd", function() { return selectToEnd; });
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSelectedFromStart", function() { return isSelectedFromStart; });
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSelectedToEnd", function() { return isSelectedToEnd; });
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rangeToHTML", function() { return rangeToHTML; });
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trimScribeContent", function() { return trimScribeContent; });


  	var selectionRange = __webpack_require__(13);

  	var utils = __webpack_require__(1);

  	var selectToEnd = function selectToEnd(scribe) {
  	  var selection = new scribe.api.Selection();
  	  var range = selection.range.cloneRange();
  	  range.setEndAfter(scribe.el.lastChild, 0);
  	  return range;
  	};

  	var isAtStart = function isAtStart(scribe) {
  	  var currentRange = selectionRange(scribe.el);
  	  return currentRange.start === 0 && currentRange.end === 0 && currentRange.atStart;
  	};

  	var getTotalLength = function getTotalLength(scribe) {
  	  var selection = new scribe.api.Selection();
  	  var range = selection.range.cloneRange();
  	  range.selectNodeContents(scribe.el);
  	  return range.toString().length;
  	};

  	var isAtEnd = function isAtEnd(scribe) {
  	  var currentRange = selectionRange(scribe.el);
  	  return getTotalLength(scribe) === currentRange.end && currentRange.start === currentRange.end;
  	};

  	var isSelectedToEnd = function isSelectedToEnd(scribe) {
  	  var currentRange = selectionRange(scribe.el);
  	  return getTotalLength(scribe) === currentRange.end;
  	};

  	var isSelectedFromStart = function isSelectedFromStart(scribe) {
  	  var currentRange = selectionRange(scribe.el);
  	  return currentRange.atStart && currentRange.start === 0;
  	}; // Remove any empty elements at the start of the range.


  	var stripFirstEmptyElement = function stripFirstEmptyElement(div) {
  	  if (div.firstChild === null) {
  	    return;
  	  }

  	  var firstChild = div.firstChild.childNodes[0];

  	  if (firstChild && firstChild.nodeName !== '#text') {
  	    if (firstChild.innerText === '') {
  	      div.firstChild.removeChild(firstChild);
  	    }
  	  }
  	};

  	var createBlocksFromParagraphs = function createBlocksFromParagraphs(block, scribe) {
  	  var fakeContent = document.createElement('div');
  	  fakeContent.appendChild(selectToEnd(scribe).extractContents());
  	  stripFirstEmptyElement(fakeContent); // Add wrapper div which is missing in non blockElement scribe.

  	  if (!scribe.allowsBlockElements()) {
  	    var tempContent = document.createElement('div');
  	    tempContent.appendChild(fakeContent);
  	    fakeContent = tempContent;
  	  }

  	  if (fakeContent.childNodes.length >= 1) {
  	    var data;
  	    var nodes = [].slice.call(fakeContent.childNodes);
  	    nodes.reverse().forEach(function (node) {
  	      if (node.innerText !== '') {
  	        data = {
  	          format: 'html',
  	          text: node.innerHTML.trim()
  	        };
  	        block.mediator.trigger("block:create", block.type, data, block.el, {
  	          autoFocus: true
  	        });
  	      }
  	    });
  	  }
  	};

  	var rangeToHTML = function rangeToHTML(range) {
  	  var div = document.createElement('div');
  	  div.appendChild(range.extractContents());
  	  return div.innerHTML;
  	};

  	var trimScribeContent = function trimScribeContent(scribe) {
  	  // Remove any whitespace in the first node, otherwise selections won't work.
  	  var firstNode = scribe.node.firstDeepestChild(scribe.el);

  	  if (firstNode.nodeName === '#text') {
  	    firstNode.textContent = utils.leftTrim(firstNode.textContent);
  	  } // Remove all empty nodes at the front to get blocks working.
  	  // Don't remove nodes that can't contain text content (e.g. <input>)


  	  while (scribe.el.firstChild && scribe.el.firstChild.textContent === '' && document.createElement(scribe.el.firstChild.tagName).outerHTML.indexOf("/") != -1) {
  	    scribe.el.removeChild(scribe.el.firstChild);
  	  } // Remove all empty nodes at the end to get blocks working.
  	  // Don't remove nodes that can't contain text content (e.g. <input>)


  	  while (scribe.el.lastChild && scribe.el.lastChild.textContent === '' && document.createElement(scribe.el.lastChild.tagName).outerHTML.indexOf("/") != -1) {
  	    scribe.el.removeChild(scribe.el.lastChild);
  	  } // Firefox adds empty br tags at the end of content.


  	  while (scribe.el.lastChild && scribe.el.lastChild.nodeName === 'BR') {
  	    scribe.el.removeChild(scribe.el.lastChild);
  	  }
  	};



  	/***/ }),
  	/* 17 */
  	/***/ (function(module, exports) {

  	var g;

  	// This works in non-strict mode
  	g = (function() {
  		return this;
  	})();

  	try {
  		// This works if eval is allowed (see CSP)
  		g = g || new Function("return this")();
  	} catch (e) {
  		// This works if the window reference is available
  		if (typeof window === "object") g = window;
  	}

  	// g can still be undefined, but nothing to do about it...
  	// We return undefined, instead of nothing here, so it's
  	// easier to handle this case. if(!global) { ...}

  	module.exports = g;


  	/***/ }),
  	/* 18 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var objectTypes = __webpack_require__(26);

  	/**
  	 * Checks if `value` is the language type of Object.
  	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Objects
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
  	 * @example
  	 *
  	 * _.isObject({});
  	 * // => true
  	 *
  	 * _.isObject([1, 2, 3]);
  	 * // => true
  	 *
  	 * _.isObject(1);
  	 * // => false
  	 */
  	function isObject(value) {
  	  // check if the value is the ECMAScript language type of Object
  	  // http://es5.github.io/#x8
  	  // and avoid a V8 bug
  	  // http://code.google.com/p/v8/issues/detail?id=2291
  	  return !!(value && objectTypes[typeof value]);
  	}

  	module.exports = isObject;


  	/***/ }),
  	/* 19 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202), __webpack_require__(15)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(escapeRegExp, isObjectLike) {

  	  /** `Object#toString` result references. */
  	  var funcTag = '[object Function]';

  	  /** Used to detect host constructors (Safari > 5). */
  	  var reHostCtor = /^\[object .+?Constructor\]$/;

  	  /** Used for native method references. */
  	  var objectProto = Object.prototype;

  	  /** Used to resolve the decompiled source of functions. */
  	  var fnToString = Function.prototype.toString;

  	  /**
  	   * Used to resolve the `toStringTag` of values.
  	   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
  	   * for more details.
  	   */
  	  var objToString = objectProto.toString;

  	  /** Used to detect if a method is native. */
  	  var reNative = RegExp('^' +
  	    escapeRegExp(objToString)
  	    .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  	  );

  	  /**
  	   * Checks if `value` is a native function.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Lang
  	   * @param {*} value The value to check.
  	   * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
  	   * @example
  	   *
  	   * _.isNative(Array.prototype.push);
  	   * // => true
  	   *
  	   * _.isNative(_);
  	   * // => false
  	   */
  	  function isNative(value) {
  	    if (value == null) {
  	      return false;
  	    }
  	    if (objToString.call(value) == funcTag) {
  	      return reNative.test(fnToString.call(value));
  	    }
  	    return (isObjectLike(value) && reHostCtor.test(value)) || false;
  	  }

  	  return isNative;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 20 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7), __webpack_require__(19), __webpack_require__(15)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(isLength, isNative, isObjectLike) {

  	  /** `Object#toString` result references. */
  	  var arrayTag = '[object Array]';

  	  /** Used for native method references. */
  	  var objectProto = Object.prototype;

  	  /**
  	   * Used to resolve the `toStringTag` of values.
  	   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
  	   * for more details.
  	   */
  	  var objToString = objectProto.toString;

  	  /* Native method references for those with the same name as other `lodash` methods. */
  	  var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;

  	  /**
  	   * Checks if `value` is classified as an `Array` object.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Lang
  	   * @param {*} value The value to check.
  	   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
  	   * @example
  	   *
  	   * _.isArray([1, 2, 3]);
  	   * // => true
  	   *
  	   * _.isArray(function() { return arguments; }());
  	   * // => false
  	   */
  	  var isArray = nativeIsArray || function(value) {
  	    return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
  	  };

  	  return isArray;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 21 */
  	/***/ (function(module, exports, __webpack_require__) {


  	module.exports = {
  	  Text: __webpack_require__(222),
  	  Quote: __webpack_require__(229),
  	  Image: __webpack_require__(230),
  	  Heading: __webpack_require__(231),
  	  List: __webpack_require__(232),
  	  Tweet: __webpack_require__(234),
  	  Video: __webpack_require__(235)
  	};

  	/***/ }),
  	/* 22 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var utils = __webpack_require__(1);

  	module.exports = function (markdown, type) {
  	  // Deferring requiring these to sidestep a circular dependency:
  	  // Block -> this -> Blocks -> Block
  	  var Blocks = __webpack_require__(21); // MD -> HTML


  	  type = utils.classify(type);
  	  var html = markdown,
  	      shouldWrap = type === "Text";

  	  if (_.isUndefined(shouldWrap)) {
  	    shouldWrap = false;
  	  }

  	  if (shouldWrap) {
  	    html = "<p>" + html;
  	  }

  	  html = html.replace(/\[([^\]]+)\]\(([^\)]+)\)/gm, function (match, p1, p2) {
  	    return "<a href='" + p2 + "'>" + p1.replace(/\n/g, '') + "</a>";
  	  }); // This may seem crazy, but because JS doesn't have a look behind,
  	  // we reverse the string to regex out the italic items (and bold)
  	  // and look for something that doesn't start (or end in the reversed strings case)
  	  // with a slash.

  	  html = utils.reverse(utils.reverse(html).replace(/_(?!\\)((_\\|[^_])*)_(?=$|[^\\])/gm, function (match, p1) {
  	    return ">i/<" + p1.replace(/\n/g, '').replace(/[\s]+$/, '') + ">i<";
  	  }).replace(/\*\*(?!\\)((\*\*\\|[^\*\*])*)\*\*(?=$|[^\\])/gm, function (match, p1) {
  	    return ">b/<" + p1.replace(/\n/g, '').replace(/[\s]+$/, '') + ">b<";
  	  }));
  	  html = html.replace(/^\> (.+)$/mg, "$1"); // Use custom block toHTML functions (if any exist)

  	  var block;

  	  if (Blocks.hasOwnProperty(type)) {
  	    block = Blocks[type]; // Do we have a toHTML function?

  	    if (!_.isUndefined(block.prototype.toHTML) && _.isFunction(block.prototype.toHTML)) {
  	      html = block.prototype.toHTML(html);
  	    }
  	  }

  	  if (shouldWrap) {
  	    html = html.replace(/\n\s*\n/gm, "</p><p>");
  	    html = html.replace(/\n/gm, "<br>");
  	  }

  	  html = html.replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/\n/g, "<br>").replace(/\*\*/, "").replace(/__/, ""); // Cleanup any markdown characters left
  	  // Replace escaped

  	  html = html.replace(/\\\*/g, "*").replace(/\\\[/g, "[").replace(/\\\]/g, "]").replace(/\\\_/g, "_").replace(/\\\(/g, "(").replace(/\\\)/g, ")").replace(/\\\-/g, "-");

  	  if (shouldWrap) {
  	    html += "</p>";
  	  }

  	  return html;
  	};

  	/***/ }),
  	/* 23 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var keys = __webpack_require__(42);
  	var foreach = __webpack_require__(98);
  	var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

  	var toStr = Object.prototype.toString;

  	var isFunction = function (fn) {
  		return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
  	};

  	var arePropertyDescriptorsSupported = function () {
  		var obj = {};
  		try {
  			Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
  	        /* eslint-disable no-unused-vars, no-restricted-syntax */
  	        for (var _ in obj) { return false; }
  	        /* eslint-enable no-unused-vars, no-restricted-syntax */
  			return obj.x === obj;
  		} catch (e) { /* this is IE 8. */
  			return false;
  		}
  	};
  	var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

  	var defineProperty = function (object, name, value, predicate) {
  		if (name in object && (!isFunction(predicate) || !predicate())) {
  			return;
  		}
  		if (supportsDescriptors) {
  			Object.defineProperty(object, name, {
  				configurable: true,
  				enumerable: false,
  				value: value,
  				writable: true
  			});
  		} else {
  			object[name] = value;
  		}
  	};

  	var defineProperties = function (object, map) {
  		var predicates = arguments.length > 2 ? arguments[2] : {};
  		var props = keys(map);
  		if (hasSymbols) {
  			props = props.concat(Object.getOwnPropertySymbols(map));
  		}
  		foreach(props, function (name) {
  			defineProperty(object, name, map[name], predicates[name]);
  		});
  	};

  	defineProperties.supportsDescriptors = !!supportsDescriptors;

  	module.exports = defineProperties;


  	/***/ }),
  	/* 24 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var implementation = __webpack_require__(99);

  	module.exports = Function.prototype.bind || implementation;


  	/***/ }),
  	/* 25 */
  	/***/ (function(module, exports) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */

  	/** Used for native method references */
  	var objectProto = Object.prototype;

  	/** Used to resolve the internal [[Class]] of values */
  	var toString = objectProto.toString;

  	/** Used to detect if a method is native */
  	var reNative = RegExp('^' +
  	  String(toString)
  	    .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
  	    .replace(/toString| for [^\]]+/g, '.*?') + '$'
  	);

  	/**
  	 * Checks if `value` is a native function.
  	 *
  	 * @private
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
  	 */
  	function isNative(value) {
  	  return typeof value == 'function' && reNative.test(value);
  	}

  	module.exports = isNative;


  	/***/ }),
  	/* 26 */
  	/***/ (function(module, exports) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */

  	/** Used to determine if values are of the language type Object */
  	var objectTypes = {
  	  'boolean': false,
  	  'function': true,
  	  'object': true,
  	  'number': false,
  	  'string': false,
  	  'undefined': false
  	};

  	module.exports = objectTypes;


  	/***/ }),
  	/* 27 */
  	/***/ (function(module, exports) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */

  	/**
  	 * Slices the `collection` from the `start` index up to, but not including,
  	 * the `end` index.
  	 *
  	 * Note: This function is used instead of `Array#slice` to support node lists
  	 * in IE < 9 and to ensure dense arrays are returned.
  	 *
  	 * @private
  	 * @param {Array|Object|string} collection The collection to slice.
  	 * @param {number} start The start index.
  	 * @param {number} end The end index.
  	 * @returns {Array} Returns the new array.
  	 */
  	function slice(array, start, end) {
  	  start || (start = 0);
  	  if (typeof end == 'undefined') {
  	    end = array ? array.length : 0;
  	  }
  	  var index = -1,
  	      length = end - start || 0,
  	      result = Array(length < 0 ? 0 : length);

  	  while (++index < length) {
  	    result[index] = array[start + index];
  	  }
  	  return result;
  	}

  	module.exports = slice;


  	/***/ }),
  	/* 28 */
  	/***/ (function(module, exports) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */

  	/**
  	 * Checks if `value` is a function.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Objects
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
  	 * @example
  	 *
  	 * _.isFunction(_);
  	 * // => true
  	 */
  	function isFunction(value) {
  	  return typeof value == 'function';
  	}

  	module.exports = isFunction;


  	/***/ }),
  	/* 29 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(157),
  	  __webpack_require__(158),
  	  __webpack_require__(5)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (inlineElementNames, blockElementNames, Immutable) {

  	  function isBlockElement(node) {
  	    return blockElementNames.includes(node.nodeName);
  	  }

  	  function isInlineElement(node) {
  	    return inlineElementNames.includes(node.nodeName);
  	  }

  	  function hasContent(node) {

  	    if(node && node.children && node.children.length > 0) {
  	      return true;
  	    }

  	    if(node && node.nodeName === 'BR') {
  	      return true;
  	    }
  	    return false;
  	  }

  	  // return true if nested inline tags ultimately just contain <br> or ""
  	  function isEmptyInlineElement(node) {
  	    if( node.children.length > 1 ) return false;
  	    if( node.children.length === 1 && node.textContent.trim() !== '' ) return false;
  	    if( node.children.length === 0 ) return node.textContent.trim() === '';
  	    return isEmptyInlineElement(node.children[0]);
  	  }

  	  function isText(node) {
  	    return node.nodeType === Node.TEXT_NODE;
  	  }

  	  function isEmptyTextNode(node) {
  	    var isEmpty = false;
  	    try {
  	      isEmpty = isText(node) && node.data === '';
  	    }
  	    catch(err) {
  	      isEmpty = true;
  	    }
  	    return isEmpty;
  	  }

  	  function isFragment(node) {
  	    return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
  	  }

  	  function isBefore(node1, node2) {
  	    return node1.compareDocumentPosition(node2) & Node.DOCUMENT_POSITION_FOLLOWING;
  	  }

  	  function elementHasClass(Node, className) {
  	    return function(node) {
  	      return (node.nodeType === Node.ELEMENT_NODE && node.className === className)
  	    }
  	  }

  	  function isSelectionMarkerNode(node) {
  	    return elementHasClass(Node, 'scribe-marker')(node);
  	  }

  	  function isCaretPositionNode(node) {
  	    return elementHasClass(Node, 'caret-position')(node);
  	  }

  	  function isWhitespaceOnlyTextNode(Node, node) {
  	    if(node.nodeType === Node.TEXT_NODE
  	      && /^\s*$/.test(node.nodeValue)) {
  	      return true;
  	    }

  	    return false;

  	  }

  	  function isTextNodeWithContent(Node, node) {
  	    return node.nodeType === Node.TEXT_NODE && !isWhitespaceOnlyTextNode(Node, node);
  	  }

  	  function firstDeepestChild(node) {
  	    var fs = node.firstChild;
  	    return !fs || fs.nodeName === 'BR' ?
  	      node :
  	      firstDeepestChild(fs);
  	  }

  	  function insertAfter(newNode, referenceNode) {
  	    return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
  	  }

  	  function removeNode(node) {
  	    return node.parentNode.removeChild(node);
  	  }

  	  function getAncestor(node, rootElement, nodeFilter) {
  	    function isTopContainerElement (element) {
  	      return rootElement === element;
  	    }
  	    // TODO: should this happen here?
  	    if (isTopContainerElement(node)) {
  	      return;
  	    }

  	    var currentNode = node.parentNode;

  	    // If it's a `contenteditable` then it's likely going to be the Scribe
  	    // instance, so stop traversing there.
  	    while (currentNode && ! isTopContainerElement(currentNode)) {
  	      if (nodeFilter(currentNode)) {
  	        return currentNode;
  	      }
  	      currentNode = currentNode.parentNode;
  	    }
  	  }

  	  function nextSiblings(node) {
  	    var all = Immutable.List();
  	    while (node = node.nextSibling) {
  	      all = all.push(node);
  	    }
  	    return all;
  	  }

  	  function wrap(nodes, parentNode) {
  	    nodes[0].parentNode.insertBefore(parentNode, nodes[0]);
  	    nodes.forEach(function (node) {
  	      parentNode.appendChild(node);
  	    });
  	    return parentNode;
  	  }

  	  function unwrap(node, childNode) {
  	    while (childNode.childNodes.length > 0) {
  	      node.insertBefore(childNode.childNodes[0], childNode);
  	    }
  	    node.removeChild(childNode);
  	  }

  	  /**
  	   * Chrome: If a parent node has a CSS `line-height` when we apply the
  	   * insertHTML command, Chrome appends a SPAN to plain content with
  	   * inline styling replicating that `line-height`, and adjusts the
  	   * `line-height` on inline elements.
  	   *
  	   * As per: http://jsbin.com/ilEmudi/4/edit?css,js,output
  	   * More from the web: http://stackoverflow.com/q/15015019/40352
  	   */
  	  function removeChromeArtifacts(parentElement) {
  	    function isInlineWithStyle(parentStyle, element) {
  	      return window.getComputedStyle(element).lineHeight === parentStyle.lineHeight;
  	    }

  	    var nodes = Immutable.List(parentElement.querySelectorAll(inlineElementNames
  	      .map(function(elName) { return elName + '[style*="line-height"]' })
  	      .join(',')
  	      ));
  	    nodes = nodes.filter(isInlineWithStyle.bind(null, window.getComputedStyle(parentElement)));

  	    var emptySpans = Immutable.List();

  	    nodes.forEach(function(node) {
  	      node.style.lineHeight = null;
  	      if (node.getAttribute('style') === '') {
  	        node.removeAttribute('style');
  	      }
  	      if (node.nodeName === 'SPAN' && node.attributes.length === 0) {
  	        emptySpans = emptySpans.push(node);
  	      }
  	    });

  	    emptySpans.forEach(function(node) {
  	      unwrap(node.parentNode, node);
  	    });
  	  }

  	  return {
  	    isInlineElement: isInlineElement,
  	    isBlockElement: isBlockElement,
  	    isEmptyInlineElement: isEmptyInlineElement,
  	    isText: isText,
  	    isEmptyTextNode: isEmptyTextNode,
  	    isWhitespaceOnlyTextNode: isWhitespaceOnlyTextNode,
  	    isTextNodeWithContent: isTextNodeWithContent,
  	    isFragment: isFragment,
  	    isBefore: isBefore,
  	    isSelectionMarkerNode: isSelectionMarkerNode,
  	    isCaretPositionNode: isCaretPositionNode,
  	    firstDeepestChild: firstDeepestChild,
  	    insertAfter: insertAfter,
  	    removeNode: removeNode,
  	    getAncestor: getAncestor,
  	    nextSiblings: nextSiblings,
  	    wrap: wrap,
  	    unwrap: unwrap,
  	    removeChromeArtifacts: removeChromeArtifacts,
  	    elementHasClass: elementHasClass,
  	    hasContent: hasContent
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 30 */
  	/***/ (function(module, exports, __webpack_require__) {


  	module.exports = {
  	  mediatedEvents: {},
  	  eventNamespace: null,
  	  _bindMediatedEvents: function _bindMediatedEvents() {
  	    Object.keys(this.mediatedEvents).forEach(function (eventName) {
  	      var cb = this.mediatedEvents[eventName];
  	      eventName = this.eventNamespace ? this.eventNamespace + ':' + eventName : eventName;
  	      this.mediator.on(eventName, this[cb].bind(this));
  	    }, this);
  	  }
  	};

  	/***/ }),
  	/* 31 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var bind = __webpack_require__(24);

  	module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


  	/***/ }),
  	/* 32 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var fnToStr = Function.prototype.toString;

  	var constructorRegex = /^\s*class\b/;
  	var isES6ClassFn = function isES6ClassFunction(value) {
  		try {
  			var fnStr = fnToStr.call(value);
  			return constructorRegex.test(fnStr);
  		} catch (e) {
  			return false; // not a function
  		}
  	};

  	var tryFunctionObject = function tryFunctionToStr(value) {
  		try {
  			if (isES6ClassFn(value)) { return false; }
  			fnToStr.call(value);
  			return true;
  		} catch (e) {
  			return false;
  		}
  	};
  	var toStr = Object.prototype.toString;
  	var fnClass = '[object Function]';
  	var genClass = '[object GeneratorFunction]';
  	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

  	module.exports = function isCallable(value) {
  		if (!value) { return false; }
  		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
  		if (typeof value === 'function' && !value.prototype) { return true; }
  		if (hasToStringTag) { return tryFunctionObject(value); }
  		if (isES6ClassFn(value)) { return false; }
  		var strClass = toStr.call(value);
  		return strClass === fnClass || strClass === genClass;
  	};


  	/***/ }),
  	/* 33 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var isNative = __webpack_require__(25),
  	    noop = __webpack_require__(57);

  	/** Used as the property descriptor for `__bindData__` */
  	var descriptor = {
  	  'configurable': false,
  	  'enumerable': false,
  	  'value': null,
  	  'writable': false
  	};

  	/** Used to set meta data on functions */
  	var defineProperty = (function() {
  	  // IE 8 only accepts DOM elements
  	  try {
  	    var o = {},
  	        func = isNative(func = Object.defineProperty) && func,
  	        result = func(o, o, o) && func;
  	  } catch(e) { }
  	  return result;
  	}());

  	/**
  	 * Sets `this` binding data on a given function.
  	 *
  	 * @private
  	 * @param {Function} func The function to set data on.
  	 * @param {Array} value The data array to set.
  	 */
  	var setBindData = !defineProperty ? noop : function(func, value) {
  	  descriptor.value = value;
  	  defineProperty(func, '__bindData__', descriptor);
  	};

  	module.exports = setBindData;


  	/***/ }),
  	/* 34 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var utils = __webpack_require__(1);

  	module.exports = {
  	  mixinName: "Ajaxable",
  	  ajaxable: true,
  	  initializeAjaxable: function initializeAjaxable() {
  	    this._queued = [];
  	  },
  	  addQueuedItem: function addQueuedItem(name, deferred) {
  	    utils.log("Adding queued item for " + this.blockID + " called " + name);

  	    this._queued.push({
  	      name: name,
  	      deferred: deferred
  	    });
  	  },
  	  removeQueuedItem: function removeQueuedItem(name) {
  	    utils.log("Removing queued item for " + this.blockID + " called " + name);
  	    this._queued = this._queued.filter(function (queued) {
  	      return queued.name !== name;
  	    });
  	  },
  	  hasItemsInQueue: function hasItemsInQueue() {
  	    return this._queued.length > 0;
  	  },
  	  resolveAllInQueue: function resolveAllInQueue() {
  	    this._queued.forEach(function (item) {
  	      utils.log("Aborting queued request: " + item.name);
  	      item.deferred.cancel();
  	    }, this);
  	  }
  	};

  	/***/ }),
  	/* 35 */
  	/***/ (function(module, exports, __webpack_require__) {


  	function dragEnter(e) {
  	  e.preventDefault();
  	  e.stopPropagation();
  	}

  	function dragOver(e) {
  	  e.dataTransfer.dropEffect = "copy";
  	  e.currentTarget.classList.add('st-drag-over');
  	  e.preventDefault();
  	  e.stopPropagation();
  	}

  	function dragLeave(e) {
  	  e.currentTarget.classList.remove('st-drag-over');
  	  e.preventDefault();
  	  e.stopPropagation();
  	}

  	module.exports = {
  	  dropArea: function dropArea(el) {
  	    el.addEventListener("dragenter", dragEnter);
  	    el.addEventListener("dragover", dragOver);
  	    el.addEventListener("dragleave", dragLeave);
  	    return el;
  	  },
  	  noDropArea: function noDropArea(el) {
  	    el.removeEventListener("dragenter");
  	    el.removeEventListener("dragover");
  	    el.removeEventListener("dragleave");
  	    return el;
  	  }
  	};

  	/***/ }),
  	/* 36 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7), __webpack_require__(15)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(isLength, isObjectLike) {

  	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  	  var undefined$1;

  	  /** `Object#toString` result references. */
  	  var argsTag = '[object Arguments]';

  	  /** Used for native method references. */
  	  var objectProto = Object.prototype;

  	  /**
  	   * Used to resolve the `toStringTag` of values.
  	   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
  	   * for more details.
  	   */
  	  var objToString = objectProto.toString;

  	  /**
  	   * Checks if `value` is classified as an `arguments` object.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Lang
  	   * @param {*} value The value to check.
  	   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
  	   * @example
  	   *
  	   * _.isArguments(function() { return arguments; }());
  	   * // => true
  	   *
  	   * _.isArguments([1, 2, 3]);
  	   * // => false
  	   */
  	  function isArguments(value) {
  	    var length = isObjectLike(value) ? value.length : undefined$1;
  	    return (isLength(length) && objToString.call(value) == argsTag) || false;
  	  }

  	  return isArguments;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 37 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /**
  	   * Used as the maximum length of an array-like value.
  	   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
  	   * for more details.
  	   */
  	  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

  	  /**
  	   * Checks if `value` is a valid array-like index.
  	   *
  	   * @private
  	   * @param {*} value The value to check.
  	   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
  	   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
  	   */
  	  function isIndex(value, length) {
  	    value = +value;
  	    length = length == null ? MAX_SAFE_INTEGER : length;
  	    return value > -1 && value % 1 == 0 && value < length;
  	  }

  	  return isIndex;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 38 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(36), __webpack_require__(20), __webpack_require__(37), __webpack_require__(7), __webpack_require__(14), __webpack_require__(75)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(isArguments, isArray, isIndex, isLength, isObject, support) {

  	  /** Used for native method references. */
  	  var objectProto = Object.prototype;

  	  /** Used to check objects for own properties. */
  	  var hasOwnProperty = objectProto.hasOwnProperty;

  	  /**
  	   * Creates an array of the own and inherited enumerable property names of `object`.
  	   *
  	   * **Note:** Non-object values are coerced to objects.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Object
  	   * @param {Object} object The object to inspect.
  	   * @returns {Array} Returns the array of property names.
  	   * @example
  	   *
  	   * function Foo() {
  	   *   this.a = 1;
  	   *   this.b = 2;
  	   * }
  	   *
  	   * Foo.prototype.c = 3;
  	   *
  	   * _.keysIn(new Foo);
  	   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
  	   */
  	  function keysIn(object) {
  	    if (object == null) {
  	      return [];
  	    }
  	    if (!isObject(object)) {
  	      object = Object(object);
  	    }
  	    var length = object.length;
  	    length = (length && isLength(length) &&
  	      (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

  	    var Ctor = object.constructor,
  	        index = -1,
  	        isProto = typeof Ctor == 'function' && Ctor.prototype === object,
  	        result = Array(length),
  	        skipIndexes = length > 0;

  	    while (++index < length) {
  	      result[index] = (index + '');
  	    }
  	    for (var key in object) {
  	      if (!(skipIndexes && isIndex(key, length)) &&
  	          !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
  	        result.push(key);
  	      }
  	    }
  	    return result;
  	  }

  	  return keysIn;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 39 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var dropEvents = __webpack_require__(35);

  	var EventBus = __webpack_require__(4);

  	var Dom = __webpack_require__(3);

  	var config = __webpack_require__(2);

  	var BlockReorder = function BlockReorder(block_element, mediator) {
  	  this.block = block_element;
  	  this.blockID = this.block.getAttribute('id');
  	  this.mediator = mediator;

  	  this._ensureElement();

  	  this._bindFunctions();

  	  this.initialize();
  	};

  	Object.assign(BlockReorder.prototype, __webpack_require__(6), __webpack_require__(11), {
  	  bound: ['onMouseDown', 'onDragStart', 'onDragEnd', 'onDrop'],
  	  className: 'st-block-ui-btn__reorder',
  	  tagName: 'a',
  	  attributes: function attributes() {
  	    return {
  	      'html': "<svg role=\"img\" class=\"st-icon\">\n                 <use xlink:href=\"".concat(config.defaults.iconUrl, "#move\"/>\n               </svg>"),
  	      'draggable': 'true',
  	      'data-icon': 'move'
  	    };
  	  },
  	  initialize: function initialize() {
  	    this.el.addEventListener('mousedown', this.onMouseDown);
  	    this.el.addEventListener('dragstart', this.onDragStart);
  	    this.el.addEventListener('dragend', this.onDragEnd);
  	    dropEvents.dropArea(this.block);
  	    this.block.addEventListener('drop', this.onDrop);
  	  },
  	  blockId: function blockId() {
  	    return this.block.getAttribute('id');
  	  },
  	  onMouseDown: function onMouseDown() {
  	    EventBus.trigger("block:reorder:down");
  	  },
  	  onDrop: function onDrop(ev) {
  	    ev.preventDefault();
  	    var dropped_on = this.block,
  	        item_id = ev.dataTransfer.getData("text/plain"),
  	        block = document.querySelector('#' + item_id);

  	    if (dropped_on.id !== item_id) {
  	      Dom.insertAfter(block, dropped_on);
  	    }

  	    this.mediator.trigger("block:rerender", item_id);
  	    EventBus.trigger("block:reorder:dropped", item_id);
  	  },
  	  onDragStart: function onDragStart(ev) {
  	    var block = this.block;
  	    this.dragEl = block.cloneNode(true);
  	    this.dragEl.classList.add("st-drag-element");
  	    this.dragEl.style.top = "".concat(block.offsetTop, "px");
  	    this.dragEl.style.left = "".concat(block.offsetLeft, "px");
  	    block.parentNode.appendChild(this.dragEl);
  	    ev.dataTransfer.setDragImage(this.dragEl, 0, 0);
  	    ev.dataTransfer.setData("text/plain", this.blockId());
  	    this.mediator.trigger("block-controls:hide");
  	    EventBus.trigger("block:reorder:dragstart");
  	    block.classList.add('st-block--dragging');
  	  },
  	  onDragEnd: function onDragEnd(ev) {
  	    EventBus.trigger("block:reorder:dragend");
  	    this.block.classList.remove('st-block--dragging');
  	    this.dragEl.parentNode.removeChild(this.dragEl);
  	  },
  	  render: function render() {
  	    return this;
  	  }
  	});
  	module.exports = BlockReorder;

  	/***/ }),
  	/* 40 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var scribeHeadingPlugin = function scribeHeadingPlugin(block) {
  	  return function (scribe) {
  	    var headingCommand = new scribe.api.Command('heading');

  	    headingCommand.queryEnabled = function () {
  	      return block.inline_editable;
  	    };

  	    headingCommand.queryState = function () {
  	      return block.type === 'heading';
  	    };

  	    var getBlockType = function getBlockType() {
  	      return headingCommand.queryState() ? 'Text' : 'Heading';
  	    };

  	    headingCommand.execute = function headingCommandExecute(value) {
  	      var data = {
  	        format: 'html',
  	        text: block.getScribeInnerContent()
  	      };
  	      block.mediator.trigger("block:replace", block.el, getBlockType(), data);
  	    };

  	    scribe.commands.heading = headingCommand;
  	  };
  	};

  	module.exports = scribeHeadingPlugin;

  	/***/ }),
  	/* 41 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var scribeQuotePlugin = function scribeQuotePlugin(block) {
  	  return function (scribe) {
  	    var quoteCommand = new scribe.api.Command('quote');

  	    quoteCommand.queryEnabled = function () {
  	      return block.inline_editable;
  	    };

  	    quoteCommand.queryState = function () {
  	      return block.type === 'quote';
  	    };

  	    var getBlockType = function getBlockType() {
  	      return quoteCommand.queryState() ? 'Text' : 'Quote';
  	    };

  	    quoteCommand.execute = function quoteCommandExecute(value) {
  	      var data = {
  	        format: 'html',
  	        text: block.getScribeInnerContent()
  	      };
  	      block.mediator.trigger("block:replace", block.el, getBlockType(), data);
  	    };

  	    scribe.commands.quote = quoteCommand;
  	  };
  	};

  	module.exports = scribeQuotePlugin;

  	/***/ }),
  	/* 42 */
  	/***/ (function(module, exports, __webpack_require__) {


  	// modified from https://github.com/es-shims/es5-shim
  	var has = Object.prototype.hasOwnProperty;
  	var toStr = Object.prototype.toString;
  	var slice = Array.prototype.slice;
  	var isArgs = __webpack_require__(97);
  	var isEnumerable = Object.prototype.propertyIsEnumerable;
  	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
  	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
  	var dontEnums = [
  		'toString',
  		'toLocaleString',
  		'valueOf',
  		'hasOwnProperty',
  		'isPrototypeOf',
  		'propertyIsEnumerable',
  		'constructor'
  	];
  	var equalsConstructorPrototype = function (o) {
  		var ctor = o.constructor;
  		return ctor && ctor.prototype === o;
  	};
  	var excludedKeys = {
  		$applicationCache: true,
  		$console: true,
  		$external: true,
  		$frame: true,
  		$frameElement: true,
  		$frames: true,
  		$innerHeight: true,
  		$innerWidth: true,
  		$outerHeight: true,
  		$outerWidth: true,
  		$pageXOffset: true,
  		$pageYOffset: true,
  		$parent: true,
  		$scrollLeft: true,
  		$scrollTop: true,
  		$scrollX: true,
  		$scrollY: true,
  		$self: true,
  		$webkitIndexedDB: true,
  		$webkitStorageInfo: true,
  		$window: true
  	};
  	var hasAutomationEqualityBug = (function () {
  		/* global window */
  		if (typeof window === 'undefined') { return false; }
  		for (var k in window) {
  			try {
  				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
  					try {
  						equalsConstructorPrototype(window[k]);
  					} catch (e) {
  						return true;
  					}
  				}
  			} catch (e) {
  				return true;
  			}
  		}
  		return false;
  	}());
  	var equalsConstructorPrototypeIfNotBuggy = function (o) {
  		/* global window */
  		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
  			return equalsConstructorPrototype(o);
  		}
  		try {
  			return equalsConstructorPrototype(o);
  		} catch (e) {
  			return false;
  		}
  	};

  	var keysShim = function keys(object) {
  		var isObject = object !== null && typeof object === 'object';
  		var isFunction = toStr.call(object) === '[object Function]';
  		var isArguments = isArgs(object);
  		var isString = isObject && toStr.call(object) === '[object String]';
  		var theKeys = [];

  		if (!isObject && !isFunction && !isArguments) {
  			throw new TypeError('Object.keys called on a non-object');
  		}

  		var skipProto = hasProtoEnumBug && isFunction;
  		if (isString && object.length > 0 && !has.call(object, 0)) {
  			for (var i = 0; i < object.length; ++i) {
  				theKeys.push(String(i));
  			}
  		}

  		if (isArguments && object.length > 0) {
  			for (var j = 0; j < object.length; ++j) {
  				theKeys.push(String(j));
  			}
  		} else {
  			for (var name in object) {
  				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
  					theKeys.push(String(name));
  				}
  			}
  		}

  		if (hasDontEnumBug) {
  			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

  			for (var k = 0; k < dontEnums.length; ++k) {
  				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
  					theKeys.push(dontEnums[k]);
  				}
  			}
  		}
  		return theKeys;
  	};

  	keysShim.shim = function shimObjectKeys() {
  		if (Object.keys) {
  			var keysWorksWithArguments = (function () {
  				// Safari 5.0 bug
  				return (Object.keys(arguments) || '').length === 2;
  			}(1, 2));
  			if (!keysWorksWithArguments) {
  				var originalKeys = Object.keys;
  				Object.keys = function keys(object) { // eslint-disable-line func-name-matching
  					if (isArgs(object)) {
  						return originalKeys(slice.call(object));
  					} else {
  						return originalKeys(object);
  					}
  				};
  			}
  		} else {
  			Object.keys = keysShim;
  		}
  		return Object.keys || keysShim;
  	};

  	module.exports = keysShim;


  	/***/ }),
  	/* 43 */
  	/***/ (function(module, exports, __webpack_require__) {


  	// modified from https://github.com/es-shims/es6-shim
  	var keys = __webpack_require__(42);
  	var bind = __webpack_require__(24);
  	var canBeObject = function (obj) {
  		return typeof obj !== 'undefined' && obj !== null;
  	};
  	var hasSymbols = __webpack_require__(44)();
  	var toObject = Object;
  	var push = bind.call(Function.call, Array.prototype.push);
  	var propIsEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);
  	var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

  	module.exports = function assign(target, source1) {
  		if (!canBeObject(target)) { throw new TypeError('target must be an object'); }
  		var objTarget = toObject(target);
  		var s, source, i, props, syms, value, key;
  		for (s = 1; s < arguments.length; ++s) {
  			source = toObject(arguments[s]);
  			props = keys(source);
  			var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
  			if (getSymbols) {
  				syms = getSymbols(source);
  				for (i = 0; i < syms.length; ++i) {
  					key = syms[i];
  					if (propIsEnumerable(source, key)) {
  						push(props, key);
  					}
  				}
  			}
  			for (i = 0; i < props.length; ++i) {
  				key = props[i];
  				value = source[key];
  				if (propIsEnumerable(source, key)) {
  					objTarget[key] = value;
  				}
  			}
  		}
  		return objTarget;
  	};


  	/***/ }),
  	/* 44 */
  	/***/ (function(module, exports, __webpack_require__) {


  	/* eslint complexity: [2, 17], max-statements: [2, 33] */
  	module.exports = function hasSymbols() {
  		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
  		if (typeof Symbol.iterator === 'symbol') { return true; }

  		var obj = {};
  		var sym = Symbol('test');
  		var symObj = Object(sym);
  		if (typeof sym === 'string') { return false; }

  		if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
  		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

  		// temp disabled per https://github.com/ljharb/object.assign/issues/17
  		// if (sym instanceof Symbol) { return false; }
  		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  		// if (!(symObj instanceof Symbol)) { return false; }

  		// if (typeof Symbol.prototype.toString !== 'function') { return false; }
  		// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

  		var symVal = 42;
  		obj[sym] = symVal;
  		for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
  		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

  		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

  		var syms = Object.getOwnPropertySymbols(obj);
  		if (syms.length !== 1 || syms[0] !== sym) { return false; }

  		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

  		if (typeof Object.getOwnPropertyDescriptor === 'function') {
  			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
  			if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
  		}

  		return true;
  	};


  	/***/ }),
  	/* 45 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var implementation = __webpack_require__(43);

  	var lacksProperEnumerationOrder = function () {
  		if (!Object.assign) {
  			return false;
  		}
  		// v8, specifically in node 4.x, has a bug with incorrect property enumeration order
  		// note: this does not detect the bug unless there's 20 characters
  		var str = 'abcdefghijklmnopqrst';
  		var letters = str.split('');
  		var map = {};
  		for (var i = 0; i < letters.length; ++i) {
  			map[letters[i]] = letters[i];
  		}
  		var obj = Object.assign({}, map);
  		var actual = '';
  		for (var k in obj) {
  			actual += k;
  		}
  		return str !== actual;
  	};

  	var assignHasPendingExceptions = function () {
  		if (!Object.assign || !Object.preventExtensions) {
  			return false;
  		}
  		// Firefox 37 still has "pending exception" logic in its Object.assign implementation,
  		// which is 72% slower than our shim, and Firefox 40's native implementation.
  		var thrower = Object.preventExtensions({ 1: 2 });
  		try {
  			Object.assign(thrower, 'xy');
  		} catch (e) {
  			return thrower[1] === 'y';
  		}
  		return false;
  	};

  	module.exports = function getPolyfill() {
  		if (!Object.assign) {
  			return implementation;
  		}
  		if (lacksProperEnumerationOrder()) {
  			return implementation;
  		}
  		if (assignHasPendingExceptions()) {
  			return implementation;
  		}
  		return Object.assign;
  	};


  	/***/ }),
  	/* 46 */
  	/***/ (function(module, exports, __webpack_require__) {


  	module.exports = __webpack_require__(102);


  	/***/ }),
  	/* 47 */
  	/***/ (function(module, exports) {

  	module.exports = function isPrimitive(value) {
  		return value === null || (typeof value !== 'function' && typeof value !== 'object');
  	};


  	/***/ }),
  	/* 48 */
  	/***/ (function(module, exports, __webpack_require__) {


  	/* globals
  		Set,
  		Map,
  		WeakSet,
  		WeakMap,

  		Promise,

  		Symbol,
  		Proxy,

  		Atomics,
  		SharedArrayBuffer,

  		ArrayBuffer,
  		DataView,
  		Uint8Array,
  		Float32Array,
  		Float64Array,
  		Int8Array,
  		Int16Array,
  		Int32Array,
  		Uint8ClampedArray,
  		Uint16Array,
  		Uint32Array,
  	*/

  	var undefined$1; // eslint-disable-line no-shadow-restricted-names

  	var ThrowTypeError = Object.getOwnPropertyDescriptor
  		? (function () { return Object.getOwnPropertyDescriptor(arguments, 'callee').get; }())
  		: function () { throw new TypeError(); };

  	var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

  	var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto
  	var generatorFunction = undefined$1;
  	var asyncFunction = undefined$1;
  	var asyncGenFunction = undefined$1;

  	var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto(Uint8Array);

  	var INTRINSICS = {
  		'$ %Array%': Array,
  		'$ %ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
  		'$ %ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer.prototype,
  		'$ %ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined$1,
  		'$ %ArrayPrototype%': Array.prototype,
  		'$ %ArrayProto_entries%': Array.prototype.entries,
  		'$ %ArrayProto_forEach%': Array.prototype.forEach,
  		'$ %ArrayProto_keys%': Array.prototype.keys,
  		'$ %ArrayProto_values%': Array.prototype.values,
  		'$ %AsyncFromSyncIteratorPrototype%': undefined$1,
  		'$ %AsyncFunction%': asyncFunction,
  		'$ %AsyncFunctionPrototype%': undefined$1,
  		'$ %AsyncGenerator%': undefined$1,
  		'$ %AsyncGeneratorFunction%': asyncGenFunction,
  		'$ %AsyncGeneratorPrototype%': undefined$1,
  		'$ %AsyncIteratorPrototype%': undefined$1,
  		'$ %Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
  		'$ %Boolean%': Boolean,
  		'$ %BooleanPrototype%': Boolean.prototype,
  		'$ %DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
  		'$ %DataViewPrototype%': typeof DataView === 'undefined' ? undefined$1 : DataView.prototype,
  		'$ %Date%': Date,
  		'$ %DatePrototype%': Date.prototype,
  		'$ %decodeURI%': decodeURI,
  		'$ %decodeURIComponent%': decodeURIComponent,
  		'$ %encodeURI%': encodeURI,
  		'$ %encodeURIComponent%': encodeURIComponent,
  		'$ %Error%': Error,
  		'$ %ErrorPrototype%': Error.prototype,
  		'$ %eval%': eval, // eslint-disable-line no-eval
  		'$ %EvalError%': EvalError,
  		'$ %EvalErrorPrototype%': EvalError.prototype,
  		'$ %Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
  		'$ %Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array.prototype,
  		'$ %Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
  		'$ %Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array.prototype,
  		'$ %Function%': Function,
  		'$ %FunctionPrototype%': Function.prototype,
  		'$ %Generator%': undefined$1,
  		'$ %GeneratorFunction%': generatorFunction,
  		'$ %GeneratorPrototype%': undefined$1,
  		'$ %Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
  		'$ %Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array.prototype,
  		'$ %Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
  		'$ %Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined$1 : Int8Array.prototype,
  		'$ %Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
  		'$ %Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array.prototype,
  		'$ %isFinite%': isFinite,
  		'$ %isNaN%': isNaN,
  		'$ %IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  		'$ %JSON%': JSON,
  		'$ %JSONParse%': JSON.parse,
  		'$ %Map%': typeof Map === 'undefined' ? undefined$1 : Map,
  		'$ %MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
  		'$ %MapPrototype%': typeof Map === 'undefined' ? undefined$1 : Map.prototype,
  		'$ %Math%': Math,
  		'$ %Number%': Number,
  		'$ %NumberPrototype%': Number.prototype,
  		'$ %Object%': Object,
  		'$ %ObjectPrototype%': Object.prototype,
  		'$ %ObjProto_toString%': Object.prototype.toString,
  		'$ %ObjProto_valueOf%': Object.prototype.valueOf,
  		'$ %parseFloat%': parseFloat,
  		'$ %parseInt%': parseInt,
  		'$ %Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
  		'$ %PromisePrototype%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype,
  		'$ %PromiseProto_then%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype.then,
  		'$ %Promise_all%': typeof Promise === 'undefined' ? undefined$1 : Promise.all,
  		'$ %Promise_reject%': typeof Promise === 'undefined' ? undefined$1 : Promise.reject,
  		'$ %Promise_resolve%': typeof Promise === 'undefined' ? undefined$1 : Promise.resolve,
  		'$ %Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
  		'$ %RangeError%': RangeError,
  		'$ %RangeErrorPrototype%': RangeError.prototype,
  		'$ %ReferenceError%': ReferenceError,
  		'$ %ReferenceErrorPrototype%': ReferenceError.prototype,
  		'$ %Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
  		'$ %RegExp%': RegExp,
  		'$ %RegExpPrototype%': RegExp.prototype,
  		'$ %Set%': typeof Set === 'undefined' ? undefined$1 : Set,
  		'$ %SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
  		'$ %SetPrototype%': typeof Set === 'undefined' ? undefined$1 : Set.prototype,
  		'$ %SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
  		'$ %SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer.prototype,
  		'$ %String%': String,
  		'$ %StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined$1,
  		'$ %StringPrototype%': String.prototype,
  		'$ %Symbol%': hasSymbols ? Symbol : undefined$1,
  		'$ %SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined$1,
  		'$ %SyntaxError%': SyntaxError,
  		'$ %SyntaxErrorPrototype%': SyntaxError.prototype,
  		'$ %ThrowTypeError%': ThrowTypeError,
  		'$ %TypedArray%': TypedArray,
  		'$ %TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined$1,
  		'$ %TypeError%': TypeError,
  		'$ %TypeErrorPrototype%': TypeError.prototype,
  		'$ %Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
  		'$ %Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array.prototype,
  		'$ %Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
  		'$ %Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray.prototype,
  		'$ %Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
  		'$ %Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array.prototype,
  		'$ %Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
  		'$ %Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array.prototype,
  		'$ %URIError%': URIError,
  		'$ %URIErrorPrototype%': URIError.prototype,
  		'$ %WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
  		'$ %WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap.prototype,
  		'$ %WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,
  		'$ %WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet.prototype
  	};

  	module.exports = function GetIntrinsic(name, allowMissing) {
  		if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
  			throw new TypeError('"allowMissing" argument must be a boolean');
  		}

  		var key = '$ ' + name;
  		if (!(key in INTRINSICS)) {
  			throw new SyntaxError('intrinsic ' + name + ' does not exist!');
  		}

  		// istanbul ignore if // hopefully this is impossible to test :-)
  		if (typeof INTRINSICS[key] === 'undefined' && !allowMissing) {
  			throw new TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
  		}
  		return INTRINSICS[key];
  	};


  	/***/ }),
  	/* 49 */
  	/***/ (function(module, exports) {

  	module.exports = Number.isNaN || function isNaN(a) {
  		return a !== a;
  	};


  	/***/ }),
  	/* 50 */
  	/***/ (function(module, exports) {

  	var $isNaN = Number.isNaN || function (a) { return a !== a; };

  	module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };


  	/***/ }),
  	/* 51 */
  	/***/ (function(module, exports) {

  	module.exports = function sign(number) {
  		return number >= 0 ? 1 : -1;
  	};


  	/***/ }),
  	/* 52 */
  	/***/ (function(module, exports) {

  	module.exports = function mod(number, modulo) {
  		var remain = number % modulo;
  		return Math.floor(remain >= 0 ? remain : remain + modulo);
  	};


  	/***/ }),
  	/* 53 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var ES = __webpack_require__(46);

  	module.exports = function find(predicate) {
  		var list = ES.ToObject(this);
  		var length = ES.ToInteger(ES.ToLength(list.length));
  		if (!ES.IsCallable(predicate)) {
  			throw new TypeError('Array#find: predicate must be a function');
  		}
  		if (length === 0) {
  			return undefined;
  		}
  		var thisArg = arguments[1];
  		for (var i = 0, value; i < length; i++) {
  			value = list[i];
  			if (ES.Call(predicate, thisArg, [value, i, list])) {
  				return value;
  			}
  		}
  		return undefined;
  	};


  	/***/ }),
  	/* 54 */
  	/***/ (function(module, exports, __webpack_require__) {


  	module.exports = function getPolyfill() {
  		// Detect if an implementation exists
  		// Detect early implementations which skipped holes in sparse arrays
  	  // eslint-disable-next-line no-sparse-arrays
  		var implemented = Array.prototype.find && [, 1].find(function () {
  			return true;
  		}) !== 1;

  	  // eslint-disable-next-line global-require
  		return implemented ? Array.prototype.find : __webpack_require__(53);
  	};


  	/***/ }),
  	/* 55 */
  	/***/ (function(module, exports) {

  	// shim for using process in browser
  	var process = module.exports = {};

  	// cached from whatever global is present so that test runners that stub it
  	// don't break things.  But we need to wrap it in a try catch in case it is
  	// wrapped in strict mode code which doesn't define any globals.  It's inside a
  	// function because try/catches deoptimize in certain engines.

  	var cachedSetTimeout;
  	var cachedClearTimeout;

  	function defaultSetTimout() {
  	    throw new Error('setTimeout has not been defined');
  	}
  	function defaultClearTimeout () {
  	    throw new Error('clearTimeout has not been defined');
  	}
  	(function () {
  	    try {
  	        if (typeof setTimeout === 'function') {
  	            cachedSetTimeout = setTimeout;
  	        } else {
  	            cachedSetTimeout = defaultSetTimout;
  	        }
  	    } catch (e) {
  	        cachedSetTimeout = defaultSetTimout;
  	    }
  	    try {
  	        if (typeof clearTimeout === 'function') {
  	            cachedClearTimeout = clearTimeout;
  	        } else {
  	            cachedClearTimeout = defaultClearTimeout;
  	        }
  	    } catch (e) {
  	        cachedClearTimeout = defaultClearTimeout;
  	    }
  	} ());
  	function runTimeout(fun) {
  	    if (cachedSetTimeout === setTimeout) {
  	        //normal enviroments in sane situations
  	        return setTimeout(fun, 0);
  	    }
  	    // if setTimeout wasn't available but was latter defined
  	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
  	        cachedSetTimeout = setTimeout;
  	        return setTimeout(fun, 0);
  	    }
  	    try {
  	        // when when somebody has screwed with setTimeout but no I.E. maddness
  	        return cachedSetTimeout(fun, 0);
  	    } catch(e){
  	        try {
  	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
  	            return cachedSetTimeout.call(null, fun, 0);
  	        } catch(e){
  	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
  	            return cachedSetTimeout.call(this, fun, 0);
  	        }
  	    }


  	}
  	function runClearTimeout(marker) {
  	    if (cachedClearTimeout === clearTimeout) {
  	        //normal enviroments in sane situations
  	        return clearTimeout(marker);
  	    }
  	    // if clearTimeout wasn't available but was latter defined
  	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
  	        cachedClearTimeout = clearTimeout;
  	        return clearTimeout(marker);
  	    }
  	    try {
  	        // when when somebody has screwed with setTimeout but no I.E. maddness
  	        return cachedClearTimeout(marker);
  	    } catch (e){
  	        try {
  	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
  	            return cachedClearTimeout.call(null, marker);
  	        } catch (e){
  	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
  	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
  	            return cachedClearTimeout.call(this, marker);
  	        }
  	    }



  	}
  	var queue = [];
  	var draining = false;
  	var currentQueue;
  	var queueIndex = -1;

  	function cleanUpNextTick() {
  	    if (!draining || !currentQueue) {
  	        return;
  	    }
  	    draining = false;
  	    if (currentQueue.length) {
  	        queue = currentQueue.concat(queue);
  	    } else {
  	        queueIndex = -1;
  	    }
  	    if (queue.length) {
  	        drainQueue();
  	    }
  	}

  	function drainQueue() {
  	    if (draining) {
  	        return;
  	    }
  	    var timeout = runTimeout(cleanUpNextTick);
  	    draining = true;

  	    var len = queue.length;
  	    while(len) {
  	        currentQueue = queue;
  	        queue = [];
  	        while (++queueIndex < len) {
  	            if (currentQueue) {
  	                currentQueue[queueIndex].run();
  	            }
  	        }
  	        queueIndex = -1;
  	        len = queue.length;
  	    }
  	    currentQueue = null;
  	    draining = false;
  	    runClearTimeout(timeout);
  	}

  	process.nextTick = function (fun) {
  	    var args = new Array(arguments.length - 1);
  	    if (arguments.length > 1) {
  	        for (var i = 1; i < arguments.length; i++) {
  	            args[i - 1] = arguments[i];
  	        }
  	    }
  	    queue.push(new Item(fun, args));
  	    if (queue.length === 1 && !draining) {
  	        runTimeout(drainQueue);
  	    }
  	};

  	// v8 likes predictible objects
  	function Item(fun, array) {
  	    this.fun = fun;
  	    this.array = array;
  	}
  	Item.prototype.run = function () {
  	    this.fun.apply(null, this.array);
  	};
  	process.title = 'browser';
  	process.browser = true;
  	process.env = {};
  	process.argv = [];
  	process.version = ''; // empty string to avoid regexp issues
  	process.versions = {};

  	function noop() {}

  	process.on = noop;
  	process.addListener = noop;
  	process.once = noop;
  	process.off = noop;
  	process.removeListener = noop;
  	process.removeAllListeners = noop;
  	process.emit = noop;
  	process.prependListener = noop;
  	process.prependOnceListener = noop;

  	process.listeners = function (name) { return [] };

  	process.binding = function (name) {
  	    throw new Error('process.binding is not supported');
  	};

  	process.cwd = function () { return '/' };
  	process.chdir = function (dir) {
  	    throw new Error('process.chdir is not supported');
  	};
  	process.umask = function() { return 0; };


  	/***/ }),
  	/* 56 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/* WEBPACK VAR INJECTION */(function(global) {/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var isNative = __webpack_require__(25),
  	    isObject = __webpack_require__(18);
  	    __webpack_require__(57);

  	/* Native method shortcuts for methods with the same name as other `lodash` methods */
  	var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate;

  	/**
  	 * The base implementation of `_.create` without support for assigning
  	 * properties to the created object.
  	 *
  	 * @private
  	 * @param {Object} prototype The object to inherit from.
  	 * @returns {Object} Returns the new object.
  	 */
  	function baseCreate(prototype, properties) {
  	  return isObject(prototype) ? nativeCreate(prototype) : {};
  	}
  	// fallback for browsers without `Object.create`
  	if (!nativeCreate) {
  	  baseCreate = (function() {
  	    function Object() {}
  	    return function(prototype) {
  	      if (isObject(prototype)) {
  	        Object.prototype = prototype;
  	        var result = new Object;
  	        Object.prototype = null;
  	      }
  	      return result || global.Object();
  	    };
  	  }());
  	}

  	module.exports = baseCreate;

  	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17)));

  	/***/ }),
  	/* 57 */
  	/***/ (function(module, exports) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */

  	/**
  	 * A no-operation function.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Utilities
  	 * @example
  	 *
  	 * var object = { 'name': 'fred' };
  	 * _.noop(object) === undefined;
  	 * // => true
  	 */
  	function noop() {
  	  // no operation performed
  	}

  	module.exports = noop;


  	/***/ }),
  	/* 58 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var escapeHtmlChar = __webpack_require__(134);
  	    __webpack_require__(12);
  	    var reUnescapedHtml = __webpack_require__(135);

  	/**
  	 * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
  	 * corresponding HTML entities.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Utilities
  	 * @param {string} string The string to escape.
  	 * @returns {string} Returns the escaped string.
  	 * @example
  	 *
  	 * _.escape('Fred, Wilma, & Pebbles');
  	 * // => 'Fred, Wilma, &amp; Pebbles'
  	 */
  	function escape(string) {
  	  return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
  	}

  	module.exports = escape;


  	/***/ }),
  	/* 59 */
  	/***/ (function(module, exports) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */

  	/**
  	 * Used to convert characters to HTML entities:
  	 *
  	 * Though the `>` character is escaped for symmetry, characters like `>` and `/`
  	 * don't require escaping in HTML and have no special meaning unless they're part
  	 * of a tag or an unquoted attribute value.
  	 * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
  	 */
  	var htmlEscapes = {
  	  '&': '&amp;',
  	  '<': '&lt;',
  	  '>': '&gt;',
  	  '"': '&quot;',
  	  "'": '&#39;'
  	};

  	module.exports = htmlEscapes;


  	/***/ }),
  	/* 60 */
  	/***/ (function(module, exports) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */

  	/** Used to match "interpolate" template delimiters */
  	var reInterpolate = /<%=([\s\S]+?)%>/g;

  	module.exports = reInterpolate;


  	/***/ }),
  	/* 61 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/*
  	 * Sir Trevor Editor Store
  	 * By default we store the complete data on the instances $el
  	 * We can easily extend this and store it on some server or something
  	 */

  	var _ = __webpack_require__(0);

  	var utils = __webpack_require__(1);

  	var EditorStore = function EditorStore(data, mediator) {
  	  this.mediator = mediator;
  	  this.initialize(data ? data.trim() : '');
  	};

  	Object.assign(EditorStore.prototype, {
  	  initialize: function initialize(data) {
  	    this.store = this._parseData(data) || {
  	      data: []
  	    };
  	  },
  	  retrieve: function retrieve() {
  	    return this.store;
  	  },
  	  toString: function toString(space) {
  	    return JSON.stringify(this.store, undefined, space);
  	  },
  	  reset: function reset() {
  	    utils.log("Resetting the EditorStore");
  	    this.store = {
  	      data: []
  	    };
  	  },
  	  addData: function addData(data) {
  	    this.store.data.push(data);
  	    return this.store;
  	  },
  	  _parseData: function _parseData(data) {
  	    var result;

  	    if (data.length === 0) {
  	      return result;
  	    }

  	    try {
  	      // Ensure the JSON string has a data element that's an array
  	      var jsonStr = JSON.parse(data);

  	      if (!_.isUndefined(jsonStr.data)) {
  	        result = jsonStr;
  	      }
  	    } catch (e) {
  	      this.mediator.trigger('errors:add', {
  	        text: i18n.t("errors:load_fail")
  	      });
  	      this.mediator.trigger('errors:render');
  	      console.log('Sorry there has been a problem with parsing the JSON');
  	      console.log(e);
  	    }

  	    return result;
  	  }
  	});
  	module.exports = EditorStore;

  	/***/ }),
  	/* 62 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/*
  	 * SirTrevor.Submittable
  	 * --
  	 * We need a global way of setting if the editor can and can't be submitted,
  	 * and a way to disable the submit button and add messages (when appropriate)
  	 * We also need this to be highly extensible so it can be overridden.
  	 * This will be triggered *by anything* so it needs to subscribe to events.
  	 */

  	var utils = __webpack_require__(1);

  	var EventBus = __webpack_require__(4);

  	var Submittable = function Submittable(form) {
  	  this.form = form;
  	  this.initialize();
  	};

  	Object.assign(Submittable.prototype, {
  	  initialize: function initialize() {
  	    this.submitBtns = this.form.querySelectorAll("input[type='submit']");
  	    var btnTitles = [];
  	    Array.prototype.forEach.call(this.submitBtns, function (btn, i) {
  	      btnTitles.push(btn.getAttribute('value'));
  	    });
  	    this.submitBtnTitles = btnTitles;
  	    this.canSubmit = true;
  	    this.globalUploadCount = 0;

  	    this._bindEvents();
  	  },
  	  setSubmitButton: function setSubmitButton(e, message) {
  	    Array.prototype.forEach.call(this.submitBtns, function (btn, i) {
  	      btn.setAttribute('value', message);
  	    });
  	  },
  	  resetSubmitButton: function resetSubmitButton() {
  	    var titles = this.submitBtnTitles;
  	    Array.prototype.forEach.call(this.submitBtns, function (item, index) {
  	      item.setAttribute('value', titles[index]);
  	    });
  	  },
  	  onUploadStart: function onUploadStart(e) {
  	    this.globalUploadCount++;
  	    utils.log('onUploadStart called ' + this.globalUploadCount);

  	    if (this.globalUploadCount === 1) {
  	      this._disableSubmitButton();
  	    }
  	  },
  	  onUploadStop: function onUploadStop(e) {
  	    this.globalUploadCount = this.globalUploadCount <= 0 ? 0 : this.globalUploadCount - 1;
  	    utils.log('onUploadStop called ' + this.globalUploadCount);

  	    if (this.globalUploadCount === 0) {
  	      this._enableSubmitButton();
  	    }
  	  },
  	  onError: function onError(e) {
  	    utils.log('onError called');
  	    this.canSubmit = false;
  	  },
  	  _disableSubmitButton: function _disableSubmitButton(message) {
  	    this.setSubmitButton(null, message || i18n.t("general:wait"));
  	    Array.prototype.forEach.call(this.submitBtns, function (btn, i) {
  	      btn.setAttribute('disabled', 'disabled');
  	      btn.classList.add('disabled');
  	    });
  	  },
  	  _enableSubmitButton: function _enableSubmitButton() {
  	    this.resetSubmitButton();
  	    Array.prototype.forEach.call(this.submitBtns, function (btn, i) {
  	      btn.removeAttribute('disabled');
  	      btn.classList.remove('disabled');
  	    });
  	  },
  	  _events: {
  	    "disableSubmitButton": "_disableSubmitButton",
  	    "enableSubmitButton": "_enableSubmitButton",
  	    "setSubmitButton": "setSubmitButton",
  	    "resetSubmitButton": "resetSubmitButton",
  	    "onError": "onError",
  	    "onUploadStart": "onUploadStart",
  	    "onUploadStop": "onUploadStop"
  	  },
  	  _bindEvents: function _bindEvents() {
  	    Object.keys(this._events).forEach(function (type) {
  	      EventBus.on(type, this[this._events[type]], this);
  	    }, this);
  	  }
  	});
  	module.exports = Submittable;

  	/***/ }),
  	/* 63 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/*
  	*   Sir Trevor Uploader
  	*   Generic Upload implementation that can be extended for blocks
  	*/

  	var _ = __webpack_require__(0);

  	var config = __webpack_require__(2);

  	var utils = __webpack_require__(1);

  	var Ajax = __webpack_require__(64);

  	var EventBus = __webpack_require__(4);

  	module.exports = function (block, file, success, error) {
  	  var uid = [block.blockID, new Date().getTime(), 'raw'].join('-');
  	  var data = new FormData();
  	  var attachmentName = block.attachmentName || config.defaults.attachmentName;
  	  var attachmentFile = block.attachmentFile || config.defaults.attachmentFile;
  	  var attachmentUid = block.attachmentUid || config.defaults.attachmentUid;
  	  data.append(attachmentName, file.name);
  	  data.append(attachmentFile, file);
  	  data.append(attachmentUid, uid);
  	  EventBus.trigger('onUploadStart', data);
  	  block.resetMessages();

  	  var callbackSuccess = function callbackSuccess(data) {
  	    utils.log('Upload callback called');
  	    EventBus.trigger('onUploadStop', data);

  	    if (!_.isUndefined(success) && _.isFunction(success)) {
  	      success.apply(block, arguments, data);
  	    }

  	    block.removeQueuedItem(uid);
  	  };

  	  var callbackError = function callbackError(jqXHR, status, errorThrown) {
  	    utils.log('Upload callback error called');
  	    EventBus.trigger('onUploadStop', undefined, errorThrown, status, jqXHR);

  	    if (!_.isUndefined(error) && _.isFunction(error)) {
  	      error.call(block, status);
  	    }

  	    block.removeQueuedItem(uid);
  	  };

  	  var url = block.uploadUrl || config.defaults.uploadUrl;
  	  var xhr = Ajax.fetch(url, {
  	    body: data,
  	    method: 'POST',
  	    dataType: 'json'
  	  });
  	  block.addQueuedItem(uid, xhr);
  	  xhr.then(callbackSuccess).catch(callbackError);
  	  return xhr;
  	};

  	/***/ }),
  	/* 64 */
  	/***/ (function(module, exports, __webpack_require__) {


  	__webpack_require__(142);

  	var fetchJsonP = __webpack_require__(143);

  	var cancellablePromise = __webpack_require__(144);

  	var config = __webpack_require__(2);

  	var Ajax = Object.create(null);

  	Ajax.fetch = function (url) {
  	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	  options = Object.assign({}, config.defaults.ajaxOptions, options);
  	  var promise;

  	  if (options.jsonp) {
  	    promise = fetchJsonP(url).promise;
  	  } else {
  	    promise = fetch(url, options).then(function (response) {
  	      if (options.dataType === 'json') {
  	        return response.json();
  	      }

  	      return response.text();
  	    });
  	  }

  	  return cancellablePromise(promise);
  	};

  	module.exports = Ajax;

  	/***/ }),
  	/* 65 */
  	/***/ (function(module, exports, __webpack_require__) {


  	module.exports = {
  	  Ajaxable: __webpack_require__(34),
  	  Controllable: __webpack_require__(145),
  	  Droppable: __webpack_require__(146),
  	  Fetchable: __webpack_require__(147),
  	  Pastable: __webpack_require__(148),
  	  Uploadable: __webpack_require__(149),
  	  MultiEditable: __webpack_require__(150),
  	  Textable: __webpack_require__(221)
  	};

  	/***/ }),
  	/* 66 */
  	/***/ (function(module, exports) {

  	/**
  	 * Expose `xor`
  	 */

  	module.exports = xor;

  	/**
  	 * XOR utility
  	 *
  	 * T T F
  	 * T F T
  	 * F T T
  	 * F F F
  	 *
  	 * @param {Boolean} a
  	 * @param {Boolean} b
  	 * @return {Boolean}
  	 */

  	function xor(a, b) {
  	  return !a != !b;
  	}


  	/***/ }),
  	/* 67 */
  	/***/ (function(module, exports) {

  	/**
  	 * Global Names
  	 */

  	var globals = /\b(Array|Date|Object|Math|JSON)\b/g;

  	/**
  	 * Return immediate identifiers parsed from `str`.
  	 *
  	 * @param {String} str
  	 * @param {String|Function} map function or prefix
  	 * @return {Array}
  	 * @api public
  	 */

  	module.exports = function(str, fn){
  	  var p = unique(props(str));
  	  if (fn && 'string' == typeof fn) fn = prefixed(fn);
  	  if (fn) return map(str, p, fn);
  	  return p;
  	};

  	/**
  	 * Return immediate identifiers in `str`.
  	 *
  	 * @param {String} str
  	 * @return {Array}
  	 * @api private
  	 */

  	function props(str) {
  	  return str
  	    .replace(/\.\w+|\w+ *\(|"[^"]*"|'[^']*'|\/([^/]+)\//g, '')
  	    .replace(globals, '')
  	    .match(/[a-zA-Z_]\w*/g)
  	    || [];
  	}

  	/**
  	 * Return `str` with `props` mapped with `fn`.
  	 *
  	 * @param {String} str
  	 * @param {Array} props
  	 * @param {Function} fn
  	 * @return {String}
  	 * @api private
  	 */

  	function map(str, props, fn) {
  	  var re = /\.\w+|\w+ *\(|"[^"]*"|'[^']*'|\/([^/]+)\/|[a-zA-Z_]\w*/g;
  	  return str.replace(re, function(_){
  	    if ('(' == _[_.length - 1]) return fn(_);
  	    if (!~props.indexOf(_)) return _;
  	    return fn(_);
  	  });
  	}

  	/**
  	 * Return unique array.
  	 *
  	 * @param {Array} arr
  	 * @return {Array}
  	 * @api private
  	 */

  	function unique(arr) {
  	  var ret = [];

  	  for (var i = 0; i < arr.length; i++) {
  	    if (~ret.indexOf(arr[i])) continue;
  	    ret.push(arr[i]);
  	  }

  	  return ret;
  	}

  	/**
  	 * Map with prefix `str`.
  	 */

  	function prefixed(str) {
  	  return function(_){
  	    return str + _;
  	  };
  	}


  	/***/ }),
  	/* 68 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var Scribe = __webpack_require__(152);

  	var config = __webpack_require__(2);

  	var scribePluginFormatterPlainTextConvertNewLinesToHTML = __webpack_require__(191);

  	var scribePluginLinkPromptCommand = __webpack_require__(192);

  	var scribePluginSanitizer = __webpack_require__(197);

  	var sanitizeDefaults = {
  	  p: true,
  	  a: {
  	    href: true,
  	    target: '_blank',
  	    rel: true
  	  },
  	  i: true,
  	  b: true,
  	  strong: true,
  	  em: true
  	};
  	module.exports = {
  	  initScribeInstance: function initScribeInstance(el, scribeOptions, configureScribe) {
  	    scribeOptions = scribeOptions || {};
  	    var scribeConfig = {
  	      debug: config.scribeDebug
  	    };
  	    var tags = sanitizeDefaults;

  	    if (_.isObject(scribeOptions)) {
  	      scribeConfig = Object.assign(scribeConfig, scribeOptions);
  	    }

  	    var scribe = new Scribe(el, scribeConfig);

  	    if (scribeOptions.hasOwnProperty("tags")) {
  	      tags = Object.assign(sanitizeDefaults, scribeOptions.tags);
  	    }

  	    scribe.use(scribePluginFormatterPlainTextConvertNewLinesToHTML());
  	    scribe.use(scribePluginLinkPromptCommand());
  	    scribe.use(scribePluginSanitizer({
  	      tags: tags
  	    }));

  	    if (_.isFunction(configureScribe)) {
  	      configureScribe.call(this, scribe);
  	    }

  	    return scribe;
  	  },
  	  execTextBlockCommand: function execTextBlockCommand(scribeInstance, cmdName) {
  	    if (_.isUndefined(scribeInstance)) {
  	      throw "No Scribe instance found to query command";
  	    }

  	    var cmd = scribeInstance.getCommand(cmdName);
  	    scribeInstance.el.focus();
  	    return cmd.execute();
  	  },
  	  queryTextBlockCommandState: function queryTextBlockCommandState(scribeInstance, cmdName) {
  	    if (_.isUndefined(scribeInstance)) {
  	      throw "No Scribe instance found to query command";
  	    }

  	    var cmd = scribeInstance.getCommand(cmdName),
  	        sel = new scribeInstance.api.Selection();
  	    return sel.range && cmd.queryState();
  	  }
  	};

  	/***/ }),
  	/* 69 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  function isUndoKeyCombination(event) {
  	    return !event.shiftKey && (event.metaKey || (event.ctrlKey && !event.altKey)) && event.keyCode === 90;
  	  }

  	  function isRedoKeyCombination(event) {
  	    return event.shiftKey && (event.metaKey || (event.ctrlKey && !event.altKey)) && event.keyCode === 90;
  	  }

  	  return {
  	    isUndoKeyCombination: isUndoKeyCombination,
  	    isRedoKeyCombination: isRedoKeyCombination
  	  };
  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

  	/***/ }),
  	/* 70 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  return {
  	    contentChanged: "scribe:content-changed",
  	    legacyContentChanged: "content-changed",
  	    destroy: "scribe:destroy"
  	  };
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 71 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /**
  	   * A specialized version of `_.forEach` for arrays without support for callback
  	   * shorthands or `this` binding.
  	   *
  	   * @private
  	   * @param {Array} array The array to iterate over.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @returns {Array} Returns `array`.
  	   */
  	  function arrayEach(array, iteratee) {
  	    var index = -1,
  	        length = array.length;

  	    while (++index < length) {
  	      if (iteratee(array[index], index, array) === false) {
  	        break;
  	      }
  	    }
  	    return array;
  	  }

  	  return arrayEach;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 72 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(73), __webpack_require__(74)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(baseFor, keys) {

  	  /**
  	   * The base implementation of `_.forOwn` without support for callback
  	   * shorthands and `this` binding.
  	   *
  	   * @private
  	   * @param {Object} object The object to iterate over.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @returns {Object} Returns `object`.
  	   */
  	  function baseForOwn(object, iteratee) {
  	    return baseFor(object, iteratee, keys);
  	  }

  	  return baseForOwn;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 73 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(201)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(toObject) {

  	  /**
  	   * The base implementation of `baseForIn` and `baseForOwn` which iterates
  	   * over `object` properties returned by `keysFunc` invoking `iteratee` for
  	   * each property. Iterator functions may exit iteration early by explicitly
  	   * returning `false`.
  	   *
  	   * @private
  	   * @param {Object} object The object to iterate over.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @param {Function} keysFunc The function to get the keys of `object`.
  	   * @returns {Object} Returns `object`.
  	   */
  	  function baseFor(object, iteratee, keysFunc) {
  	    var index = -1,
  	        iterable = toObject(object),
  	        props = keysFunc(object),
  	        length = props.length;

  	    while (++index < length) {
  	      var key = props[index];
  	      if (iteratee(iterable[key], key, iterable) === false) {
  	        break;
  	      }
  	    }
  	    return object;
  	  }

  	  return baseFor;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 74 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7), __webpack_require__(19), __webpack_require__(14), __webpack_require__(204)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(isLength, isNative, isObject, shimKeys) {

  	  /* Native method references for those with the same name as other `lodash` methods. */
  	  var nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;

  	  /**
  	   * Creates an array of the own enumerable property names of `object`.
  	   *
  	   * **Note:** Non-object values are coerced to objects. See the
  	   * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
  	   * for more details.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Object
  	   * @param {Object} object The object to inspect.
  	   * @returns {Array} Returns the array of property names.
  	   * @example
  	   *
  	   * function Foo() {
  	   *   this.a = 1;
  	   *   this.b = 2;
  	   * }
  	   *
  	   * Foo.prototype.c = 3;
  	   *
  	   * _.keys(new Foo);
  	   * // => ['a', 'b'] (iteration order is not guaranteed)
  	   *
  	   * _.keys('hi');
  	   * // => ['0', '1']
  	   */
  	  var keys = !nativeKeys ? shimKeys : function(object) {
  	    if (object) {
  	      var Ctor = object.constructor,
  	          length = object.length;
  	    }
  	    if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
  	        (typeof object != 'function' && (length && isLength(length)))) {
  	      return shimKeys(object);
  	    }
  	    return isObject(object) ? nativeKeys(object) : [];
  	  };

  	  return keys;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 75 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19), __webpack_require__(76)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(isNative, root) {

  	  /** Used to detect functions containing a `this` reference. */
  	  var reThis = /\bthis\b/;

  	  /** Used for native method references. */
  	  var objectProto = Object.prototype;

  	  /** Used to detect DOM support. */
  	  var document = (document = root.window) && document.document;

  	  /** Native method references. */
  	  var propertyIsEnumerable = objectProto.propertyIsEnumerable;

  	  /**
  	   * An object environment feature flags.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @type Object
  	   */
  	  var support = {};

  	  (function(x) {

  	    /**
  	     * Detect if functions can be decompiled by `Function#toString`
  	     * (all but Firefox OS certified apps, older Opera mobile browsers, and
  	     * the PlayStation 3; forced `false` for Windows 8 apps).
  	     *
  	     * @memberOf _.support
  	     * @type boolean
  	     */
  	    support.funcDecomp = !isNative(root.WinRTError) && reThis.test(function() { return this; });

  	    /**
  	     * Detect if `Function#name` is supported (all but IE).
  	     *
  	     * @memberOf _.support
  	     * @type boolean
  	     */
  	    support.funcNames = typeof Function.name == 'string';

  	    /**
  	     * Detect if the DOM is supported.
  	     *
  	     * @memberOf _.support
  	     * @type boolean
  	     */
  	    try {
  	      support.dom = document.createDocumentFragment().nodeType === 11;
  	    } catch(e) {
  	      support.dom = false;
  	    }

  	    /**
  	     * Detect if `arguments` object indexes are non-enumerable.
  	     *
  	     * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
  	     * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
  	     * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
  	     * checks for indexes that exceed their function's formal parameters with
  	     * associated values of `0`.
  	     *
  	     * @memberOf _.support
  	     * @type boolean
  	     */
  	    try {
  	      support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
  	    } catch(e) {
  	      support.nonEnumArgs = true;
  	    }
  	  }(0, 0));

  	  return support;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 76 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /** Used to determine if values are of the language type `Object`. */
  	  var objectTypes = {
  	    'function': true,
  	    'object': true
  	  };

  	  /** Detect free variable `exports`. */
  	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  	  /** Detect free variable `module`. */
  	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  	  /** Detect free variable `global` from Node.js. */
  	  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;

  	  /** Detect free variable `window`. */
  	  var freeWindow = objectTypes[typeof window] && window;

  	  /**
  	   * Used as a reference to the global object.
  	   *
  	   * The `this` value is used if it is the global object to avoid Greasemonkey's
  	   * restricted `window` object, otherwise the `window` object is used.
  	   */
  	  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || this;

  	  return root;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

  	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(205)(module), __webpack_require__(17)));

  	/***/ }),
  	/* 77 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /**
  	   * Copies the values of `source` to `array`.
  	   *
  	   * @private
  	   * @param {Array} source The array to copy values from.
  	   * @param {Array} [array=[]] The array to copy values to.
  	   * @returns {Array} Returns `array`.
  	   */
  	  function arrayCopy(source, array) {
  	    var index = -1,
  	        length = source.length;

  	    array || (array = Array(length));
  	    while (++index < length) {
  	      array[index] = source[index];
  	    }
  	    return array;
  	  }

  	  return arrayCopy;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 78 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7), __webpack_require__(15)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(isLength, isObjectLike) {

  	  /** `Object#toString` result references. */
  	  var argsTag = '[object Arguments]',
  	      arrayTag = '[object Array]',
  	      boolTag = '[object Boolean]',
  	      dateTag = '[object Date]',
  	      errorTag = '[object Error]',
  	      funcTag = '[object Function]',
  	      mapTag = '[object Map]',
  	      numberTag = '[object Number]',
  	      objectTag = '[object Object]',
  	      regexpTag = '[object RegExp]',
  	      setTag = '[object Set]',
  	      stringTag = '[object String]',
  	      weakMapTag = '[object WeakMap]';

  	  var arrayBufferTag = '[object ArrayBuffer]',
  	      float32Tag = '[object Float32Array]',
  	      float64Tag = '[object Float64Array]',
  	      int8Tag = '[object Int8Array]',
  	      int16Tag = '[object Int16Array]',
  	      int32Tag = '[object Int32Array]',
  	      uint8Tag = '[object Uint8Array]',
  	      uint8ClampedTag = '[object Uint8ClampedArray]',
  	      uint16Tag = '[object Uint16Array]',
  	      uint32Tag = '[object Uint32Array]';

  	  /** Used to identify `toStringTag` values of typed arrays. */
  	  var typedArrayTags = {};
  	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  	  typedArrayTags[uint32Tag] = true;
  	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  	  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  	  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  	  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  	  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  	  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  	  /** Used for native method references. */
  	  var objectProto = Object.prototype;

  	  /**
  	   * Used to resolve the `toStringTag` of values.
  	   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
  	   * for more details.
  	   */
  	  var objToString = objectProto.toString;

  	  /**
  	   * Checks if `value` is classified as a typed array.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Lang
  	   * @param {*} value The value to check.
  	   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
  	   * @example
  	   *
  	   * _.isTypedArray(new Uint8Array);
  	   * // => true
  	   *
  	   * _.isTypedArray([]);
  	   * // => false
  	   */
  	  function isTypedArray(value) {
  	    return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
  	  }

  	  return isTypedArray;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 79 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /**
  	   * Copies the properties of `source` to `object`.
  	   *
  	   * @private
  	   * @param {Object} source The object to copy properties from.
  	   * @param {Object} [object={}] The object to copy properties to.
  	   * @param {Array} props The property names to copy.
  	   * @returns {Object} Returns `object`.
  	   */
  	  function baseCopy(source, object, props) {
  	    if (!props) {
  	      props = object;
  	      object = {};
  	    }
  	    var index = -1,
  	        length = props.length;

  	    while (++index < length) {
  	      var key = props[index];
  	      object[key] = source[key];
  	    }
  	    return object;
  	  }

  	  return baseCopy;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 80 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(212)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(identity) {

  	  /**
  	   * A specialized version of `baseCallback` which only supports `this` binding
  	   * and specifying the number of arguments to provide to `func`.
  	   *
  	   * @private
  	   * @param {Function} func The function to bind.
  	   * @param {*} thisArg The `this` binding of `func`.
  	   * @param {number} [argCount] The number of arguments to provide to `func`.
  	   * @returns {Function} Returns the callback.
  	   */
  	  function bindCallback(func, thisArg, argCount) {
  	    if (typeof func != 'function') {
  	      return identity;
  	    }
  	    if (typeof thisArg == 'undefined') {
  	      return func;
  	    }
  	    switch (argCount) {
  	      case 1: return function(value) {
  	        return func.call(thisArg, value);
  	      };
  	      case 3: return function(value, index, collection) {
  	        return func.call(thisArg, value, index, collection);
  	      };
  	      case 4: return function(accumulator, value, index, collection) {
  	        return func.call(thisArg, accumulator, value, index, collection);
  	      };
  	      case 5: return function(value, other, key, object, source) {
  	        return func.call(thisArg, value, other, key, object, source);
  	      };
  	    }
  	    return function() {
  	      return func.apply(thisArg, arguments);
  	    };
  	  }

  	  return bindCallback;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 81 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var BlockPositioner = function BlockPositioner(block, mediator) {
  	  this.mediator = mediator;
  	  this.block = block;

  	  this._ensureElement();

  	  this._bindFunctions();

  	  this.initialize();
  	};

  	Object.assign(BlockPositioner.prototype, __webpack_require__(6), __webpack_require__(11), {
  	  bound: ['toggle', 'show', 'hide'],
  	  className: 'st-block-positioner',
  	  visibleClass: 'active',
  	  initialize: function initialize() {},
  	  toggle: function toggle() {
  	    this.mediator.trigger('block-positioner-select:render', this);
  	    this.el.classList.toggle(this.visibleClass);
  	  },
  	  show: function show() {
  	    this.el.classList.add(this.visibleClass);
  	  },
  	  hide: function hide() {
  	    this.el.classList.remove(this.visibleClass);
  	  }
  	});
  	module.exports = BlockPositioner;

  	/***/ }),
  	/* 82 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var Dom = __webpack_require__(3);

  	var template = ["<span class='st-block-positioner__selected-value'></span>", "<select class='st-block-positioner__select'></select>"].join("\n");

  	var BlockPositionerSelect = function BlockPositionerSelect(mediator) {
  	  this.mediator = mediator;

  	  this._ensureElement();

  	  this._bindFunctions();

  	  this.initialize();
  	};

  	Object.assign(BlockPositionerSelect.prototype, __webpack_require__(6), __webpack_require__(11), {
  	  total_blocks: 0,
  	  bound: ['onBlockCountChange', 'onSelectChange'],
  	  className: 'st-block-positioner__inner',
  	  initialize: function initialize() {
  	    this.el.insertAdjacentHTML("beforeend", template);
  	    this.select = this.el.querySelector('.st-block-positioner__select');
  	    this.positioner = null;
  	    this.select.addEventListener('change', this.onSelectChange);
  	  },
  	  onBlockCountChange: function onBlockCountChange(new_count) {
  	    if (new_count !== this.total_blocks) {
  	      this.total_blocks = new_count;
  	      this.renderPositionList();
  	    }
  	  },
  	  onSelectChange: function onSelectChange() {
  	    var val = this.select.value;

  	    if (val !== 0) {
  	      this.mediator.trigger("block:changePosition", this.positioner.block, val, val === 1 ? 'before' : 'after');
  	      this.positioner.toggle();
  	    }
  	  },
  	  renderPositionList: function renderPositionList() {
  	    var inner = "<option value='0'>" + i18n.t("general:position") + "</option>";

  	    for (var i = 1; i <= this.total_blocks; i++) {
  	      inner += "<option value=" + i + ">" + i + "</option>";
  	    }

  	    this.select.innerHTML = inner;
  	  },
  	  renderInBlock: function renderInBlock(positioner) {
  	    // hide old
  	    if (this.positioner && this.positioner !== positioner) {
  	      this.positioner.hide();
  	    } // add new


  	    this.positioner = positioner;
  	    this.select.value = 0;
  	    Dom.remove(this.el);
  	    positioner.el.appendChild(this.el);
  	  }
  	});
  	module.exports = BlockPositionerSelect;

  	/***/ }),
  	/* 83 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var config = __webpack_require__(2);

  	var BlockDeletion = function BlockDeletion() {
  	  this._ensureElement();

  	  this._bindFunctions();
  	};

  	Object.assign(BlockDeletion.prototype, __webpack_require__(6), __webpack_require__(11), {
  	  tagName: 'a',
  	  className: 'st-block-ui-btn__delete',
  	  attributes: {
  	    html: function html() {
  	      return "<svg role=\"img\" class=\"st-icon\">\n                   <use xlink:href=\"".concat(config.defaults.iconUrl, "#cross\"/>\n                 </svg>");
  	    },
  	    'data-icon': 'close'
  	  }
  	});
  	module.exports = BlockDeletion;

  	/***/ }),
  	/* 84 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var utils = __webpack_require__(1);

  	var bestNameFromField = function bestNameFromField(field) {
  	  var msg = field.getAttribute("data-st-name") || field.getAttribute("name");

  	  if (!msg) {
  	    msg = 'Field';
  	  }

  	  return utils.capitalize(msg);
  	};

  	module.exports = {
  	  errors: [],
  	  valid: function valid() {
  	    this.performValidations();
  	    return this.errors.length === 0;
  	  },
  	  // This method actually does the leg work
  	  // of running our validators and custom validators
  	  performValidations: function performValidations() {
  	    this.resetErrors();
  	    var required_fields = this.$('.st-required');
  	    Array.prototype.forEach.call(required_fields, function (f, i) {
  	      this.validateField(f);
  	    }.bind(this));
  	    this.validations.forEach(this.runValidator, this);
  	    this.el.classList.toggle('st-block--with-errors', this.errors.length > 0);
  	  },
  	  // Everything in here should be a function that returns true or false
  	  validations: [],
  	  validateField: function validateField(field) {
  	    var content = field.getAttribute('contenteditable') ? field.textContent : field.value;

  	    if (content.length === 0) {
  	      this.setError(field, i18n.t("errors:block_empty", {
  	        name: bestNameFromField(field)
  	      }));
  	    }
  	  },
  	  runValidator: function runValidator(validator) {
  	    if (!_.isUndefined(this[validator])) {
  	      this[validator].call(this);
  	    }
  	  },
  	  setError: function setError(field, reason) {
  	    var msg = this.addMessage(reason, "st-msg--error");
  	    field.classList.add('st-error');
  	    this.errors.push({
  	      field: field,
  	      reason: reason,
  	      msg: msg
  	    });
  	  },
  	  resetErrors: function resetErrors() {
  	    this.errors.forEach(function (error) {
  	      error.field.classList.remove('st-error');
  	      error.msg.remove();
  	    });
  	    this.messages.classList.remove("st-block__messages--is-visible");
  	    this.errors = [];
  	  }
  	};

  	/***/ }),
  	/* 85 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var utils = __webpack_require__(1);

  	var EventBus = __webpack_require__(4);

  	module.exports = {
  	  /**
  	   * Internal storage object for the block
  	   */
  	  blockStorage: {},

  	  /**
  	   * Initialize the store, including the block type
  	   */
  	  createStore: function createStore(blockData) {
  	    this.blockStorage = {
  	      type: utils.underscored(this.type),
  	      data: blockData || {}
  	    };
  	  },

  	  /**
  	   * Serialize the block and save the data into the store
  	   */
  	  save: function save() {
  	    var data = this._serializeData();

  	    if (!_.isEmpty(data)) {
  	      this.setData(data);
  	    }
  	  },
  	  getData: function getData() {
  	    this.save();
  	    return this.blockStorage;
  	  },
  	  getBlockData: function getBlockData() {
  	    this.save();
  	    return this.blockStorage.data;
  	  },
  	  _getData: function _getData() {
  	    return this.blockStorage.data;
  	  },

  	  /**
  	   * Set the block data.
  	   * This is used by the save() method.
  	   */
  	  setData: function setData(blockData) {
  	    utils.log("Setting data for block " + this.blockID);
  	    Object.assign(this.blockStorage.data, blockData || {});
  	  },
  	  setAndLoadData: function setAndLoadData(blockData) {
  	    this.setData(blockData);
  	    this.beforeLoadingData();
  	  },
  	  _serializeData: function _serializeData() {},
  	  loadData: function loadData() {},
  	  beforeLoadingData: function beforeLoadingData() {
  	    utils.log("loadData for " + this.blockID);
  	    EventBus.trigger("editor/block/loadData");
  	    this.loadData(this._getData());
  	  },
  	  _loadData: function _loadData() {
  	    utils.log("_loadData is deprecated and will be removed in the future. Please use beforeLoadingData instead.");
  	    this.beforeLoadingData();
  	  },
  	  checkAndLoadData: function checkAndLoadData() {
  	    if (!_.isEmpty(this._getData())) {
  	      this.beforeLoadingData();
  	    }
  	  }
  	};

  	/***/ }),
  	/* 86 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var selectionRange = __webpack_require__(13);

  	var _ = __webpack_require__(0);

  	var utils = __webpack_require__(1);

  	var config = __webpack_require__(2);

  	var EventBus = __webpack_require__(4);

  	var Blocks = __webpack_require__(21);

  	var Dom = __webpack_require__(3);

  	var BLOCK_OPTION_KEYS = ['convertToMarkdown', 'convertFromMarkdown', 'formatBar'];

  	var BlockManager = function BlockManager(SirTrevor) {
  	  this.options = SirTrevor.options;
  	  this.blockOptions = BLOCK_OPTION_KEYS.reduce(function (acc, key) {
  	    acc[key] = SirTrevor.options[key];
  	    return acc;
  	  }, {});
  	  this.instance_scope = SirTrevor.ID;
  	  this.mediator = SirTrevor.mediator;
  	  this.editor = SirTrevor; // REFACTOR: this is a hack until I can focus on reworking the blockmanager

  	  this.wrapper = SirTrevor.wrapper;
  	  this.blocks = [];
  	  this.blockCounts = {};
  	  this.blockTypes = [];

  	  this._setBlocksTypes();

  	  this._setRequired();

  	  this._bindMediatedEvents();

  	  this.initialize();
  	};

  	Object.assign(BlockManager.prototype, __webpack_require__(6), __webpack_require__(30), __webpack_require__(9), {
  	  eventNamespace: 'block',
  	  mediatedEvents: {
  	    'create': 'createBlock',
  	    'createBefore': 'createBlockBefore',
  	    'remove': 'removeBlock',
  	    'rerender': 'rerenderBlock',
  	    'replace': 'replaceBlock',
  	    'focusPrevious': 'focusPreviousBlock',
  	    'focusNext': 'focusNextBlock',
  	    'paste': 'paste'
  	  },
  	  initialize: function initialize() {},
  	  createBlock: function createBlock(type, data, previousSibling) {
  	    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  	    options = Object.assign({
  	      autoFocus: false,
  	      focusAtEnd: false
  	    }, options);
  	    type = utils.classify(type); // Run validations

  	    if (!this.canCreateBlock(type)) {
  	      return;
  	    }

  	    var block = new Blocks[type](data, this.instance_scope, this.mediator, this.blockOptions, this.options);
  	    this.blocks.push(block);

  	    this._incrementBlockTypeCount(type);

  	    this.renderBlock(block, previousSibling);

  	    if (options.autoFocus) {
  	      block.focus();
  	    } else if (options.focusAtEnd) {
  	      block.focusAtEnd();
  	    }

  	    this.triggerBlockCountUpdate();
  	    this.mediator.trigger('block:limitReached', this.blockLimitReached());
  	    this.mediator.trigger('block:created', block);
  	    EventBus.trigger(data ? "block:create:existing" : "block:create:new", block);
  	    utils.log("Block created of type " + type);
  	  },
  	  createBlockBefore: function createBlockBefore(type, data, nextBlock) {
  	    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  	    options = Object.assign({
  	      autoFocus: false,
  	      focusAtEnd: false
  	    }, options);
  	    type = utils.classify(type); // Run validations

  	    if (!this.canCreateBlock(type)) {
  	      return;
  	    }

  	    var block = new Blocks[type](data, this.instance_scope, this.mediator, this.blockOptions, this.options);
  	    this.blocks.push(block);

  	    this._incrementBlockTypeCount(type);

  	    var previousBlock = this.getPreviousBlock(nextBlock);

  	    if (previousBlock) {
  	      this.renderBlock(block, previousBlock.el);
  	    } else {
  	      this.renderBlock(block, this.wrapper.querySelector(".st-top-controls"));
  	    }

  	    if (options.autoFocus) {
  	      block.focus();
  	    } else if (options.focusAtEnd) {
  	      block.focusAtEnd();
  	    }

  	    this.triggerBlockCountUpdate();
  	    this.mediator.trigger('block:limitReached', this.blockLimitReached());
  	    this.mediator.trigger('block:created', block);
  	    EventBus.trigger(data ? "block:create:existing" : "block:create:new", block);
  	    utils.log("Block created of type " + type);
  	  },
  	  removeBlock: function removeBlock(blockID, options) {
  	    options = Object.assign({
  	      transposeContent: false,
  	      focusOnPrevious: false,
  	      focusOnNext: false,
  	      createNextBlock: false
  	    }, options);
  	    var block = this.findBlockById(blockID);
  	    var type = utils.classify(block.type);
  	    var previousBlock = this.getPreviousBlock(block);
  	    var nextBlock = this.getNextBlock(block);

  	    if (options.transposeContent && block.mergeable) {
  	      // Don't allow removal of first block if it's the only block.
  	      if (!previousBlock && this.blocks.length === 1) {
  	        return;
  	      } // If previous block can transpose content then append content.


  	      if (previousBlock && previousBlock.type === "list") {
  	        previousBlock.focusAtEnd();
  	        previousBlock.appendToCurrentItem(block.getScribeInnerContent());
  	      } else if (previousBlock && previousBlock.mergeable) {
  	        previousBlock.appendContent(block.getScribeInnerContent(), {
  	          keepCaretPosition: true
  	        });
  	      } else {
  	        // If there's content and the block above isn't mergeable then
  	        // cancel remove.
  	        if (block.getScribeInnerContent() !== '') {
  	          return;
  	        } // If block before isn't mergeable then we want to still focus.


  	        if (previousBlock) {
  	          previousBlock.focusAtEnd();
  	        } else if (nextBlock) {
  	          // If there wasn't a previous block then
  	          // we'll want to focus on the next block.
  	          nextBlock.focus();
  	        }
  	      }
  	    }

  	    this.mediator.trigger('block-controls:reset');
  	    this.blocks = this.blocks.filter(function (item) {
  	      return item.blockID !== block.blockID;
  	    });
  	    block.remove();

  	    if (previousBlock && nextBlock) {
  	      // Join blocks if they span the removed block
  	      if (this.options.joinListBlocksOnBlockRemove && previousBlock.type === "list" && nextBlock.type === "list") {
  	        var listItems = nextBlock._serializeData().listItems;

  	        nextBlock.remove();
  	        var currentListItem = previousBlock.getCurrentTextEditor();
  	        var currentSelection = selectionRange(currentListItem.scribe.el);
  	        listItems.forEach(function (item) {
  	          previousBlock.addListItem(item.content);
  	        });
  	        previousBlock.focusOn(currentListItem, {
  	          caretPosition: currentSelection.start
  	        });
  	      }
  	    }

  	    if (options.focusOnPrevious && previousBlock) {
  	      previousBlock.focusAtEnd();
  	    }

  	    if (options.focusOnNext) {
  	      if (nextBlock) {
  	        nextBlock.focus();
  	      } else if (options.createNextBlock) {
  	        this.createBlock("text", null, null, {
  	          autoFocus: true
  	        });
  	      }
  	    }

  	    this._decrementBlockTypeCount(type);

  	    this.triggerBlockCountUpdate();
  	    this.mediator.trigger('block:limitReached', this.blockLimitReached());
  	    EventBus.trigger('block:remove', blockID);
  	  },
  	  replaceBlock: function replaceBlock(blockNode, type, data) {
  	    var block = this.findBlockById(blockNode.id);
  	    this.createBlock(type, data || null, blockNode);
  	    this.removeBlock(blockNode.id);
  	    block.remove();
  	  },
  	  renderBlock: function renderBlock(block, previousSibling) {
  	    var _this = this;

  	    // REFACTOR: this will have to do until we're able to address
  	    // the block manager
  	    var blockElement = block.render().el;

  	    if (previousSibling) {
  	      Dom.insertAfter(blockElement, previousSibling);
  	    } else {
  	      this.wrapper.appendChild(blockElement);
  	    }

  	    block.trigger("onRender");

  	    if (this.options.selectionMouse) {
  	      blockElement.addEventListener("mouseenter", function () {
  	        if (!_this.editor.mouseDown) return;

  	        var blockPosition = _this.getBlockPosition(block.el);

  	        _this.mediator.trigger("selection:update", blockPosition);
  	      });
  	      blockElement.addEventListener("mousedown", function (ev) {
  	        var blockPosition = _this.getBlockPosition(block.el);

  	        var options = {
  	          mouseEnabled: true,
  	          expand: ev.shiftKey || ev.metaKey
  	        };

  	        _this.mediator.trigger("selection:start", blockPosition, options);
  	      });
  	    }
  	  },
  	  rerenderBlock: function rerenderBlock(blockID) {
  	    var block = this.findBlockById(blockID);

  	    if (!_.isUndefined(block) && !block.isEmpty() && block.drop_options.re_render_on_reorder) {
  	      block.beforeLoadingData();
  	    }
  	  },
  	  getPreviousBlock: function getPreviousBlock(block) {
  	    var blockPosition = this.getBlockPosition(block.el);

  	    if (blockPosition < 1) {
  	      return;
  	    }

  	    var previousBlock = this.wrapper.querySelectorAll('.st-block')[blockPosition - 1];
  	    return this.findBlockById(previousBlock.getAttribute('id'));
  	  },
  	  getNextBlock: function getNextBlock(block) {
  	    var blockPosition = this.getBlockPosition(block.el);

  	    if (blockPosition < 0 || blockPosition >= this.blocks.length - 1) {
  	      return;
  	    }

  	    return this.findBlockById(this.wrapper.querySelectorAll('.st-block')[blockPosition + 1].getAttribute('id'));
  	  },
  	  getBlockPosition: function getBlockPosition(block) {
  	    return Array.prototype.indexOf.call(this.wrapper.querySelectorAll('.st-block'), block);
  	  },
  	  focusPreviousBlock: function focusPreviousBlock(blockID) {
  	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	    options = Object.assign({
  	      force: false
  	    }, options);
  	    var block = this.findBlockById(blockID);

  	    if (block && (block.mergeable || options.force)) {
  	      var previousBlock = this.getPreviousBlock(block);

  	      if (previousBlock && previousBlock.mergeable) {
  	        previousBlock.focusAtEnd();
  	      } else if (options.force) {
  	        block.focus();
  	      }
  	    }
  	  },
  	  focusNextBlock: function focusNextBlock(blockID) {
  	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	    options = Object.assign({
  	      force: false
  	    }, options);
  	    var block = this.findBlockById(blockID);

  	    if (block && (block.mergeable || options.force)) {
  	      var nextBlock = this.getNextBlock(block);

  	      if (nextBlock && nextBlock.mergeable) {
  	        nextBlock.focusAtStart();
  	      } else if (options.force) {
  	        block.focusAtEnd();
  	      }
  	    }
  	  },
  	  paste: function paste(blocks) {
  	    var _this2 = this;

  	    var currentBlock = utils.getBlockBySelection();

  	    if (currentBlock) {
  	      currentBlock.split();
  	      var nextBlock = this.getNextBlock(currentBlock);

  	      if (currentBlock.isEmpty()) {
  	        this.removeBlock(currentBlock.blockID);
  	      }

  	      if (nextBlock) {
  	        blocks.forEach(function (block) {
  	          _this2.createBlockBefore(block.type, block.data, nextBlock, {
  	            focusAtEnd: true
  	          });
  	        });
  	        return;
  	      }
  	    }

  	    blocks.forEach(function (block) {
  	      _this2.createBlock(block.type, block.data, undefined, {
  	        focusAtEnd: true
  	      });
  	    });
  	  },
  	  triggerBlockCountUpdate: function triggerBlockCountUpdate() {
  	    this.mediator.trigger('block:countUpdate', this.blocks.length);
  	  },
  	  canCreateBlock: function canCreateBlock(type) {
  	    if (this.blockLimitReached()) {
  	      utils.log("Cannot add any more blocks. Limit reached.");
  	      return false;
  	    }

  	    if (!this.isBlockTypeAvailable(type)) {
  	      utils.log("Block type not available " + type);
  	      return false;
  	    } // Can we have another one of these blocks?


  	    if (!this.canAddBlockType(type)) {
  	      utils.log("Block Limit reached for type " + type);
  	      return false;
  	    }

  	    return true;
  	  },
  	  validateBlockTypesExist: function validateBlockTypesExist(shouldValidate) {
  	    if (config.skipValidation || !shouldValidate) {
  	      return false;
  	    }

  	    (this.required || []).forEach(function (type, index) {
  	      if (!this.isBlockTypeAvailable(type)) {
  	        return;
  	      }

  	      if (this._getBlockTypeCount(type) === 0) {
  	        utils.log("Failed validation on required block type " + type);
  	        this.mediator.trigger('errors:add', {
  	          text: i18n.t("errors:type_missing", {
  	            type: type
  	          })
  	        });
  	      } else {
  	        var blocks = this.getBlocksByType(type).filter(function (b) {
  	          return !b.isEmpty();
  	        });

  	        if (blocks.length > 0) {
  	          return false;
  	        }

  	        this.mediator.trigger('errors:add', {
  	          text: i18n.t("errors:required_type_empty", {
  	            type: type
  	          })
  	        });
  	        utils.log("A required block type " + type + " is empty");
  	      }
  	    }, this);
  	  },
  	  findBlockById: function findBlockById(blockID) {
  	    return this.blocks.find(function (b) {
  	      return b.blockID === blockID;
  	    });
  	  },
  	  getBlocksByType: function getBlocksByType(type) {
  	    return this.blocks.filter(function (b) {
  	      return utils.classify(b.type) === type;
  	    });
  	  },
  	  getBlocksByIDs: function getBlocksByIDs(block_ids) {
  	    return this.blocks.filter(function (b) {
  	      return block_ids.includes(b.blockID);
  	    });
  	  },
  	  blockLimitReached: function blockLimitReached() {
  	    return this.options.blockLimit !== 0 && this.blocks.length >= this.options.blockLimit;
  	  },
  	  isBlockTypeAvailable: function isBlockTypeAvailable(t) {
  	    return this.blockTypes.includes(t);
  	  },
  	  canAddBlockType: function canAddBlockType(type) {
  	    var block_type_limit = this._getBlockTypeLimit(type);

  	    return !(block_type_limit !== 0 && this._getBlockTypeCount(type) >= block_type_limit);
  	  },
  	  _setBlocksTypes: function _setBlocksTypes() {
  	    this.blockTypes = this.options.blockTypes || Object.keys(Blocks);
  	  },
  	  _setRequired: function _setRequired() {
  	    this.required = false;

  	    if (Array.isArray(this.options.required) && !_.isEmpty(this.options.required)) {
  	      this.required = this.options.required;
  	    }
  	  },
  	  _incrementBlockTypeCount: function _incrementBlockTypeCount(type) {
  	    this.blockCounts[type] = _.isUndefined(this.blockCounts[type]) ? 1 : this.blockCounts[type] + 1;
  	  },
  	  _decrementBlockTypeCount: function _decrementBlockTypeCount(type) {
  	    this.blockCounts[type] = _.isUndefined(this.blockCounts[type]) ? 1 : this.blockCounts[type] - 1;
  	  },
  	  _getBlockTypeCount: function _getBlockTypeCount(type) {
  	    return _.isUndefined(this.blockCounts[type]) ? 0 : this.blockCounts[type];
  	  },
  	  _blockLimitReached: function _blockLimitReached() {
  	    return this.options.blockLimit !== 0 && this.blocks.length >= this.options.blockLimit;
  	  },
  	  _getBlockTypeLimit: function _getBlockTypeLimit(t) {
  	    if (!this.isBlockTypeAvailable(t)) {
  	      return 0;
  	    }

  	    return parseInt(_.isUndefined(this.options.blockTypeLimits[t]) ? 0 : this.options.blockTypeLimits[t], 10);
  	  }
  	});
  	module.exports = BlockManager;

  	/***/ }),
  	/* 87 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var utils = __webpack_require__(1);

  	var Dom = __webpack_require__(3);

  	var Events = __webpack_require__(10);

  	var BlockReorder = __webpack_require__(39);

  	var BLOCK_TEMPLATE = __webpack_require__(223);

  	var SimpleBlock = function SimpleBlock(data, instance_id, mediator, options, editorOptions) {
  	  this.createStore(data);
  	  this.blockID = _.uniqueId('st-block-');
  	  this.instanceID = instance_id;
  	  this.mediator = mediator;
  	  this.options = options || {};
  	  this.editorOptions = editorOptions || {};

  	  this._ensureElement();

  	  this._bindFunctions();

  	  this.initialize.apply(this, arguments);
  	};

  	Object.assign(SimpleBlock.prototype, __webpack_require__(6), __webpack_require__(9), __webpack_require__(11), __webpack_require__(85), {
  	  focus: function focus() {},
  	  valid: function valid() {
  	    return true;
  	  },
  	  className: 'st-block',
  	  block_template: BLOCK_TEMPLATE,
  	  attributes: function attributes() {
  	    return {
  	      'id': this.blockID,
  	      'data-type': this.type,
  	      'data-instance': this.instanceID
  	    };
  	  },
  	  title: function title() {
  	    return i18n.t("blocks:".concat(this.type, ":title")) || utils.titleize(this.type.replace(/[\W_]/g, ' '));
  	  },
  	  blockCSSClass: function blockCSSClass() {
  	    this.blockCSSClass = utils.toSlug(this.type);
  	    return this.blockCSSClass;
  	  },
  	  type: '',
  	  class: function _class() {
  	    return utils.classify(this.type);
  	  },
  	  editorHTML: '',
  	  initialize: function initialize() {},
  	  onBlockRender: function onBlockRender() {},
  	  beforeBlockRender: function beforeBlockRender() {},
  	  _setBlockInner: function _setBlockInner() {
  	    var editor_html = _.result(this, 'editorHTML');

  	    this.el.insertAdjacentHTML("beforeend", this.block_template(editor_html));
  	    this.inner = this.el.querySelector('.st-block__inner');
  	  },
  	  render: function render() {
  	    this.beforeBlockRender();

  	    this._setBlockInner();

  	    this._blockPrepare();

  	    return this;
  	  },
  	  _blockPrepare: function _blockPrepare() {
  	    this._initUI();

  	    this._initMessages();

  	    this.checkAndLoadData();
  	    this.el.classList.add('st-item-ready');
  	    this.on("onRender", this.onBlockRender);
  	    this.save();
  	  },
  	  _withUIComponent: function _withUIComponent(component, className, callback) {
  	    this.ui.appendChild(component.render().el);

  	    if (className && callback) {
  	      Events.delegate(this.ui, className, 'click', callback);
  	    }
  	  },
  	  _initUI: function _initUI() {
  	    var ui_element = Dom.createElement("div", {
  	      'class': 'st-block__ui'
  	    });
  	    this.el.appendChild(ui_element);
  	    this.ui = ui_element;

  	    this._initUIComponents();
  	  },
  	  _initMessages: function _initMessages() {
  	    var msgs_element = Dom.createElement("div", {
  	      'class': 'st-block__messages'
  	    });
  	    this.inner.insertBefore(msgs_element, this.inner.firstChild);
  	    this.messages = msgs_element;
  	  },
  	  addMessage: function addMessage(msg, additionalClass) {
  	    msg = Dom.createElement("span", {
  	      html: msg,
  	      class: "st-msg " + additionalClass
  	    });
  	    this.messages.appendChild(msg);
  	    this.messages.classList.add('st-block__messages--is-visible');
  	    return msg;
  	  },
  	  resetMessages: function resetMessages() {
  	    this.messages.innerHTML = '';
  	    this.messages.classList.remove('st-block__messages--is-visible');
  	  },
  	  _initUIComponents: function _initUIComponents() {
  	    this._withUIComponent(new BlockReorder(this.el));
  	  }
  	});
  	SimpleBlock.fn = SimpleBlock.prototype; // Allow our Block to be extended.

  	SimpleBlock.extend = __webpack_require__(89);
  	module.exports = SimpleBlock;

  	/***/ }),
  	/* 88 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var config = __webpack_require__(2);

  	module.exports = function () {
  	  return "\n    <button class=\"st-block-addition\" type=\"button\">\n      <span class=\"st-block-addition__button\">\n        <svg role=\"img\" class=\"st-icon\">\n          <use xlink:href=\"".concat(config.defaults.iconUrl, "#plus\"/>\n        </svg>\n      </span>\n    </button>\n  ");
  	};

  	/***/ }),
  	/* 89 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/*
  	  Backbone Inheritence 
  	  --
  	  From: https://github.com/documentcloud/backbone/blob/master/backbone.js
  	  Backbone.js 0.9.2
  	  (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.
  	*/

  	module.exports = function (protoProps, staticProps) {
  	  var parent = this;
  	  var child; // The constructor function for the new subclass is either defined by you
  	  // (the "constructor" property in your `extend` definition), or defaulted
  	  // by us to simply call the parent's constructor.

  	  if (protoProps && protoProps.hasOwnProperty('constructor')) {
  	    child = protoProps.constructor;
  	  } else {
  	    child = function child() {
  	      return parent.apply(this, arguments);
  	    };
  	  } // Add static properties to the constructor function, if supplied.


  	  Object.assign(child, parent, staticProps); // Set the prototype chain to inherit from `parent`, without calling
  	  // `parent`'s constructor function.

  	  var Surrogate = function Surrogate() {
  	    this.constructor = child;
  	  };

  	  Surrogate.prototype = parent.prototype;
  	  child.prototype = new Surrogate(); // jshint ignore:line
  	  // Add prototype properties (instance properties) to the subclass,
  	  // if supplied.

  	  if (protoProps) {
  	    Object.assign(child.prototype, protoProps);
  	  } // Set a convenience property in case the parent's prototype is needed
  	  // later.


  	  child.__super__ = parent.prototype;
  	  return child;
  	};

  	/***/ }),
  	/* 90 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _require = __webpack_require__(16),
  	    createBlocksFromParagraphs = _require.createBlocksFromParagraphs,
  	    isAtStart = _require.isAtStart,
  	    isAtEnd = _require.isAtEnd,
  	    isSelectedFromStart = _require.isSelectedFromStart,
  	    isSelectedToEnd = _require.isSelectedToEnd,
  	    selectToEnd = _require.selectToEnd;

  	var ScribeTextBlockPlugin = function ScribeTextBlockPlugin(block) {
  	  return function (scribe) {
  	    var isAtStartBoolean = false;
  	    scribe.el.addEventListener('keydown', function (ev) {
  	      if (block.supressKeyListeners) {
  	        return;
  	      }

  	      if (ev.key === "Enter" && !ev.shiftKey) {
  	        // enter pressed
  	        ev.preventDefault();

  	        if (isAtEnd(scribe)) {
  	          // Remove any bad characters after current selection.
  	          selectToEnd(scribe).extractContents();
  	          block.mediator.trigger("block:create", 'Text', null, block.el, {
  	            autoFocus: true
  	          });
  	        } else {
  	          createBlocksFromParagraphs(block, scribe);
  	        } // If the block is left empty then we need to reset the placeholder content.


  	        if (scribe.allowsBlockElements() && scribe.getTextContent() === '') {
  	          scribe.setContent('<p><br></p>');
  	        }
  	      } else if (["Left", "ArrowLeft", "Up", "ArrowUp"].indexOf(ev.key) > -1) {
  	        if (ev.shiftKey && isSelectedFromStart(scribe)) {
  	          ev.preventDefault();
  	          ev.stopPropagation();
  	          document.activeElement && document.activeElement.blur();
  	          block.mediator.trigger("selection:block", block);
  	        } else if (isAtStart(scribe)) {
  	          ev.preventDefault();
  	          ev.stopPropagation();
  	          block.mediator.trigger("block:focusPrevious", block.blockID);
  	        }
  	      } else if (ev.keyCode === 8 && isAtStart(scribe)) {
  	        ev.preventDefault();
  	        isAtStartBoolean = true;
  	      } else if (["Right", "ArrowRight", "Down", "ArrowDown"].indexOf(ev.key) > -1) {
  	        if (ev.shiftKey && isSelectedToEnd(scribe)) {
  	          ev.preventDefault();
  	          ev.stopPropagation();
  	          document.activeElement && document.activeElement.blur();
  	          block.mediator.trigger("selection:block", block);
  	        } else if (isAtEnd(scribe)) {
  	          ev.preventDefault();
  	          block.mediator.trigger("block:focusNext", block.blockID);
  	        }
  	      }
  	    });
  	    scribe.el.addEventListener('keyup', function (ev) {
  	      if (block.supressKeyListeners) {
  	        return;
  	      }

  	      if (ev.key === "Backspace" && isAtStartBoolean) {
  	        ev.preventDefault();
  	        block.mediator.trigger('block:remove', block.blockID, {
  	          transposeContent: true
  	        });
  	        isAtStartBoolean = false;
  	      }
  	    });
  	  };
  	};

  	module.exports = ScribeTextBlockPlugin;

  	/***/ }),
  	/* 91 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Format Bar
  	 * --
  	 * Displayed on focus on a text area.
  	 * Renders with all available options for the editor instance
  	 */

  	var _ = __webpack_require__(0);

  	var config = __webpack_require__(2);

  	var Dom = __webpack_require__(3);

  	var Events = __webpack_require__(10);

  	var FORMAT_BUTTON_TEMPLATE = __webpack_require__(236);

  	var FormatBar = function FormatBar(options, mediator, editor) {
  	  this.editor = editor;
  	  this.options = Object.assign({}, config.defaults.formatBar, options || {});
  	  this.commands = this.options.commands;
  	  this.mediator = mediator;
  	  this.isShown = false;

  	  this._ensureElement();

  	  this._bindFunctions();

  	  this._bindMediatedEvents();

  	  this.initialize.apply(this, arguments);
  	};

  	Object.assign(FormatBar.prototype, __webpack_require__(6), __webpack_require__(30), __webpack_require__(9), __webpack_require__(11), {
  	  className: 'st-format-bar',
  	  bound: ["onFormatButtonClick", "renderBySelection", "hide"],
  	  eventNamespace: 'formatter',
  	  mediatedEvents: {
  	    'position': 'renderBySelection',
  	    'show': 'show',
  	    'hide': 'hide'
  	  },
  	  initialize: function initialize() {
  	    var buttons = this.commands.reduce(function (memo, format) {
  	      return memo += FORMAT_BUTTON_TEMPLATE(format);
  	    }, "");
  	    this.el.insertAdjacentHTML("beforeend", buttons); // We use mousedown rather than click as that allows us to keep focus on the contenteditable field.

  	    Events.delegate(this.el, '.st-format-btn', 'mousedown', this.onFormatButtonClick);
  	  },
  	  hide: function hide() {
  	    this.block = undefined;
  	    this.isShown = false;
  	    this.el.classList.remove('st-format-bar--is-ready');
  	    Dom.remove(this.el);
  	  },
  	  show: function show() {
  	    if (this.isShown) {
  	      return;
  	    }

  	    this.isShown = true;
  	    this.editor.outer.appendChild(this.el);
  	    this.el.classList.add('st-format-bar--is-ready');
  	  },
  	  remove: function remove() {
  	    Dom.remove(this.el);
  	  },
  	  renderBySelection: function renderBySelection(block) {
  	    this.block = block;
  	    this.highlightSelectedButtons();
  	    this.show();
  	    this.calculatePosition();
  	  },
  	  calculatePosition: function calculatePosition() {
  	    var selection = window.getSelection(),
  	        range = selection.getRangeAt(0),
  	        boundary = range.getBoundingClientRect(),
  	        coords = {},
  	        outer = this.editor.outer,
  	        outerBoundary = outer.getBoundingClientRect();
  	    coords.top = boundary.top - outerBoundary.top + 'px';
  	    coords.left = (boundary.left + boundary.right) / 2 - this.el.offsetWidth / 2 - outerBoundary.left + 'px';
  	    this.el.style.top = coords.top;
  	    this.el.style.left = coords.left;
  	  },
  	  highlightSelectedButtons: function highlightSelectedButtons() {
  	    var _this = this;

  	    [].forEach.call(this.el.querySelectorAll(".st-format-btn"), function (btn) {
  	      var cmd = btn.getAttribute('data-cmd');
  	      btn.classList.toggle("st-format-btn--is-active", _this.block.queryTextBlockCommandState(cmd));
  	      btn = null;
  	    });
  	  },
  	  onFormatButtonClick: function onFormatButtonClick(ev) {
  	    ev.preventDefault();
  	    ev.stopPropagation();

  	    if (_.isUndefined(this.block)) {
  	      throw "Associated block not found";
  	    }

  	    var btn = ev.currentTarget,
  	        cmd = btn.getAttribute('data-cmd');

  	    if (_.isUndefined(cmd)) {
  	      return false;
  	    }

  	    this.block.execTextBlockCommand(cmd);
  	    this.highlightSelectedButtons(); // Re-select the contenteditable field.

  	    document.activeElement.focus();
  	    return false;
  	  }
  	});
  	module.exports = FormatBar;

  	/***/ }),
  	/* 92 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var config = __webpack_require__(2);

  	var utils = __webpack_require__(1);

  	var EventBus = __webpack_require__(4);

  	var Submittable = __webpack_require__(62);

  	var formBound = false; // Flag to tell us once we've bound our submit event

  	var FormEvents = {
  	  bindFormSubmit: function bindFormSubmit(form) {
  	    if (!formBound) {
  	      // XXX: should we have a formBound and submittable per-editor?
  	      // telling JSHint to ignore as it'll complain we shouldn't be creating
  	      // a new object, but otherwise `this` won't be set in the Submittable
  	      // initialiser. Bit weird.
  	      new Submittable(form); // jshint ignore:line

  	      form.addEventListener('submit', this.onFormSubmit);
  	      formBound = true;
  	    }
  	  },
  	  onBeforeSubmit: function onBeforeSubmit(shouldValidate) {
  	    // Loop through all of our instances and do our form submits on them
  	    var errors = 0;
  	    config.instances.forEach(function (inst, i) {
  	      errors += inst.onFormSubmit(shouldValidate);
  	    });
  	    utils.log("Total errors: " + errors);
  	    return errors;
  	  },
  	  onFormSubmit: function onFormSubmit(ev) {
  	    var errors = FormEvents.onBeforeSubmit();

  	    if (errors > 0) {
  	      EventBus.trigger("onError");
  	      ev.preventDefault();
  	    }
  	  }
  	};
  	module.exports = FormEvents;

  	/***/ }),
  	/* 93 */
  	/***/ (function(module, exports, __webpack_require__) {

  	module.exports = __webpack_require__(94);

  	__webpack_require__(246);

  	/***/ }),
  	/* 94 */
  	/***/ (function(module, exports, __webpack_require__) {


  	__webpack_require__(95); // ES6 shims


  	__webpack_require__(96).shim();

  	__webpack_require__(101).shim();

  	__webpack_require__(114); // shims ES7 Array.prototype.includes


  	__webpack_require__(115).polyfill(); // Old IE support


  	__webpack_require__(116);

  	__webpack_require__(117);

  	__webpack_require__(118);

  	var utils = __webpack_require__(1);

  	var SirTrevor = {
  	  config: __webpack_require__(2),
  	  log: utils.log,
  	  Locales: __webpack_require__(140),
  	  Events: __webpack_require__(9),
  	  EventBus: __webpack_require__(4),
  	  EditorStore: __webpack_require__(61),
  	  Submittable: __webpack_require__(62),
  	  FileUploader: __webpack_require__(63),
  	  BlockMixins: __webpack_require__(65),
  	  BlockPositioner: __webpack_require__(81),
  	  BlockPositionerSelect: __webpack_require__(82),
  	  BlockReorder: __webpack_require__(39),
  	  BlockDeletion: __webpack_require__(83),
  	  BlockValidations: __webpack_require__(84),
  	  BlockStore: __webpack_require__(85),
  	  BlockManager: __webpack_require__(86),
  	  SimpleBlock: __webpack_require__(87),
  	  Block: __webpack_require__(8),
  	  Blocks: __webpack_require__(21),
  	  FormatBar: __webpack_require__(91),
  	  Editor: __webpack_require__(237),
  	  toMarkdown: __webpack_require__(245),
  	  toHTML: __webpack_require__(22),
  	  setDefaults: function setDefaults(options) {
  	    Object.assign(SirTrevor.config.defaults, options || {});
  	  },
  	  getInstance: utils.getInstance,
  	  setBlockOptions: function setBlockOptions(type, options) {
  	    var block = SirTrevor.Blocks[type];

  	    if (typeof block === "undefined") {
  	      return;
  	    }

  	    Object.assign(block.prototype, options || {});
  	  },
  	  runOnAllInstances: function runOnAllInstances(method) {
  	    if (SirTrevor.Editor.prototype.hasOwnProperty(method)) {
  	      var methodArgs = Array.prototype.slice.call(arguments, 1);
  	      Array.prototype.forEach.call(SirTrevor.config.instances, function (i) {
  	        i[method].apply(null, methodArgs);
  	      });
  	    } else {
  	      SirTrevor.log("method doesn't exist");
  	    }
  	  }
  	};
  	Object.assign(SirTrevor, __webpack_require__(92));
  	module.exports = SirTrevor;

  	/***/ }),
  	/* 95 */
  	/***/ (function(module, exports, __webpack_require__) {

  	module.exports = __webpack_require__.p + "178289a66e4bc63fe9a24fba4c8acf36.svg";

  	/***/ }),
  	/* 96 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var defineProperties = __webpack_require__(23);

  	var implementation = __webpack_require__(43);
  	var getPolyfill = __webpack_require__(45);
  	var shim = __webpack_require__(100);

  	var polyfill = getPolyfill();

  	defineProperties(polyfill, {
  		getPolyfill: getPolyfill,
  		implementation: implementation,
  		shim: shim
  	});

  	module.exports = polyfill;


  	/***/ }),
  	/* 97 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var toStr = Object.prototype.toString;

  	module.exports = function isArguments(value) {
  		var str = toStr.call(value);
  		var isArgs = str === '[object Arguments]';
  		if (!isArgs) {
  			isArgs = str !== '[object Array]' &&
  				value !== null &&
  				typeof value === 'object' &&
  				typeof value.length === 'number' &&
  				value.length >= 0 &&
  				toStr.call(value.callee) === '[object Function]';
  		}
  		return isArgs;
  	};


  	/***/ }),
  	/* 98 */
  	/***/ (function(module, exports) {


  	var hasOwn = Object.prototype.hasOwnProperty;
  	var toString = Object.prototype.toString;

  	module.exports = function forEach (obj, fn, ctx) {
  	    if (toString.call(fn) !== '[object Function]') {
  	        throw new TypeError('iterator must be a function');
  	    }
  	    var l = obj.length;
  	    if (l === +l) {
  	        for (var i = 0; i < l; i++) {
  	            fn.call(ctx, obj[i], i, obj);
  	        }
  	    } else {
  	        for (var k in obj) {
  	            if (hasOwn.call(obj, k)) {
  	                fn.call(ctx, obj[k], k, obj);
  	            }
  	        }
  	    }
  	};



  	/***/ }),
  	/* 99 */
  	/***/ (function(module, exports, __webpack_require__) {


  	/* eslint no-invalid-this: 1 */

  	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
  	var slice = Array.prototype.slice;
  	var toStr = Object.prototype.toString;
  	var funcType = '[object Function]';

  	module.exports = function bind(that) {
  	    var target = this;
  	    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
  	        throw new TypeError(ERROR_MESSAGE + target);
  	    }
  	    var args = slice.call(arguments, 1);

  	    var bound;
  	    var binder = function () {
  	        if (this instanceof bound) {
  	            var result = target.apply(
  	                this,
  	                args.concat(slice.call(arguments))
  	            );
  	            if (Object(result) === result) {
  	                return result;
  	            }
  	            return this;
  	        } else {
  	            return target.apply(
  	                that,
  	                args.concat(slice.call(arguments))
  	            );
  	        }
  	    };

  	    var boundLength = Math.max(0, target.length - args.length);
  	    var boundArgs = [];
  	    for (var i = 0; i < boundLength; i++) {
  	        boundArgs.push('$' + i);
  	    }

  	    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

  	    if (target.prototype) {
  	        var Empty = function Empty() {};
  	        Empty.prototype = target.prototype;
  	        bound.prototype = new Empty();
  	        Empty.prototype = null;
  	    }

  	    return bound;
  	};


  	/***/ }),
  	/* 100 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var define = __webpack_require__(23);
  	var getPolyfill = __webpack_require__(45);

  	module.exports = function shimAssign() {
  		var polyfill = getPolyfill();
  		define(
  			Object,
  			{ assign: polyfill },
  			{ assign: function () { return Object.assign !== polyfill; } }
  		);
  		return polyfill;
  	};


  	/***/ }),
  	/* 101 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var define = __webpack_require__(23);
  	var ES = __webpack_require__(46);

  	var implementation = __webpack_require__(53);
  	var getPolyfill = __webpack_require__(54);
  	var shim = __webpack_require__(113);

  	var slice = Array.prototype.slice;

  	var polyfill = getPolyfill();

  	var boundFindShim = function find(array, predicate) { // eslint-disable-line no-unused-vars
  		ES.RequireObjectCoercible(array);
  		var args = slice.call(arguments, 1);
  		return polyfill.apply(array, args);
  	};

  	define(boundFindShim, {
  		getPolyfill: getPolyfill,
  		implementation: implementation,
  		shim: shim
  	});

  	module.exports = boundFindShim;


  	/***/ }),
  	/* 102 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var has = __webpack_require__(31);
  	var toPrimitive = __webpack_require__(103);

  	var GetIntrinsic = __webpack_require__(48);

  	var $TypeError = GetIntrinsic('%TypeError%');
  	var $SyntaxError = GetIntrinsic('%SyntaxError%');
  	var $Array = GetIntrinsic('%Array%');
  	var $String = GetIntrinsic('%String%');
  	var $Object = GetIntrinsic('%Object%');
  	var $Number = GetIntrinsic('%Number%');
  	var $Symbol = GetIntrinsic('%Symbol%', true);
  	var $RegExp = GetIntrinsic('%RegExp%');

  	var hasSymbols = !!$Symbol;

  	var $isNaN = __webpack_require__(49);
  	var $isFinite = __webpack_require__(50);
  	var MAX_SAFE_INTEGER = $Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

  	var assign = __webpack_require__(108);
  	var sign = __webpack_require__(51);
  	var mod = __webpack_require__(52);
  	var isPrimitive = __webpack_require__(109);
  	var parseInteger = parseInt;
  	var bind = __webpack_require__(24);
  	var arraySlice = bind.call(Function.call, $Array.prototype.slice);
  	var strSlice = bind.call(Function.call, $String.prototype.slice);
  	var isBinary = bind.call(Function.call, $RegExp.prototype.test, /^0b[01]+$/i);
  	var isOctal = bind.call(Function.call, $RegExp.prototype.test, /^0o[0-7]+$/i);
  	var regexExec = bind.call(Function.call, $RegExp.prototype.exec);
  	var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
  	var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
  	var hasNonWS = bind.call(Function.call, $RegExp.prototype.test, nonWSregex);
  	var invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;
  	var isInvalidHexLiteral = bind.call(Function.call, $RegExp.prototype.test, invalidHexLiteral);
  	var $charCodeAt = bind.call(Function.call, $String.prototype.charCodeAt);

  	var toStr = bind.call(Function.call, Object.prototype.toString);

  	var $floor = Math.floor;
  	var $abs = Math.abs;

  	var $ObjectCreate = Object.create;
  	var $gOPD = $Object.getOwnPropertyDescriptor;

  	var $isExtensible = $Object.isExtensible;

  	// whitespace from: http://es5.github.io/#x15.5.4.20
  	// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
  	var ws = [
  		'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
  		'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
  		'\u2029\uFEFF'
  	].join('');
  	var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
  	var replace = bind.call(Function.call, $String.prototype.replace);
  	var trim = function (value) {
  		return replace(value, trimRegex, '');
  	};

  	var ES5 = __webpack_require__(110);

  	var hasRegExpMatcher = __webpack_require__(112);

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
  	var ES6 = assign(assign({}, ES5), {

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
  		Call: function Call(F, V) {
  			var args = arguments.length > 2 ? arguments[2] : [];
  			if (!this.IsCallable(F)) {
  				throw new $TypeError(F + ' is not a function');
  			}
  			return F.apply(V, args);
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
  		ToPrimitive: toPrimitive,

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
  		// ToBoolean: ES5.ToBoolean,

  		// https://ecma-international.org/ecma-262/6.0/#sec-tonumber
  		ToNumber: function ToNumber(argument) {
  			var value = isPrimitive(argument) ? argument : toPrimitive(argument, $Number);
  			if (typeof value === 'symbol') {
  				throw new $TypeError('Cannot convert a Symbol value to a number');
  			}
  			if (typeof value === 'string') {
  				if (isBinary(value)) {
  					return this.ToNumber(parseInteger(strSlice(value, 2), 2));
  				} else if (isOctal(value)) {
  					return this.ToNumber(parseInteger(strSlice(value, 2), 8));
  				} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
  					return NaN;
  				} else {
  					var trimmed = trim(value);
  					if (trimmed !== value) {
  						return this.ToNumber(trimmed);
  					}
  				}
  			}
  			return $Number(value);
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
  		// ToInteger: ES5.ToNumber,

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
  		// ToInt32: ES5.ToInt32,

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
  		// ToUint32: ES5.ToUint32,

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
  		ToInt16: function ToInt16(argument) {
  			var int16bit = this.ToUint16(argument);
  			return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
  		// ToUint16: ES5.ToUint16,

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
  		ToInt8: function ToInt8(argument) {
  			var int8bit = this.ToUint8(argument);
  			return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
  		ToUint8: function ToUint8(argument) {
  			var number = this.ToNumber(argument);
  			if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
  			var posInt = sign(number) * $floor($abs(number));
  			return mod(posInt, 0x100);
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
  		ToUint8Clamp: function ToUint8Clamp(argument) {
  			var number = this.ToNumber(argument);
  			if ($isNaN(number) || number <= 0) { return 0; }
  			if (number >= 0xFF) { return 0xFF; }
  			var f = $floor(argument);
  			if (f + 0.5 < number) { return f + 1; }
  			if (number < f + 0.5) { return f; }
  			if (f % 2 !== 0) { return f + 1; }
  			return f;
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
  		ToString: function ToString(argument) {
  			if (typeof argument === 'symbol') {
  				throw new $TypeError('Cannot convert a Symbol value to a string');
  			}
  			return $String(argument);
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
  		ToObject: function ToObject(value) {
  			this.RequireObjectCoercible(value);
  			return $Object(value);
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
  		ToPropertyKey: function ToPropertyKey(argument) {
  			var key = this.ToPrimitive(argument, $String);
  			return typeof key === 'symbol' ? key : this.ToString(key);
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  		ToLength: function ToLength(argument) {
  			var len = this.ToInteger(argument);
  			if (len <= 0) { return 0; } // includes converting -0 to +0
  			if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
  			return len;
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-canonicalnumericindexstring
  		CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
  			if (toStr(argument) !== '[object String]') {
  				throw new $TypeError('must be a string');
  			}
  			if (argument === '-0') { return -0; }
  			var n = this.ToNumber(argument);
  			if (this.SameValue(this.ToString(n), argument)) { return n; }
  			return void 0;
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
  		RequireObjectCoercible: ES5.CheckObjectCoercible,

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
  		IsArray: $Array.isArray || function IsArray(argument) {
  			return toStr(argument) === '[object Array]';
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
  		// IsCallable: ES5.IsCallable,

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
  		IsConstructor: function IsConstructor(argument) {
  			return typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
  		IsExtensible: Object.preventExtensions
  			? function IsExtensible(obj) {
  				if (isPrimitive(obj)) {
  					return false;
  				}
  				return $isExtensible(obj);
  			}
  			: function isExtensible(obj) { return true; }, // eslint-disable-line no-unused-vars

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
  		IsInteger: function IsInteger(argument) {
  			if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
  				return false;
  			}
  			var abs = $abs(argument);
  			return $floor(abs) === abs;
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
  		IsPropertyKey: function IsPropertyKey(argument) {
  			return typeof argument === 'string' || typeof argument === 'symbol';
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-isregexp
  		IsRegExp: function IsRegExp(argument) {
  			if (!argument || typeof argument !== 'object') {
  				return false;
  			}
  			if (hasSymbols) {
  				var isRegExp = argument[$Symbol.match];
  				if (typeof isRegExp !== 'undefined') {
  					return ES5.ToBoolean(isRegExp);
  				}
  			}
  			return hasRegExpMatcher(argument);
  		},

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
  		// SameValue: ES5.SameValue,

  		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
  		SameValueZero: function SameValueZero(x, y) {
  			return (x === y) || ($isNaN(x) && $isNaN(y));
  		},

  		/**
  		 * 7.3.2 GetV (V, P)
  		 * 1. Assert: IsPropertyKey(P) is true.
  		 * 2. Let O be ToObject(V).
  		 * 3. ReturnIfAbrupt(O).
  		 * 4. Return O.[[Get]](P, V).
  		 */
  		GetV: function GetV(V, P) {
  			// 7.3.2.1
  			if (!this.IsPropertyKey(P)) {
  				throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
  			}

  			// 7.3.2.2-3
  			var O = this.ToObject(V);

  			// 7.3.2.4
  			return O[P];
  		},

  		/**
  		 * 7.3.9 - https://ecma-international.org/ecma-262/6.0/#sec-getmethod
  		 * 1. Assert: IsPropertyKey(P) is true.
  		 * 2. Let func be GetV(O, P).
  		 * 3. ReturnIfAbrupt(func).
  		 * 4. If func is either undefined or null, return undefined.
  		 * 5. If IsCallable(func) is false, throw a TypeError exception.
  		 * 6. Return func.
  		 */
  		GetMethod: function GetMethod(O, P) {
  			// 7.3.9.1
  			if (!this.IsPropertyKey(P)) {
  				throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
  			}

  			// 7.3.9.2
  			var func = this.GetV(O, P);

  			// 7.3.9.4
  			if (func == null) {
  				return void 0;
  			}

  			// 7.3.9.5
  			if (!this.IsCallable(func)) {
  				throw new $TypeError(P + 'is not a function');
  			}

  			// 7.3.9.6
  			return func;
  		},

  		/**
  		 * 7.3.1 Get (O, P) - https://ecma-international.org/ecma-262/6.0/#sec-get-o-p
  		 * 1. Assert: Type(O) is Object.
  		 * 2. Assert: IsPropertyKey(P) is true.
  		 * 3. Return O.[[Get]](P, O).
  		 */
  		Get: function Get(O, P) {
  			// 7.3.1.1
  			if (this.Type(O) !== 'Object') {
  				throw new $TypeError('Assertion failed: Type(O) is not Object');
  			}
  			// 7.3.1.2
  			if (!this.IsPropertyKey(P)) {
  				throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
  			}
  			// 7.3.1.3
  			return O[P];
  		},

  		Type: function Type(x) {
  			if (typeof x === 'symbol') {
  				return 'Symbol';
  			}
  			return ES5.Type(x);
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-speciesconstructor
  		SpeciesConstructor: function SpeciesConstructor(O, defaultConstructor) {
  			if (this.Type(O) !== 'Object') {
  				throw new $TypeError('Assertion failed: Type(O) is not Object');
  			}
  			var C = O.constructor;
  			if (typeof C === 'undefined') {
  				return defaultConstructor;
  			}
  			if (this.Type(C) !== 'Object') {
  				throw new $TypeError('O.constructor is not an Object');
  			}
  			var S = hasSymbols && $Symbol.species ? C[$Symbol.species] : void 0;
  			if (S == null) {
  				return defaultConstructor;
  			}
  			if (this.IsConstructor(S)) {
  				return S;
  			}
  			throw new $TypeError('no constructor found');
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-completepropertydescriptor
  		CompletePropertyDescriptor: function CompletePropertyDescriptor(Desc) {
  			if (!this.IsPropertyDescriptor(Desc)) {
  				throw new $TypeError('Desc must be a Property Descriptor');
  			}

  			if (this.IsGenericDescriptor(Desc) || this.IsDataDescriptor(Desc)) {
  				if (!has(Desc, '[[Value]]')) {
  					Desc['[[Value]]'] = void 0;
  				}
  				if (!has(Desc, '[[Writable]]')) {
  					Desc['[[Writable]]'] = false;
  				}
  			} else {
  				if (!has(Desc, '[[Get]]')) {
  					Desc['[[Get]]'] = void 0;
  				}
  				if (!has(Desc, '[[Set]]')) {
  					Desc['[[Set]]'] = void 0;
  				}
  			}
  			if (!has(Desc, '[[Enumerable]]')) {
  				Desc['[[Enumerable]]'] = false;
  			}
  			if (!has(Desc, '[[Configurable]]')) {
  				Desc['[[Configurable]]'] = false;
  			}
  			return Desc;
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-set-o-p-v-throw
  		Set: function Set(O, P, V, Throw) {
  			if (this.Type(O) !== 'Object') {
  				throw new $TypeError('O must be an Object');
  			}
  			if (!this.IsPropertyKey(P)) {
  				throw new $TypeError('P must be a Property Key');
  			}
  			if (this.Type(Throw) !== 'Boolean') {
  				throw new $TypeError('Throw must be a Boolean');
  			}
  			if (Throw) {
  				O[P] = V;
  				return true;
  			} else {
  				try {
  					O[P] = V;
  				} catch (e) {
  					return false;
  				}
  			}
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-hasownproperty
  		HasOwnProperty: function HasOwnProperty(O, P) {
  			if (this.Type(O) !== 'Object') {
  				throw new $TypeError('O must be an Object');
  			}
  			if (!this.IsPropertyKey(P)) {
  				throw new $TypeError('P must be a Property Key');
  			}
  			return has(O, P);
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-hasproperty
  		HasProperty: function HasProperty(O, P) {
  			if (this.Type(O) !== 'Object') {
  				throw new $TypeError('O must be an Object');
  			}
  			if (!this.IsPropertyKey(P)) {
  				throw new $TypeError('P must be a Property Key');
  			}
  			return P in O;
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable
  		IsConcatSpreadable: function IsConcatSpreadable(O) {
  			if (this.Type(O) !== 'Object') {
  				return false;
  			}
  			if (hasSymbols && typeof $Symbol.isConcatSpreadable === 'symbol') {
  				var spreadable = this.Get(O, Symbol.isConcatSpreadable);
  				if (typeof spreadable !== 'undefined') {
  					return this.ToBoolean(spreadable);
  				}
  			}
  			return this.IsArray(O);
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-invoke
  		Invoke: function Invoke(O, P) {
  			if (!this.IsPropertyKey(P)) {
  				throw new $TypeError('P must be a Property Key');
  			}
  			var argumentsList = arraySlice(arguments, 2);
  			var func = this.GetV(O, P);
  			return this.Call(func, O, argumentsList);
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-getiterator
  		GetIterator: function GetIterator(obj, method) {
  			if (!hasSymbols) {
  				throw new SyntaxError('ES.GetIterator depends on native iterator support.');
  			}

  			var actualMethod = method;
  			if (arguments.length < 2) {
  				actualMethod = this.GetMethod(obj, $Symbol.iterator);
  			}
  			var iterator = this.Call(actualMethod, obj);
  			if (this.Type(iterator) !== 'Object') {
  				throw new $TypeError('iterator must return an object');
  			}

  			return iterator;
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-iteratornext
  		IteratorNext: function IteratorNext(iterator, value) {
  			var result = this.Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
  			if (this.Type(result) !== 'Object') {
  				throw new $TypeError('iterator next must return an object');
  			}
  			return result;
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-iteratorcomplete
  		IteratorComplete: function IteratorComplete(iterResult) {
  			if (this.Type(iterResult) !== 'Object') {
  				throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
  			}
  			return this.ToBoolean(this.Get(iterResult, 'done'));
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-iteratorvalue
  		IteratorValue: function IteratorValue(iterResult) {
  			if (this.Type(iterResult) !== 'Object') {
  				throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
  			}
  			return this.Get(iterResult, 'value');
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-iteratorstep
  		IteratorStep: function IteratorStep(iterator) {
  			var result = this.IteratorNext(iterator);
  			var done = this.IteratorComplete(result);
  			return done === true ? false : result;
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-iteratorclose
  		IteratorClose: function IteratorClose(iterator, completion) {
  			if (this.Type(iterator) !== 'Object') {
  				throw new $TypeError('Assertion failed: Type(iterator) is not Object');
  			}
  			if (!this.IsCallable(completion)) {
  				throw new $TypeError('Assertion failed: completion is not a thunk for a Completion Record');
  			}
  			var completionThunk = completion;

  			var iteratorReturn = this.GetMethod(iterator, 'return');

  			if (typeof iteratorReturn === 'undefined') {
  				return completionThunk();
  			}

  			var completionRecord;
  			try {
  				var innerResult = this.Call(iteratorReturn, iterator, []);
  			} catch (e) {
  				// if we hit here, then "e" is the innerResult completion that needs re-throwing

  				// if the completion is of type "throw", this will throw.
  				completionRecord = completionThunk();
  				completionThunk = null; // ensure it's not called twice.

  				// if not, then return the innerResult completion
  				throw e;
  			}
  			completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
  			completionThunk = null; // ensure it's not called twice.

  			if (this.Type(innerResult) !== 'Object') {
  				throw new $TypeError('iterator .return must return an object');
  			}

  			return completionRecord;
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-createiterresultobject
  		CreateIterResultObject: function CreateIterResultObject(value, done) {
  			if (this.Type(done) !== 'Boolean') {
  				throw new $TypeError('Assertion failed: Type(done) is not Boolean');
  			}
  			return {
  				value: value,
  				done: done
  			};
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-regexpexec
  		RegExpExec: function RegExpExec(R, S) {
  			if (this.Type(R) !== 'Object') {
  				throw new $TypeError('R must be an Object');
  			}
  			if (this.Type(S) !== 'String') {
  				throw new $TypeError('S must be a String');
  			}
  			var exec = this.Get(R, 'exec');
  			if (this.IsCallable(exec)) {
  				var result = this.Call(exec, R, [S]);
  				if (result === null || this.Type(result) === 'Object') {
  					return result;
  				}
  				throw new $TypeError('"exec" method must return `null` or an Object');
  			}
  			return regexExec(R, S);
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-arrayspeciescreate
  		ArraySpeciesCreate: function ArraySpeciesCreate(originalArray, length) {
  			if (!this.IsInteger(length) || length < 0) {
  				throw new $TypeError('Assertion failed: length must be an integer >= 0');
  			}
  			var len = length === 0 ? 0 : length;
  			var C;
  			var isArray = this.IsArray(originalArray);
  			if (isArray) {
  				C = this.Get(originalArray, 'constructor');
  				// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
  				// if (this.IsConstructor(C)) {
  				// 	if C is another realm's Array, C = undefined
  				// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
  				// }
  				if (this.Type(C) === 'Object' && hasSymbols && $Symbol.species) {
  					C = this.Get(C, $Symbol.species);
  					if (C === null) {
  						C = void 0;
  					}
  				}
  			}
  			if (typeof C === 'undefined') {
  				return $Array(len);
  			}
  			if (!this.IsConstructor(C)) {
  				throw new $TypeError('C must be a constructor');
  			}
  			return new C(len); // this.Construct(C, len);
  		},

  		CreateDataProperty: function CreateDataProperty(O, P, V) {
  			if (this.Type(O) !== 'Object') {
  				throw new $TypeError('Assertion failed: Type(O) is not Object');
  			}
  			if (!this.IsPropertyKey(P)) {
  				throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
  			}
  			var oldDesc = $gOPD(O, P);
  			var extensible = oldDesc || (typeof $isExtensible !== 'function' || $isExtensible(O));
  			var immutable = oldDesc && (!oldDesc.writable || !oldDesc.configurable);
  			if (immutable || !extensible) {
  				return false;
  			}
  			var newDesc = {
  				configurable: true,
  				enumerable: true,
  				value: V,
  				writable: true
  			};
  			Object.defineProperty(O, P, newDesc);
  			return true;
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-createdatapropertyorthrow
  		CreateDataPropertyOrThrow: function CreateDataPropertyOrThrow(O, P, V) {
  			if (this.Type(O) !== 'Object') {
  				throw new $TypeError('Assertion failed: Type(O) is not Object');
  			}
  			if (!this.IsPropertyKey(P)) {
  				throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
  			}
  			var success = this.CreateDataProperty(O, P, V);
  			if (!success) {
  				throw new $TypeError('unable to create data property');
  			}
  			return success;
  		},

  		// https://www.ecma-international.org/ecma-262/6.0/#sec-objectcreate
  		ObjectCreate: function ObjectCreate(proto, internalSlotsList) {
  			if (proto !== null && this.Type(proto) !== 'Object') {
  				throw new $TypeError('Assertion failed: proto must be null or an object');
  			}
  			var slots = arguments.length < 2 ? [] : internalSlotsList;
  			if (slots.length > 0) {
  				throw new $SyntaxError('es-abstract does not yet support internal slots');
  			}

  			if (proto === null && !$ObjectCreate) {
  				throw new $SyntaxError('native Object.create support is required to create null objects');
  			}

  			return $ObjectCreate(proto);
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-advancestringindex
  		AdvanceStringIndex: function AdvanceStringIndex(S, index, unicode) {
  			if (this.Type(S) !== 'String') {
  				throw new $TypeError('S must be a String');
  			}
  			if (!this.IsInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
  				throw new $TypeError('Assertion failed: length must be an integer >= 0 and <= 2**53');
  			}
  			if (this.Type(unicode) !== 'Boolean') {
  				throw new $TypeError('Assertion failed: unicode must be a Boolean');
  			}
  			if (!unicode) {
  				return index + 1;
  			}
  			var length = S.length;
  			if ((index + 1) >= length) {
  				return index + 1;
  			}

  			var first = $charCodeAt(S, index);
  			if (first < 0xD800 || first > 0xDBFF) {
  				return index + 1;
  			}

  			var second = $charCodeAt(S, index + 1);
  			if (second < 0xDC00 || second > 0xDFFF) {
  				return index + 1;
  			}

  			return index + 2;
  		}
  	});

  	delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible

  	module.exports = ES6;


  	/***/ }),
  	/* 103 */
  	/***/ (function(module, exports, __webpack_require__) {


  	module.exports = __webpack_require__(104);


  	/***/ }),
  	/* 104 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

  	var isPrimitive = __webpack_require__(47);
  	var isCallable = __webpack_require__(32);
  	var isDate = __webpack_require__(105);
  	var isSymbol = __webpack_require__(106);

  	var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
  		if (typeof O === 'undefined' || O === null) {
  			throw new TypeError('Cannot call method on ' + O);
  		}
  		if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
  			throw new TypeError('hint must be "string" or "number"');
  		}
  		var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
  		var method, result, i;
  		for (i = 0; i < methodNames.length; ++i) {
  			method = O[methodNames[i]];
  			if (isCallable(method)) {
  				result = method.call(O);
  				if (isPrimitive(result)) {
  					return result;
  				}
  			}
  		}
  		throw new TypeError('No default value');
  	};

  	var GetMethod = function GetMethod(O, P) {
  		var func = O[P];
  		if (func !== null && typeof func !== 'undefined') {
  			if (!isCallable(func)) {
  				throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
  			}
  			return func;
  		}
  		return void 0;
  	};

  	// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
  	module.exports = function ToPrimitive(input) {
  		if (isPrimitive(input)) {
  			return input;
  		}
  		var hint = 'default';
  		if (arguments.length > 1) {
  			if (arguments[1] === String) {
  				hint = 'string';
  			} else if (arguments[1] === Number) {
  				hint = 'number';
  			}
  		}

  		var exoticToPrim;
  		if (hasSymbols) {
  			if (Symbol.toPrimitive) {
  				exoticToPrim = GetMethod(input, Symbol.toPrimitive);
  			} else if (isSymbol(input)) {
  				exoticToPrim = Symbol.prototype.valueOf;
  			}
  		}
  		if (typeof exoticToPrim !== 'undefined') {
  			var result = exoticToPrim.call(input, hint);
  			if (isPrimitive(result)) {
  				return result;
  			}
  			throw new TypeError('unable to convert exotic object to primitive');
  		}
  		if (hint === 'default' && (isDate(input) || isSymbol(input))) {
  			hint = 'string';
  		}
  		return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
  	};


  	/***/ }),
  	/* 105 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var getDay = Date.prototype.getDay;
  	var tryDateObject = function tryDateObject(value) {
  		try {
  			getDay.call(value);
  			return true;
  		} catch (e) {
  			return false;
  		}
  	};

  	var toStr = Object.prototype.toString;
  	var dateClass = '[object Date]';
  	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

  	module.exports = function isDateObject(value) {
  		if (typeof value !== 'object' || value === null) { return false; }
  		return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
  	};


  	/***/ }),
  	/* 106 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var toStr = Object.prototype.toString;
  	var hasSymbols = __webpack_require__(107)();

  	if (hasSymbols) {
  		var symToStr = Symbol.prototype.toString;
  		var symStringRegex = /^Symbol\(.*\)$/;
  		var isSymbolObject = function isRealSymbolObject(value) {
  			if (typeof value.valueOf() !== 'symbol') {
  				return false;
  			}
  			return symStringRegex.test(symToStr.call(value));
  		};

  		module.exports = function isSymbol(value) {
  			if (typeof value === 'symbol') {
  				return true;
  			}
  			if (toStr.call(value) !== '[object Symbol]') {
  				return false;
  			}
  			try {
  				return isSymbolObject(value);
  			} catch (e) {
  				return false;
  			}
  		};
  	} else {

  		module.exports = function isSymbol(value) {
  			// this environment does not support Symbols.
  			return  false;
  		};
  	}


  	/***/ }),
  	/* 107 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/* WEBPACK VAR INJECTION */(function(global) {

  	var origSymbol = global.Symbol;
  	var hasSymbolSham = __webpack_require__(44);

  	module.exports = function hasNativeSymbols() {
  		if (typeof origSymbol !== 'function') { return false; }
  		if (typeof Symbol !== 'function') { return false; }
  		if (typeof origSymbol('foo') !== 'symbol') { return false; }
  		if (typeof Symbol('bar') !== 'symbol') { return false; }

  		return hasSymbolSham();
  	};

  	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17)));

  	/***/ }),
  	/* 108 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var bind = __webpack_require__(24);
  	var has = bind.call(Function.call, Object.prototype.hasOwnProperty);

  	var $assign = Object.assign;

  	module.exports = function assign(target, source) {
  		if ($assign) {
  			return $assign(target, source);
  		}

  		for (var key in source) {
  			if (has(source, key)) {
  				target[key] = source[key];
  			}
  		}
  		return target;
  	};


  	/***/ }),
  	/* 109 */
  	/***/ (function(module, exports) {

  	module.exports = function isPrimitive(value) {
  		return value === null || (typeof value !== 'function' && typeof value !== 'object');
  	};


  	/***/ }),
  	/* 110 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var GetIntrinsic = __webpack_require__(48);

  	var $Object = GetIntrinsic('%Object%');
  	var $TypeError = GetIntrinsic('%TypeError%');
  	var $String = GetIntrinsic('%String%');

  	var $isNaN = __webpack_require__(49);
  	var $isFinite = __webpack_require__(50);

  	var sign = __webpack_require__(51);
  	var mod = __webpack_require__(52);

  	var IsCallable = __webpack_require__(32);
  	var toPrimitive = __webpack_require__(111);

  	var has = __webpack_require__(31);

  	// https://es5.github.io/#x9
  	var ES5 = {
  		ToPrimitive: toPrimitive,

  		ToBoolean: function ToBoolean(value) {
  			return !!value;
  		},
  		ToNumber: function ToNumber(value) {
  			return +value; // eslint-disable-line no-implicit-coercion
  		},
  		ToInteger: function ToInteger(value) {
  			var number = this.ToNumber(value);
  			if ($isNaN(number)) { return 0; }
  			if (number === 0 || !$isFinite(number)) { return number; }
  			return sign(number) * Math.floor(Math.abs(number));
  		},
  		ToInt32: function ToInt32(x) {
  			return this.ToNumber(x) >> 0;
  		},
  		ToUint32: function ToUint32(x) {
  			return this.ToNumber(x) >>> 0;
  		},
  		ToUint16: function ToUint16(value) {
  			var number = this.ToNumber(value);
  			if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
  			var posInt = sign(number) * Math.floor(Math.abs(number));
  			return mod(posInt, 0x10000);
  		},
  		ToString: function ToString(value) {
  			return $String(value);
  		},
  		ToObject: function ToObject(value) {
  			this.CheckObjectCoercible(value);
  			return $Object(value);
  		},
  		CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
  			/* jshint eqnull:true */
  			if (value == null) {
  				throw new $TypeError(optMessage || 'Cannot call method on ' + value);
  			}
  			return value;
  		},
  		IsCallable: IsCallable,
  		SameValue: function SameValue(x, y) {
  			if (x === y) { // 0 === -0, but they are not identical.
  				if (x === 0) { return 1 / x === 1 / y; }
  				return true;
  			}
  			return $isNaN(x) && $isNaN(y);
  		},

  		// https://www.ecma-international.org/ecma-262/5.1/#sec-8
  		Type: function Type(x) {
  			if (x === null) {
  				return 'Null';
  			}
  			if (typeof x === 'undefined') {
  				return 'Undefined';
  			}
  			if (typeof x === 'function' || typeof x === 'object') {
  				return 'Object';
  			}
  			if (typeof x === 'number') {
  				return 'Number';
  			}
  			if (typeof x === 'boolean') {
  				return 'Boolean';
  			}
  			if (typeof x === 'string') {
  				return 'String';
  			}
  		},

  		// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
  		IsPropertyDescriptor: function IsPropertyDescriptor(Desc) {
  			if (this.Type(Desc) !== 'Object') {
  				return false;
  			}
  			var allowed = {
  				'[[Configurable]]': true,
  				'[[Enumerable]]': true,
  				'[[Get]]': true,
  				'[[Set]]': true,
  				'[[Value]]': true,
  				'[[Writable]]': true
  			};
  			// jscs:disable
  			for (var key in Desc) { // eslint-disable-line
  				if (has(Desc, key) && !allowed[key]) {
  					return false;
  				}
  			}
  			// jscs:enable
  			var isData = has(Desc, '[[Value]]');
  			var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');
  			if (isData && IsAccessor) {
  				throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
  			}
  			return true;
  		},

  		// https://ecma-international.org/ecma-262/5.1/#sec-8.10.1
  		IsAccessorDescriptor: function IsAccessorDescriptor(Desc) {
  			if (typeof Desc === 'undefined') {
  				return false;
  			}

  			if (!this.IsPropertyDescriptor(Desc)) {
  				throw new $TypeError('Desc must be a Property Descriptor');
  			}

  			if (!has(Desc, '[[Get]]') && !has(Desc, '[[Set]]')) {
  				return false;
  			}

  			return true;
  		},

  		// https://ecma-international.org/ecma-262/5.1/#sec-8.10.2
  		IsDataDescriptor: function IsDataDescriptor(Desc) {
  			if (typeof Desc === 'undefined') {
  				return false;
  			}

  			if (!this.IsPropertyDescriptor(Desc)) {
  				throw new $TypeError('Desc must be a Property Descriptor');
  			}

  			if (!has(Desc, '[[Value]]') && !has(Desc, '[[Writable]]')) {
  				return false;
  			}

  			return true;
  		},

  		// https://ecma-international.org/ecma-262/5.1/#sec-8.10.3
  		IsGenericDescriptor: function IsGenericDescriptor(Desc) {
  			if (typeof Desc === 'undefined') {
  				return false;
  			}

  			if (!this.IsPropertyDescriptor(Desc)) {
  				throw new $TypeError('Desc must be a Property Descriptor');
  			}

  			if (!this.IsAccessorDescriptor(Desc) && !this.IsDataDescriptor(Desc)) {
  				return true;
  			}

  			return false;
  		},

  		// https://ecma-international.org/ecma-262/5.1/#sec-8.10.4
  		FromPropertyDescriptor: function FromPropertyDescriptor(Desc) {
  			if (typeof Desc === 'undefined') {
  				return Desc;
  			}

  			if (!this.IsPropertyDescriptor(Desc)) {
  				throw new $TypeError('Desc must be a Property Descriptor');
  			}

  			if (this.IsDataDescriptor(Desc)) {
  				return {
  					value: Desc['[[Value]]'],
  					writable: !!Desc['[[Writable]]'],
  					enumerable: !!Desc['[[Enumerable]]'],
  					configurable: !!Desc['[[Configurable]]']
  				};
  			} else if (this.IsAccessorDescriptor(Desc)) {
  				return {
  					get: Desc['[[Get]]'],
  					set: Desc['[[Set]]'],
  					enumerable: !!Desc['[[Enumerable]]'],
  					configurable: !!Desc['[[Configurable]]']
  				};
  			} else {
  				throw new $TypeError('FromPropertyDescriptor must be called with a fully populated Property Descriptor');
  			}
  		},

  		// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5
  		ToPropertyDescriptor: function ToPropertyDescriptor(Obj) {
  			if (this.Type(Obj) !== 'Object') {
  				throw new $TypeError('ToPropertyDescriptor requires an object');
  			}

  			var desc = {};
  			if (has(Obj, 'enumerable')) {
  				desc['[[Enumerable]]'] = this.ToBoolean(Obj.enumerable);
  			}
  			if (has(Obj, 'configurable')) {
  				desc['[[Configurable]]'] = this.ToBoolean(Obj.configurable);
  			}
  			if (has(Obj, 'value')) {
  				desc['[[Value]]'] = Obj.value;
  			}
  			if (has(Obj, 'writable')) {
  				desc['[[Writable]]'] = this.ToBoolean(Obj.writable);
  			}
  			if (has(Obj, 'get')) {
  				var getter = Obj.get;
  				if (typeof getter !== 'undefined' && !this.IsCallable(getter)) {
  					throw new TypeError('getter must be a function');
  				}
  				desc['[[Get]]'] = getter;
  			}
  			if (has(Obj, 'set')) {
  				var setter = Obj.set;
  				if (typeof setter !== 'undefined' && !this.IsCallable(setter)) {
  					throw new $TypeError('setter must be a function');
  				}
  				desc['[[Set]]'] = setter;
  			}

  			if ((has(desc, '[[Get]]') || has(desc, '[[Set]]')) && (has(desc, '[[Value]]') || has(desc, '[[Writable]]'))) {
  				throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
  			}
  			return desc;
  		}
  	};

  	module.exports = ES5;


  	/***/ }),
  	/* 111 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var toStr = Object.prototype.toString;

  	var isPrimitive = __webpack_require__(47);

  	var isCallable = __webpack_require__(32);

  	// http://ecma-international.org/ecma-262/5.1/#sec-8.12.8
  	var ES5internalSlots = {
  		'[[DefaultValue]]': function (O) {
  			var actualHint;
  			if (arguments.length > 1) {
  				actualHint = arguments[1];
  			} else {
  				actualHint = toStr.call(O) === '[object Date]' ? String : Number;
  			}

  			if (actualHint === String || actualHint === Number) {
  				var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
  				var value, i;
  				for (i = 0; i < methods.length; ++i) {
  					if (isCallable(O[methods[i]])) {
  						value = O[methods[i]]();
  						if (isPrimitive(value)) {
  							return value;
  						}
  					}
  				}
  				throw new TypeError('No default value');
  			}
  			throw new TypeError('invalid [[DefaultValue]] hint supplied');
  		}
  	};

  	// http://ecma-international.org/ecma-262/5.1/#sec-9.1
  	module.exports = function ToPrimitive(input) {
  		if (isPrimitive(input)) {
  			return input;
  		}
  		if (arguments.length > 1) {
  			return ES5internalSlots['[[DefaultValue]]'](input, arguments[1]);
  		}
  		return ES5internalSlots['[[DefaultValue]]'](input);
  	};


  	/***/ }),
  	/* 112 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var has = __webpack_require__(31);
  	var regexExec = RegExp.prototype.exec;
  	var gOPD = Object.getOwnPropertyDescriptor;

  	var tryRegexExecCall = function tryRegexExec(value) {
  		try {
  			var lastIndex = value.lastIndex;
  			value.lastIndex = 0;

  			regexExec.call(value);
  			return true;
  		} catch (e) {
  			return false;
  		} finally {
  			value.lastIndex = lastIndex;
  		}
  	};
  	var toStr = Object.prototype.toString;
  	var regexClass = '[object RegExp]';
  	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

  	module.exports = function isRegex(value) {
  		if (!value || typeof value !== 'object') {
  			return false;
  		}
  		if (!hasToStringTag) {
  			return toStr.call(value) === regexClass;
  		}

  		var descriptor = gOPD(value, 'lastIndex');
  		var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
  		if (!hasLastIndexDataProperty) {
  			return false;
  		}

  		return tryRegexExecCall(value);
  	};


  	/***/ }),
  	/* 113 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var define = __webpack_require__(23);
  	var getPolyfill = __webpack_require__(54);

  	module.exports = function shimArrayPrototypeFind() {
  		var polyfill = getPolyfill();

  		define(Array.prototype, { find: polyfill }, {
  			find: function () {
  				return Array.prototype.find !== polyfill;
  			}
  		});

  		return polyfill;
  	};


  	/***/ }),
  	/* 114 */
  	/***/ (function(module, exports, __webpack_require__) {
  	 // jshint freeze: false, maxcomplexity: 11

  	if (!Array.prototype.includes) {
  	  Array.prototype.includes = function (searchElement
  	  /*, fromIndex*/
  	  ) {
  	    var O = Object(this);
  	    var len = parseInt(O.length) || 0;

  	    if (len === 0) {
  	      return false;
  	    }

  	    var n = parseInt(arguments[1]) || 0;
  	    var k;

  	    if (n >= 0) {
  	      k = n;
  	    } else {
  	      k = len + n;

  	      if (k < 0) {
  	        k = 0;
  	      }
  	    }

  	    var currentElement;

  	    while (k < len) {
  	      currentElement = O[k];

  	      if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
  	        return true;
  	      }

  	      k++;
  	    }

  	    return false;
  	  };
  	}

  	/***/ }),
  	/* 115 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/* WEBPACK VAR INJECTION */(function(process, global) {/*!
  	 * @overview es6-promise - a tiny implementation of Promises/A+.
  	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
  	 * @license   Licensed under MIT license
  	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
  	 * @version   v4.2.5+7f2b526d
  	 */

  	(function (global, factory) {
  		 module.exports = factory() ;
  	}(this, (function () {
  	function objectOrFunction(x) {
  	  var type = typeof x;
  	  return x !== null && (type === 'object' || type === 'function');
  	}

  	function isFunction(x) {
  	  return typeof x === 'function';
  	}



  	var _isArray = void 0;
  	if (Array.isArray) {
  	  _isArray = Array.isArray;
  	} else {
  	  _isArray = function (x) {
  	    return Object.prototype.toString.call(x) === '[object Array]';
  	  };
  	}

  	var isArray = _isArray;

  	var len = 0;
  	var vertxNext = void 0;
  	var customSchedulerFn = void 0;

  	var asap = function asap(callback, arg) {
  	  queue[len] = callback;
  	  queue[len + 1] = arg;
  	  len += 2;
  	  if (len === 2) {
  	    // If len is 2, that means that we need to schedule an async flush.
  	    // If additional callbacks are queued before the queue is flushed, they
  	    // will be processed by this flush that we are scheduling.
  	    if (customSchedulerFn) {
  	      customSchedulerFn(flush);
  	    } else {
  	      scheduleFlush();
  	    }
  	  }
  	};

  	function setScheduler(scheduleFn) {
  	  customSchedulerFn = scheduleFn;
  	}

  	function setAsap(asapFn) {
  	  asap = asapFn;
  	}

  	var browserWindow = typeof window !== 'undefined' ? window : undefined;
  	var browserGlobal = browserWindow || {};
  	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

  	// test for web worker but not in IE10
  	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

  	// node
  	function useNextTick() {
  	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  	  // see https://github.com/cujojs/when/issues/410 for details
  	  return function () {
  	    return process.nextTick(flush);
  	  };
  	}

  	// vertx
  	function useVertxTimer() {
  	  if (typeof vertxNext !== 'undefined') {
  	    return function () {
  	      vertxNext(flush);
  	    };
  	  }

  	  return useSetTimeout();
  	}

  	function useMutationObserver() {
  	  var iterations = 0;
  	  var observer = new BrowserMutationObserver(flush);
  	  var node = document.createTextNode('');
  	  observer.observe(node, { characterData: true });

  	  return function () {
  	    node.data = iterations = ++iterations % 2;
  	  };
  	}

  	// web worker
  	function useMessageChannel() {
  	  var channel = new MessageChannel();
  	  channel.port1.onmessage = flush;
  	  return function () {
  	    return channel.port2.postMessage(0);
  	  };
  	}

  	function useSetTimeout() {
  	  // Store setTimeout reference so es6-promise will be unaffected by
  	  // other code modifying setTimeout (like sinon.useFakeTimers())
  	  var globalSetTimeout = setTimeout;
  	  return function () {
  	    return globalSetTimeout(flush, 1);
  	  };
  	}

  	var queue = new Array(1000);
  	function flush() {
  	  for (var i = 0; i < len; i += 2) {
  	    var callback = queue[i];
  	    var arg = queue[i + 1];

  	    callback(arg);

  	    queue[i] = undefined;
  	    queue[i + 1] = undefined;
  	  }

  	  len = 0;
  	}

  	function attemptVertx() {
  	  try {
  	    var vertx = Function('return this')().require('vertx');
  	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
  	    return useVertxTimer();
  	  } catch (e) {
  	    return useSetTimeout();
  	  }
  	}

  	var scheduleFlush = void 0;
  	// Decide what async method to use to triggering processing of queued callbacks:
  	if (isNode) {
  	  scheduleFlush = useNextTick();
  	} else if (BrowserMutationObserver) {
  	  scheduleFlush = useMutationObserver();
  	} else if (isWorker) {
  	  scheduleFlush = useMessageChannel();
  	} else if (browserWindow === undefined && "function" === 'function') {
  	  scheduleFlush = attemptVertx();
  	} else {
  	  scheduleFlush = useSetTimeout();
  	}

  	function then(onFulfillment, onRejection) {
  	  var parent = this;

  	  var child = new this.constructor(noop);

  	  if (child[PROMISE_ID] === undefined) {
  	    makePromise(child);
  	  }

  	  var _state = parent._state;


  	  if (_state) {
  	    var callback = arguments[_state - 1];
  	    asap(function () {
  	      return invokeCallback(_state, child, callback, parent._result);
  	    });
  	  } else {
  	    subscribe(parent, child, onFulfillment, onRejection);
  	  }

  	  return child;
  	}

  	/**
  	  `Promise.resolve` returns a promise that will become resolved with the
  	  passed `value`. It is shorthand for the following:

  	  ```javascript
  	  let promise = new Promise(function(resolve, reject){
  	    resolve(1);
  	  });

  	  promise.then(function(value){
  	    // value === 1
  	  });
  	  ```

  	  Instead of writing the above, your code now simply becomes the following:

  	  ```javascript
  	  let promise = Promise.resolve(1);

  	  promise.then(function(value){
  	    // value === 1
  	  });
  	  ```

  	  @method resolve
  	  @static
  	  @param {Any} value value that the returned promise will be resolved with
  	  Useful for tooling.
  	  @return {Promise} a promise that will become fulfilled with the given
  	  `value`
  	*/
  	function resolve$1(object) {
  	  /*jshint validthis:true */
  	  var Constructor = this;

  	  if (object && typeof object === 'object' && object.constructor === Constructor) {
  	    return object;
  	  }

  	  var promise = new Constructor(noop);
  	  resolve(promise, object);
  	  return promise;
  	}

  	var PROMISE_ID = Math.random().toString(36).substring(2);

  	function noop() {}

  	var PENDING = void 0;
  	var FULFILLED = 1;
  	var REJECTED = 2;

  	var TRY_CATCH_ERROR = { error: null };

  	function selfFulfillment() {
  	  return new TypeError("You cannot resolve a promise with itself");
  	}

  	function cannotReturnOwn() {
  	  return new TypeError('A promises callback cannot return that same promise.');
  	}

  	function getThen(promise) {
  	  try {
  	    return promise.then;
  	  } catch (error) {
  	    TRY_CATCH_ERROR.error = error;
  	    return TRY_CATCH_ERROR;
  	  }
  	}

  	function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  	  try {
  	    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  	  } catch (e) {
  	    return e;
  	  }
  	}

  	function handleForeignThenable(promise, thenable, then$$1) {
  	  asap(function (promise) {
  	    var sealed = false;
  	    var error = tryThen(then$$1, thenable, function (value) {
  	      if (sealed) {
  	        return;
  	      }
  	      sealed = true;
  	      if (thenable !== value) {
  	        resolve(promise, value);
  	      } else {
  	        fulfill(promise, value);
  	      }
  	    }, function (reason) {
  	      if (sealed) {
  	        return;
  	      }
  	      sealed = true;

  	      reject(promise, reason);
  	    }, 'Settle: ' + (promise._label || ' unknown promise'));

  	    if (!sealed && error) {
  	      sealed = true;
  	      reject(promise, error);
  	    }
  	  }, promise);
  	}

  	function handleOwnThenable(promise, thenable) {
  	  if (thenable._state === FULFILLED) {
  	    fulfill(promise, thenable._result);
  	  } else if (thenable._state === REJECTED) {
  	    reject(promise, thenable._result);
  	  } else {
  	    subscribe(thenable, undefined, function (value) {
  	      return resolve(promise, value);
  	    }, function (reason) {
  	      return reject(promise, reason);
  	    });
  	  }
  	}

  	function handleMaybeThenable(promise, maybeThenable, then$$1) {
  	  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
  	    handleOwnThenable(promise, maybeThenable);
  	  } else {
  	    if (then$$1 === TRY_CATCH_ERROR) {
  	      reject(promise, TRY_CATCH_ERROR.error);
  	      TRY_CATCH_ERROR.error = null;
  	    } else if (then$$1 === undefined) {
  	      fulfill(promise, maybeThenable);
  	    } else if (isFunction(then$$1)) {
  	      handleForeignThenable(promise, maybeThenable, then$$1);
  	    } else {
  	      fulfill(promise, maybeThenable);
  	    }
  	  }
  	}

  	function resolve(promise, value) {
  	  if (promise === value) {
  	    reject(promise, selfFulfillment());
  	  } else if (objectOrFunction(value)) {
  	    handleMaybeThenable(promise, value, getThen(value));
  	  } else {
  	    fulfill(promise, value);
  	  }
  	}

  	function publishRejection(promise) {
  	  if (promise._onerror) {
  	    promise._onerror(promise._result);
  	  }

  	  publish(promise);
  	}

  	function fulfill(promise, value) {
  	  if (promise._state !== PENDING) {
  	    return;
  	  }

  	  promise._result = value;
  	  promise._state = FULFILLED;

  	  if (promise._subscribers.length !== 0) {
  	    asap(publish, promise);
  	  }
  	}

  	function reject(promise, reason) {
  	  if (promise._state !== PENDING) {
  	    return;
  	  }
  	  promise._state = REJECTED;
  	  promise._result = reason;

  	  asap(publishRejection, promise);
  	}

  	function subscribe(parent, child, onFulfillment, onRejection) {
  	  var _subscribers = parent._subscribers;
  	  var length = _subscribers.length;


  	  parent._onerror = null;

  	  _subscribers[length] = child;
  	  _subscribers[length + FULFILLED] = onFulfillment;
  	  _subscribers[length + REJECTED] = onRejection;

  	  if (length === 0 && parent._state) {
  	    asap(publish, parent);
  	  }
  	}

  	function publish(promise) {
  	  var subscribers = promise._subscribers;
  	  var settled = promise._state;

  	  if (subscribers.length === 0) {
  	    return;
  	  }

  	  var child = void 0,
  	      callback = void 0,
  	      detail = promise._result;

  	  for (var i = 0; i < subscribers.length; i += 3) {
  	    child = subscribers[i];
  	    callback = subscribers[i + settled];

  	    if (child) {
  	      invokeCallback(settled, child, callback, detail);
  	    } else {
  	      callback(detail);
  	    }
  	  }

  	  promise._subscribers.length = 0;
  	}

  	function tryCatch(callback, detail) {
  	  try {
  	    return callback(detail);
  	  } catch (e) {
  	    TRY_CATCH_ERROR.error = e;
  	    return TRY_CATCH_ERROR;
  	  }
  	}

  	function invokeCallback(settled, promise, callback, detail) {
  	  var hasCallback = isFunction(callback),
  	      value = void 0,
  	      error = void 0,
  	      succeeded = void 0,
  	      failed = void 0;

  	  if (hasCallback) {
  	    value = tryCatch(callback, detail);

  	    if (value === TRY_CATCH_ERROR) {
  	      failed = true;
  	      error = value.error;
  	      value.error = null;
  	    } else {
  	      succeeded = true;
  	    }

  	    if (promise === value) {
  	      reject(promise, cannotReturnOwn());
  	      return;
  	    }
  	  } else {
  	    value = detail;
  	    succeeded = true;
  	  }

  	  if (promise._state !== PENDING) ; else if (hasCallback && succeeded) {
  	    resolve(promise, value);
  	  } else if (failed) {
  	    reject(promise, error);
  	  } else if (settled === FULFILLED) {
  	    fulfill(promise, value);
  	  } else if (settled === REJECTED) {
  	    reject(promise, value);
  	  }
  	}

  	function initializePromise(promise, resolver) {
  	  try {
  	    resolver(function resolvePromise(value) {
  	      resolve(promise, value);
  	    }, function rejectPromise(reason) {
  	      reject(promise, reason);
  	    });
  	  } catch (e) {
  	    reject(promise, e);
  	  }
  	}

  	var id = 0;
  	function nextId() {
  	  return id++;
  	}

  	function makePromise(promise) {
  	  promise[PROMISE_ID] = id++;
  	  promise._state = undefined;
  	  promise._result = undefined;
  	  promise._subscribers = [];
  	}

  	function validationError() {
  	  return new Error('Array Methods must be provided an Array');
  	}

  	var Enumerator = function () {
  	  function Enumerator(Constructor, input) {
  	    this._instanceConstructor = Constructor;
  	    this.promise = new Constructor(noop);

  	    if (!this.promise[PROMISE_ID]) {
  	      makePromise(this.promise);
  	    }

  	    if (isArray(input)) {
  	      this.length = input.length;
  	      this._remaining = input.length;

  	      this._result = new Array(this.length);

  	      if (this.length === 0) {
  	        fulfill(this.promise, this._result);
  	      } else {
  	        this.length = this.length || 0;
  	        this._enumerate(input);
  	        if (this._remaining === 0) {
  	          fulfill(this.promise, this._result);
  	        }
  	      }
  	    } else {
  	      reject(this.promise, validationError());
  	    }
  	  }

  	  Enumerator.prototype._enumerate = function _enumerate(input) {
  	    for (var i = 0; this._state === PENDING && i < input.length; i++) {
  	      this._eachEntry(input[i], i);
  	    }
  	  };

  	  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
  	    var c = this._instanceConstructor;
  	    var resolve$$1 = c.resolve;


  	    if (resolve$$1 === resolve$1) {
  	      var _then = getThen(entry);

  	      if (_then === then && entry._state !== PENDING) {
  	        this._settledAt(entry._state, i, entry._result);
  	      } else if (typeof _then !== 'function') {
  	        this._remaining--;
  	        this._result[i] = entry;
  	      } else if (c === Promise$1) {
  	        var promise = new c(noop);
  	        handleMaybeThenable(promise, entry, _then);
  	        this._willSettleAt(promise, i);
  	      } else {
  	        this._willSettleAt(new c(function (resolve$$1) {
  	          return resolve$$1(entry);
  	        }), i);
  	      }
  	    } else {
  	      this._willSettleAt(resolve$$1(entry), i);
  	    }
  	  };

  	  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
  	    var promise = this.promise;


  	    if (promise._state === PENDING) {
  	      this._remaining--;

  	      if (state === REJECTED) {
  	        reject(promise, value);
  	      } else {
  	        this._result[i] = value;
  	      }
  	    }

  	    if (this._remaining === 0) {
  	      fulfill(promise, this._result);
  	    }
  	  };

  	  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
  	    var enumerator = this;

  	    subscribe(promise, undefined, function (value) {
  	      return enumerator._settledAt(FULFILLED, i, value);
  	    }, function (reason) {
  	      return enumerator._settledAt(REJECTED, i, reason);
  	    });
  	  };

  	  return Enumerator;
  	}();

  	/**
  	  `Promise.all` accepts an array of promises, and returns a new promise which
  	  is fulfilled with an array of fulfillment values for the passed promises, or
  	  rejected with the reason of the first passed promise to be rejected. It casts all
  	  elements of the passed iterable to promises as it runs this algorithm.

  	  Example:

  	  ```javascript
  	  let promise1 = resolve(1);
  	  let promise2 = resolve(2);
  	  let promise3 = resolve(3);
  	  let promises = [ promise1, promise2, promise3 ];

  	  Promise.all(promises).then(function(array){
  	    // The array here would be [ 1, 2, 3 ];
  	  });
  	  ```

  	  If any of the `promises` given to `all` are rejected, the first promise
  	  that is rejected will be given as an argument to the returned promises's
  	  rejection handler. For example:

  	  Example:

  	  ```javascript
  	  let promise1 = resolve(1);
  	  let promise2 = reject(new Error("2"));
  	  let promise3 = reject(new Error("3"));
  	  let promises = [ promise1, promise2, promise3 ];

  	  Promise.all(promises).then(function(array){
  	    // Code here never runs because there are rejected promises!
  	  }, function(error) {
  	    // error.message === "2"
  	  });
  	  ```

  	  @method all
  	  @static
  	  @param {Array} entries array of promises
  	  @param {String} label optional string for labeling the promise.
  	  Useful for tooling.
  	  @return {Promise} promise that is fulfilled when all `promises` have been
  	  fulfilled, or rejected if any of them become rejected.
  	  @static
  	*/
  	function all(entries) {
  	  return new Enumerator(this, entries).promise;
  	}

  	/**
  	  `Promise.race` returns a new promise which is settled in the same way as the
  	  first passed promise to settle.

  	  Example:

  	  ```javascript
  	  let promise1 = new Promise(function(resolve, reject){
  	    setTimeout(function(){
  	      resolve('promise 1');
  	    }, 200);
  	  });

  	  let promise2 = new Promise(function(resolve, reject){
  	    setTimeout(function(){
  	      resolve('promise 2');
  	    }, 100);
  	  });

  	  Promise.race([promise1, promise2]).then(function(result){
  	    // result === 'promise 2' because it was resolved before promise1
  	    // was resolved.
  	  });
  	  ```

  	  `Promise.race` is deterministic in that only the state of the first
  	  settled promise matters. For example, even if other promises given to the
  	  `promises` array argument are resolved, but the first settled promise has
  	  become rejected before the other promises became fulfilled, the returned
  	  promise will become rejected:

  	  ```javascript
  	  let promise1 = new Promise(function(resolve, reject){
  	    setTimeout(function(){
  	      resolve('promise 1');
  	    }, 200);
  	  });

  	  let promise2 = new Promise(function(resolve, reject){
  	    setTimeout(function(){
  	      reject(new Error('promise 2'));
  	    }, 100);
  	  });

  	  Promise.race([promise1, promise2]).then(function(result){
  	    // Code here never runs
  	  }, function(reason){
  	    // reason.message === 'promise 2' because promise 2 became rejected before
  	    // promise 1 became fulfilled
  	  });
  	  ```

  	  An example real-world use case is implementing timeouts:

  	  ```javascript
  	  Promise.race([ajax('foo.json'), timeout(5000)])
  	  ```

  	  @method race
  	  @static
  	  @param {Array} promises array of promises to observe
  	  Useful for tooling.
  	  @return {Promise} a promise which settles in the same way as the first passed
  	  promise to settle.
  	*/
  	function race(entries) {
  	  /*jshint validthis:true */
  	  var Constructor = this;

  	  if (!isArray(entries)) {
  	    return new Constructor(function (_, reject) {
  	      return reject(new TypeError('You must pass an array to race.'));
  	    });
  	  } else {
  	    return new Constructor(function (resolve, reject) {
  	      var length = entries.length;
  	      for (var i = 0; i < length; i++) {
  	        Constructor.resolve(entries[i]).then(resolve, reject);
  	      }
  	    });
  	  }
  	}

  	/**
  	  `Promise.reject` returns a promise rejected with the passed `reason`.
  	  It is shorthand for the following:

  	  ```javascript
  	  let promise = new Promise(function(resolve, reject){
  	    reject(new Error('WHOOPS'));
  	  });

  	  promise.then(function(value){
  	    // Code here doesn't run because the promise is rejected!
  	  }, function(reason){
  	    // reason.message === 'WHOOPS'
  	  });
  	  ```

  	  Instead of writing the above, your code now simply becomes the following:

  	  ```javascript
  	  let promise = Promise.reject(new Error('WHOOPS'));

  	  promise.then(function(value){
  	    // Code here doesn't run because the promise is rejected!
  	  }, function(reason){
  	    // reason.message === 'WHOOPS'
  	  });
  	  ```

  	  @method reject
  	  @static
  	  @param {Any} reason value that the returned promise will be rejected with.
  	  Useful for tooling.
  	  @return {Promise} a promise rejected with the given `reason`.
  	*/
  	function reject$1(reason) {
  	  /*jshint validthis:true */
  	  var Constructor = this;
  	  var promise = new Constructor(noop);
  	  reject(promise, reason);
  	  return promise;
  	}

  	function needsResolver() {
  	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
  	}

  	function needsNew() {
  	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
  	}

  	/**
  	  Promise objects represent the eventual result of an asynchronous operation. The
  	  primary way of interacting with a promise is through its `then` method, which
  	  registers callbacks to receive either a promise's eventual value or the reason
  	  why the promise cannot be fulfilled.

  	  Terminology
  	  -----------

  	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  	  - `thenable` is an object or function that defines a `then` method.
  	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  	  - `exception` is a value that is thrown using the throw statement.
  	  - `reason` is a value that indicates why a promise was rejected.
  	  - `settled` the final resting state of a promise, fulfilled or rejected.

  	  A promise can be in one of three states: pending, fulfilled, or rejected.

  	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  	  state.  Promises that are rejected have a rejection reason and are in the
  	  rejected state.  A fulfillment value is never a thenable.

  	  Promises can also be said to *resolve* a value.  If this value is also a
  	  promise, then the original promise's settled state will match the value's
  	  settled state.  So a promise that *resolves* a promise that rejects will
  	  itself reject, and a promise that *resolves* a promise that fulfills will
  	  itself fulfill.


  	  Basic Usage:
  	  ------------

  	  ```js
  	  let promise = new Promise(function(resolve, reject) {
  	    // on success
  	    resolve(value);

  	    // on failure
  	    reject(reason);
  	  });

  	  promise.then(function(value) {
  	    // on fulfillment
  	  }, function(reason) {
  	    // on rejection
  	  });
  	  ```

  	  Advanced Usage:
  	  ---------------

  	  Promises shine when abstracting away asynchronous interactions such as
  	  `XMLHttpRequest`s.

  	  ```js
  	  function getJSON(url) {
  	    return new Promise(function(resolve, reject){
  	      let xhr = new XMLHttpRequest();

  	      xhr.open('GET', url);
  	      xhr.onreadystatechange = handler;
  	      xhr.responseType = 'json';
  	      xhr.setRequestHeader('Accept', 'application/json');
  	      xhr.send();

  	      function handler() {
  	        if (this.readyState === this.DONE) {
  	          if (this.status === 200) {
  	            resolve(this.response);
  	          } else {
  	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
  	          }
  	        }
  	      };
  	    });
  	  }

  	  getJSON('/posts.json').then(function(json) {
  	    // on fulfillment
  	  }, function(reason) {
  	    // on rejection
  	  });
  	  ```

  	  Unlike callbacks, promises are great composable primitives.

  	  ```js
  	  Promise.all([
  	    getJSON('/posts'),
  	    getJSON('/comments')
  	  ]).then(function(values){
  	    values[0] // => postsJSON
  	    values[1] // => commentsJSON

  	    return values;
  	  });
  	  ```

  	  @class Promise
  	  @param {Function} resolver
  	  Useful for tooling.
  	  @constructor
  	*/

  	var Promise$1 = function () {
  	  function Promise(resolver) {
  	    this[PROMISE_ID] = nextId();
  	    this._result = this._state = undefined;
  	    this._subscribers = [];

  	    if (noop !== resolver) {
  	      typeof resolver !== 'function' && needsResolver();
  	      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
  	    }
  	  }

  	  /**
  	  The primary way of interacting with a promise is through its `then` method,
  	  which registers callbacks to receive either a promise's eventual value or the
  	  reason why the promise cannot be fulfilled.
  	   ```js
  	  findUser().then(function(user){
  	    // user is available
  	  }, function(reason){
  	    // user is unavailable, and you are given the reason why
  	  });
  	  ```
  	   Chaining
  	  --------
  	   The return value of `then` is itself a promise.  This second, 'downstream'
  	  promise is resolved with the return value of the first promise's fulfillment
  	  or rejection handler, or rejected if the handler throws an exception.
  	   ```js
  	  findUser().then(function (user) {
  	    return user.name;
  	  }, function (reason) {
  	    return 'default name';
  	  }).then(function (userName) {
  	    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
  	    // will be `'default name'`
  	  });
  	   findUser().then(function (user) {
  	    throw new Error('Found user, but still unhappy');
  	  }, function (reason) {
  	    throw new Error('`findUser` rejected and we're unhappy');
  	  }).then(function (value) {
  	    // never reached
  	  }, function (reason) {
  	    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
  	    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  	  });
  	  ```
  	  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  	   ```js
  	  findUser().then(function (user) {
  	    throw new PedagogicalException('Upstream error');
  	  }).then(function (value) {
  	    // never reached
  	  }).then(function (value) {
  	    // never reached
  	  }, function (reason) {
  	    // The `PedgagocialException` is propagated all the way down to here
  	  });
  	  ```
  	   Assimilation
  	  ------------
  	   Sometimes the value you want to propagate to a downstream promise can only be
  	  retrieved asynchronously. This can be achieved by returning a promise in the
  	  fulfillment or rejection handler. The downstream promise will then be pending
  	  until the returned promise is settled. This is called *assimilation*.
  	   ```js
  	  findUser().then(function (user) {
  	    return findCommentsByAuthor(user);
  	  }).then(function (comments) {
  	    // The user's comments are now available
  	  });
  	  ```
  	   If the assimliated promise rejects, then the downstream promise will also reject.
  	   ```js
  	  findUser().then(function (user) {
  	    return findCommentsByAuthor(user);
  	  }).then(function (comments) {
  	    // If `findCommentsByAuthor` fulfills, we'll have the value here
  	  }, function (reason) {
  	    // If `findCommentsByAuthor` rejects, we'll have the reason here
  	  });
  	  ```
  	   Simple Example
  	  --------------
  	   Synchronous Example
  	   ```javascript
  	  let result;
  	   try {
  	    result = findResult();
  	    // success
  	  } catch(reason) {
  	    // failure
  	  }
  	  ```
  	   Errback Example
  	   ```js
  	  findResult(function(result, err){
  	    if (err) {
  	      // failure
  	    } else {
  	      // success
  	    }
  	  });
  	  ```
  	   Promise Example;
  	   ```javascript
  	  findResult().then(function(result){
  	    // success
  	  }, function(reason){
  	    // failure
  	  });
  	  ```
  	   Advanced Example
  	  --------------
  	   Synchronous Example
  	   ```javascript
  	  let author, books;
  	   try {
  	    author = findAuthor();
  	    books  = findBooksByAuthor(author);
  	    // success
  	  } catch(reason) {
  	    // failure
  	  }
  	  ```
  	   Errback Example
  	   ```js
  	   function foundBooks(books) {
  	   }
  	   function failure(reason) {
  	   }
  	   findAuthor(function(author, err){
  	    if (err) {
  	      failure(err);
  	      // failure
  	    } else {
  	      try {
  	        findBoooksByAuthor(author, function(books, err) {
  	          if (err) {
  	            failure(err);
  	          } else {
  	            try {
  	              foundBooks(books);
  	            } catch(reason) {
  	              failure(reason);
  	            }
  	          }
  	        });
  	      } catch(error) {
  	        failure(err);
  	      }
  	      // success
  	    }
  	  });
  	  ```
  	   Promise Example;
  	   ```javascript
  	  findAuthor().
  	    then(findBooksByAuthor).
  	    then(function(books){
  	      // found books
  	  }).catch(function(reason){
  	    // something went wrong
  	  });
  	  ```
  	   @method then
  	  @param {Function} onFulfilled
  	  @param {Function} onRejected
  	  Useful for tooling.
  	  @return {Promise}
  	  */

  	  /**
  	  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  	  as the catch block of a try/catch statement.
  	  ```js
  	  function findAuthor(){
  	  throw new Error('couldn't find that author');
  	  }
  	  // synchronous
  	  try {
  	  findAuthor();
  	  } catch(reason) {
  	  // something went wrong
  	  }
  	  // async with promises
  	  findAuthor().catch(function(reason){
  	  // something went wrong
  	  });
  	  ```
  	  @method catch
  	  @param {Function} onRejection
  	  Useful for tooling.
  	  @return {Promise}
  	  */


  	  Promise.prototype.catch = function _catch(onRejection) {
  	    return this.then(null, onRejection);
  	  };

  	  /**
  	    `finally` will be invoked regardless of the promise's fate just as native
  	    try/catch/finally behaves
  	  
  	    Synchronous example:
  	  
  	    ```js
  	    findAuthor() {
  	      if (Math.random() > 0.5) {
  	        throw new Error();
  	      }
  	      return new Author();
  	    }
  	  
  	    try {
  	      return findAuthor(); // succeed or fail
  	    } catch(error) {
  	      return findOtherAuther();
  	    } finally {
  	      // always runs
  	      // doesn't affect the return value
  	    }
  	    ```
  	  
  	    Asynchronous example:
  	  
  	    ```js
  	    findAuthor().catch(function(reason){
  	      return findOtherAuther();
  	    }).finally(function(){
  	      // author was either found, or not
  	    });
  	    ```
  	  
  	    @method finally
  	    @param {Function} callback
  	    @return {Promise}
  	  */


  	  Promise.prototype.finally = function _finally(callback) {
  	    var promise = this;
  	    var constructor = promise.constructor;

  	    if (isFunction(callback)) {
  	      return promise.then(function (value) {
  	        return constructor.resolve(callback()).then(function () {
  	          return value;
  	        });
  	      }, function (reason) {
  	        return constructor.resolve(callback()).then(function () {
  	          throw reason;
  	        });
  	      });
  	    }

  	    return promise.then(callback, callback);
  	  };

  	  return Promise;
  	}();

  	Promise$1.prototype.then = then;
  	Promise$1.all = all;
  	Promise$1.race = race;
  	Promise$1.resolve = resolve$1;
  	Promise$1.reject = reject$1;
  	Promise$1._setScheduler = setScheduler;
  	Promise$1._setAsap = setAsap;
  	Promise$1._asap = asap;

  	/*global self*/
  	function polyfill() {
  	  var local = void 0;

  	  if (typeof global !== 'undefined') {
  	    local = global;
  	  } else if (typeof self !== 'undefined') {
  	    local = self;
  	  } else {
  	    try {
  	      local = Function('return this')();
  	    } catch (e) {
  	      throw new Error('polyfill failed because global object is unavailable in this environment');
  	    }
  	  }

  	  var P = local.Promise;

  	  if (P) {
  	    var promiseToString = null;
  	    try {
  	      promiseToString = Object.prototype.toString.call(P.resolve());
  	    } catch (e) {
  	      // silently ignored
  	    }

  	    if (promiseToString === '[object Promise]' && !P.cast) {
  	      return;
  	    }
  	  }

  	  local.Promise = Promise$1;
  	}

  	// Strange compat..
  	Promise$1.polyfill = polyfill;
  	Promise$1.Promise = Promise$1;

  	return Promise$1;

  	})));



  	

  	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(55), __webpack_require__(17)));

  	/***/ }),
  	/* 116 */
  	/***/ (function(module, exports) {

  	(function () {

  	  if (typeof window.CustomEvent === "function") return false;

  	  function CustomEvent(event, params) {
  	    params = params || {
  	      bubbles: false,
  	      cancelable: false,
  	      detail: undefined
  	    };
  	    var evt = document.createEvent('CustomEvent');
  	    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
  	    return evt;
  	  }

  	  CustomEvent.prototype = window.Event.prototype;
  	  window.CustomEvent = CustomEvent;
  	})();

  	/***/ }),
  	/* 117 */
  	/***/ (function(module, exports) {

  	(function () {

  	  var testElement = document.createElement("_");
  	  testElement.classList.add("c1", "c2"); // Polyfill for IE 10/11 and Firefox <26, where classList.add and
  	  // classList.remove exist but support only one argument at a time.

  	  if (!testElement.classList.contains("c2")) {
  	    var createMethod = function createMethod(method) {
  	      var original = DOMTokenList.prototype[method];

  	      DOMTokenList.prototype[method] = function (token) {
  	        var i,
  	            len = arguments.length;

  	        for (i = 0; i < len; i++) {
  	          token = arguments[i];
  	          original.call(this, token);
  	        }
  	      };
  	    };

  	    createMethod('add');
  	    createMethod('remove');
  	  }

  	  testElement.classList.toggle("c3", false); // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
  	  // support the second argument.

  	  if (testElement.classList.contains("c3")) {
  	    var _toggle = DOMTokenList.prototype.toggle;

  	    DOMTokenList.prototype.toggle = function (token, force) {
  	      if (1 in arguments && !this.contains(token) === !force) {
  	        return force;
  	      } else {
  	        return _toggle.call(this, token);
  	      }
  	    };
  	  }

  	  testElement = null;
  	})();

  	/***/ }),
  	/* 118 */
  	/***/ (function(module, exports) {

  	(function () {

  	  if (/Trident/.test(navigator.userAgent)) {
  	    Object.defineProperty(HTMLElement.prototype, 'contains', {
  	      writable: true,
  	      enumerable: false,
  	      configurable: true,
  	      value: function value(node) {
  	        if (!node) return false;
  	        return this === node || !!(this.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY);
  	      }
  	    });
  	  } // IE does not implement `Document.prototype.contains`


  	  if (typeof Document.prototype.contains !== 'function') {
  	    Object.defineProperty(Document.prototype, 'contains', {
  	      writable: true,
  	      enumerable: false,
  	      configurable: true,
  	      value: function value(el) {
  	        if (!el) return false;
  	        return this.documentElement.contains(el);
  	      }
  	    });
  	  } // IE does not implement `Range.prototype.intersectsNode`


  	  if (typeof Range.prototype.intersectsNode !== 'function') {
  	    Object.defineProperty(Range.prototype, 'intersectsNode', {
  	      writable: true,
  	      enumerable: false,
  	      configurable: true,
  	      value: function value(node) {
  	        if (!node) {
  	          throw new TypeError("Failed to execute 'intersectsNode' on 'Range': 1 argument required, but only 0 present.");
  	        }

  	        if (this.startContainer.ownerDocument !== node.ownerDocument) return false;
  	        if (!node.parentNode) return true;
  	        var targetRange = document.createRange();
  	        targetRange.selectNode(node);
  	        var startEnd = this.compareBoundaryPoints(Range.START_TO_END, targetRange);
  	        var endStart = this.compareBoundaryPoints(Range.END_TO_START, targetRange);
  	        return startEnd === 1 && endStart === -1;
  	      }
  	    });
  	  }
  	})();

  	/***/ }),
  	/* 119 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var forOwn = __webpack_require__(120),
  	    isFunction = __webpack_require__(28);

  	/** `Object#toString` result shortcuts */
  	var argsClass = '[object Arguments]',
  	    arrayClass = '[object Array]',
  	    objectClass = '[object Object]',
  	    stringClass = '[object String]';

  	/** Used for native method references */
  	var objectProto = Object.prototype;

  	/** Used to resolve the internal [[Class]] of values */
  	var toString = objectProto.toString;

  	/**
  	 * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
  	 * length of `0` and objects with no own enumerable properties are considered
  	 * "empty".
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Objects
  	 * @param {Array|Object|string} value The value to inspect.
  	 * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
  	 * @example
  	 *
  	 * _.isEmpty([1, 2, 3]);
  	 * // => false
  	 *
  	 * _.isEmpty({});
  	 * // => true
  	 *
  	 * _.isEmpty('');
  	 * // => true
  	 */
  	function isEmpty(value) {
  	  var result = true;
  	  if (!value) {
  	    return result;
  	  }
  	  var className = toString.call(value),
  	      length = value.length;

  	  if ((className == arrayClass || className == stringClass || className == argsClass ) ||
  	      (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
  	    return !length;
  	  }
  	  forOwn(value, function() {
  	    return (result = false);
  	  });
  	  return result;
  	}

  	module.exports = isEmpty;


  	/***/ }),
  	/* 120 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var baseCreateCallback = __webpack_require__(121),
  	    keys = __webpack_require__(12),
  	    objectTypes = __webpack_require__(26);

  	/**
  	 * Iterates over own enumerable properties of an object, executing the callback
  	 * for each property. The callback is bound to `thisArg` and invoked with three
  	 * arguments; (value, key, object). Callbacks may exit iteration early by
  	 * explicitly returning `false`.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @type Function
  	 * @category Objects
  	 * @param {Object} object The object to iterate over.
  	 * @param {Function} [callback=identity] The function called per iteration.
  	 * @param {*} [thisArg] The `this` binding of `callback`.
  	 * @returns {Object} Returns `object`.
  	 * @example
  	 *
  	 * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
  	 *   console.log(key);
  	 * });
  	 * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
  	 */
  	var forOwn = function(collection, callback, thisArg) {
  	  var index, iterable = collection, result = iterable;
  	  if (!iterable) return result;
  	  if (!objectTypes[typeof iterable]) return result;
  	  callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
  	    var ownIndex = -1,
  	        ownProps = objectTypes[typeof iterable] && keys(iterable),
  	        length = ownProps ? ownProps.length : 0;

  	    while (++ownIndex < length) {
  	      index = ownProps[ownIndex];
  	      if (callback(iterable[index], index, collection) === false) return result;
  	    }
  	  return result
  	};

  	module.exports = forOwn;


  	/***/ }),
  	/* 121 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var bind = __webpack_require__(122),
  	    identity = __webpack_require__(126),
  	    setBindData = __webpack_require__(33),
  	    support = __webpack_require__(127);

  	/** Used to detected named functions */
  	var reFuncName = /^\s*function[ \n\r\t]+\w/;

  	/** Used to detect functions containing a `this` reference */
  	var reThis = /\bthis\b/;

  	/** Native method shortcuts */
  	var fnToString = Function.prototype.toString;

  	/**
  	 * The base implementation of `_.createCallback` without support for creating
  	 * "_.pluck" or "_.where" style callbacks.
  	 *
  	 * @private
  	 * @param {*} [func=identity] The value to convert to a callback.
  	 * @param {*} [thisArg] The `this` binding of the created callback.
  	 * @param {number} [argCount] The number of arguments the callback accepts.
  	 * @returns {Function} Returns a callback function.
  	 */
  	function baseCreateCallback(func, thisArg, argCount) {
  	  if (typeof func != 'function') {
  	    return identity;
  	  }
  	  // exit early for no `thisArg` or already bound by `Function#bind`
  	  if (typeof thisArg == 'undefined' || !('prototype' in func)) {
  	    return func;
  	  }
  	  var bindData = func.__bindData__;
  	  if (typeof bindData == 'undefined') {
  	    if (support.funcNames) {
  	      bindData = !func.name;
  	    }
  	    bindData = bindData || !support.funcDecomp;
  	    if (!bindData) {
  	      var source = fnToString.call(func);
  	      if (!support.funcNames) {
  	        bindData = !reFuncName.test(source);
  	      }
  	      if (!bindData) {
  	        // checks if `func` references the `this` keyword and stores the result
  	        bindData = reThis.test(source);
  	        setBindData(func, bindData);
  	      }
  	    }
  	  }
  	  // exit early if there are no `this` references or `func` is bound
  	  if (bindData === false || (bindData !== true && bindData[1] & 1)) {
  	    return func;
  	  }
  	  switch (argCount) {
  	    case 1: return function(value) {
  	      return func.call(thisArg, value);
  	    };
  	    case 2: return function(a, b) {
  	      return func.call(thisArg, a, b);
  	    };
  	    case 3: return function(value, index, collection) {
  	      return func.call(thisArg, value, index, collection);
  	    };
  	    case 4: return function(accumulator, value, index, collection) {
  	      return func.call(thisArg, accumulator, value, index, collection);
  	    };
  	  }
  	  return bind(func, thisArg);
  	}

  	module.exports = baseCreateCallback;


  	/***/ }),
  	/* 122 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var createWrapper = __webpack_require__(123),
  	    slice = __webpack_require__(27);

  	/**
  	 * Creates a function that, when called, invokes `func` with the `this`
  	 * binding of `thisArg` and prepends any additional `bind` arguments to those
  	 * provided to the bound function.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Functions
  	 * @param {Function} func The function to bind.
  	 * @param {*} [thisArg] The `this` binding of `func`.
  	 * @param {...*} [arg] Arguments to be partially applied.
  	 * @returns {Function} Returns the new bound function.
  	 * @example
  	 *
  	 * var func = function(greeting) {
  	 *   return greeting + ' ' + this.name;
  	 * };
  	 *
  	 * func = _.bind(func, { 'name': 'fred' }, 'hi');
  	 * func();
  	 * // => 'hi fred'
  	 */
  	function bind(func, thisArg) {
  	  return arguments.length > 2
  	    ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
  	    : createWrapper(func, 1, null, null, thisArg);
  	}

  	module.exports = bind;


  	/***/ }),
  	/* 123 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var baseBind = __webpack_require__(124),
  	    baseCreateWrapper = __webpack_require__(125),
  	    isFunction = __webpack_require__(28),
  	    slice = __webpack_require__(27);

  	/**
  	 * Used for `Array` method references.
  	 *
  	 * Normally `Array.prototype` would suffice, however, using an array literal
  	 * avoids issues in Narwhal.
  	 */
  	var arrayRef = [];

  	/** Native method shortcuts */
  	var push = arrayRef.push,
  	    unshift = arrayRef.unshift;

  	/**
  	 * Creates a function that, when called, either curries or invokes `func`
  	 * with an optional `this` binding and partially applied arguments.
  	 *
  	 * @private
  	 * @param {Function|string} func The function or method name to reference.
  	 * @param {number} bitmask The bitmask of method flags to compose.
  	 *  The bitmask may be composed of the following flags:
  	 *  1 - `_.bind`
  	 *  2 - `_.bindKey`
  	 *  4 - `_.curry`
  	 *  8 - `_.curry` (bound)
  	 *  16 - `_.partial`
  	 *  32 - `_.partialRight`
  	 * @param {Array} [partialArgs] An array of arguments to prepend to those
  	 *  provided to the new function.
  	 * @param {Array} [partialRightArgs] An array of arguments to append to those
  	 *  provided to the new function.
  	 * @param {*} [thisArg] The `this` binding of `func`.
  	 * @param {number} [arity] The arity of `func`.
  	 * @returns {Function} Returns the new function.
  	 */
  	function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
  	  var isBind = bitmask & 1,
  	      isBindKey = bitmask & 2,
  	      isCurry = bitmask & 4,
  	      isPartial = bitmask & 16,
  	      isPartialRight = bitmask & 32;

  	  if (!isBindKey && !isFunction(func)) {
  	    throw new TypeError;
  	  }
  	  if (isPartial && !partialArgs.length) {
  	    bitmask &= ~16;
  	    isPartial = partialArgs = false;
  	  }
  	  if (isPartialRight && !partialRightArgs.length) {
  	    bitmask &= ~32;
  	    isPartialRight = partialRightArgs = false;
  	  }
  	  var bindData = func && func.__bindData__;
  	  if (bindData && bindData !== true) {
  	    // clone `bindData`
  	    bindData = slice(bindData);
  	    if (bindData[2]) {
  	      bindData[2] = slice(bindData[2]);
  	    }
  	    if (bindData[3]) {
  	      bindData[3] = slice(bindData[3]);
  	    }
  	    // set `thisBinding` is not previously bound
  	    if (isBind && !(bindData[1] & 1)) {
  	      bindData[4] = thisArg;
  	    }
  	    // set if previously bound but not currently (subsequent curried functions)
  	    if (!isBind && bindData[1] & 1) {
  	      bitmask |= 8;
  	    }
  	    // set curried arity if not yet set
  	    if (isCurry && !(bindData[1] & 4)) {
  	      bindData[5] = arity;
  	    }
  	    // append partial left arguments
  	    if (isPartial) {
  	      push.apply(bindData[2] || (bindData[2] = []), partialArgs);
  	    }
  	    // append partial right arguments
  	    if (isPartialRight) {
  	      unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
  	    }
  	    // merge flags
  	    bindData[1] |= bitmask;
  	    return createWrapper.apply(null, bindData);
  	  }
  	  // fast path for `_.bind`
  	  var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
  	  return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
  	}

  	module.exports = createWrapper;


  	/***/ }),
  	/* 124 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var baseCreate = __webpack_require__(56),
  	    isObject = __webpack_require__(18),
  	    setBindData = __webpack_require__(33),
  	    slice = __webpack_require__(27);

  	/**
  	 * Used for `Array` method references.
  	 *
  	 * Normally `Array.prototype` would suffice, however, using an array literal
  	 * avoids issues in Narwhal.
  	 */
  	var arrayRef = [];

  	/** Native method shortcuts */
  	var push = arrayRef.push;

  	/**
  	 * The base implementation of `_.bind` that creates the bound function and
  	 * sets its meta data.
  	 *
  	 * @private
  	 * @param {Array} bindData The bind data array.
  	 * @returns {Function} Returns the new bound function.
  	 */
  	function baseBind(bindData) {
  	  var func = bindData[0],
  	      partialArgs = bindData[2],
  	      thisArg = bindData[4];

  	  function bound() {
  	    // `Function#bind` spec
  	    // http://es5.github.io/#x15.3.4.5
  	    if (partialArgs) {
  	      // avoid `arguments` object deoptimizations by using `slice` instead
  	      // of `Array.prototype.slice.call` and not assigning `arguments` to a
  	      // variable as a ternary expression
  	      var args = slice(partialArgs);
  	      push.apply(args, arguments);
  	    }
  	    // mimic the constructor's `return` behavior
  	    // http://es5.github.io/#x13.2.2
  	    if (this instanceof bound) {
  	      // ensure `new bound` is an instance of `func`
  	      var thisBinding = baseCreate(func.prototype),
  	          result = func.apply(thisBinding, args || arguments);
  	      return isObject(result) ? result : thisBinding;
  	    }
  	    return func.apply(thisArg, args || arguments);
  	  }
  	  setBindData(bound, bindData);
  	  return bound;
  	}

  	module.exports = baseBind;


  	/***/ }),
  	/* 125 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var baseCreate = __webpack_require__(56),
  	    isObject = __webpack_require__(18),
  	    setBindData = __webpack_require__(33),
  	    slice = __webpack_require__(27);

  	/**
  	 * Used for `Array` method references.
  	 *
  	 * Normally `Array.prototype` would suffice, however, using an array literal
  	 * avoids issues in Narwhal.
  	 */
  	var arrayRef = [];

  	/** Native method shortcuts */
  	var push = arrayRef.push;

  	/**
  	 * The base implementation of `createWrapper` that creates the wrapper and
  	 * sets its meta data.
  	 *
  	 * @private
  	 * @param {Array} bindData The bind data array.
  	 * @returns {Function} Returns the new function.
  	 */
  	function baseCreateWrapper(bindData) {
  	  var func = bindData[0],
  	      bitmask = bindData[1],
  	      partialArgs = bindData[2],
  	      partialRightArgs = bindData[3],
  	      thisArg = bindData[4],
  	      arity = bindData[5];

  	  var isBind = bitmask & 1,
  	      isBindKey = bitmask & 2,
  	      isCurry = bitmask & 4,
  	      isCurryBound = bitmask & 8,
  	      key = func;

  	  function bound() {
  	    var thisBinding = isBind ? thisArg : this;
  	    if (partialArgs) {
  	      var args = slice(partialArgs);
  	      push.apply(args, arguments);
  	    }
  	    if (partialRightArgs || isCurry) {
  	      args || (args = slice(arguments));
  	      if (partialRightArgs) {
  	        push.apply(args, partialRightArgs);
  	      }
  	      if (isCurry && args.length < arity) {
  	        bitmask |= 16 & ~32;
  	        return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
  	      }
  	    }
  	    args || (args = arguments);
  	    if (isBindKey) {
  	      func = thisBinding[key];
  	    }
  	    if (this instanceof bound) {
  	      thisBinding = baseCreate(func.prototype);
  	      var result = func.apply(thisBinding, args);
  	      return isObject(result) ? result : thisBinding;
  	    }
  	    return func.apply(thisBinding, args);
  	  }
  	  setBindData(bound, bindData);
  	  return bound;
  	}

  	module.exports = baseCreateWrapper;


  	/***/ }),
  	/* 126 */
  	/***/ (function(module, exports) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */

  	/**
  	 * This method returns the first argument provided to it.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Utilities
  	 * @param {*} value Any value.
  	 * @returns {*} Returns `value`.
  	 * @example
  	 *
  	 * var object = { 'name': 'fred' };
  	 * _.identity(object) === object;
  	 * // => true
  	 */
  	function identity(value) {
  	  return value;
  	}

  	module.exports = identity;


  	/***/ }),
  	/* 127 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/* WEBPACK VAR INJECTION */(function(global) {/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var isNative = __webpack_require__(25);

  	/** Used to detect functions containing a `this` reference */
  	var reThis = /\bthis\b/;

  	/**
  	 * An object used to flag environments features.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @type Object
  	 */
  	var support = {};

  	/**
  	 * Detect if functions can be decompiled by `Function#toString`
  	 * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
  	 *
  	 * @memberOf _.support
  	 * @type boolean
  	 */
  	support.funcDecomp = !isNative(global.WinRTError) && reThis.test(function() { return this; });

  	/**
  	 * Detect if `Function#name` is supported (all but IE).
  	 *
  	 * @memberOf _.support
  	 * @type boolean
  	 */
  	support.funcNames = typeof Function.name == 'string';

  	module.exports = support;

  	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17)));

  	/***/ }),
  	/* 128 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var objectTypes = __webpack_require__(26);

  	/** Used for native method references */
  	var objectProto = Object.prototype;

  	/** Native method shortcuts */
  	var hasOwnProperty = objectProto.hasOwnProperty;

  	/**
  	 * A fallback implementation of `Object.keys` which produces an array of the
  	 * given object's own enumerable property names.
  	 *
  	 * @private
  	 * @type Function
  	 * @param {Object} object The object to inspect.
  	 * @returns {Array} Returns an array of property names.
  	 */
  	var shimKeys = function(object) {
  	  var index, iterable = object, result = [];
  	  if (!iterable) return result;
  	  if (!(objectTypes[typeof object])) return result;
  	    for (index in iterable) {
  	      if (hasOwnProperty.call(iterable, index)) {
  	        result.push(index);
  	      }
  	    }
  	  return result
  	};

  	module.exports = shimKeys;


  	/***/ }),
  	/* 129 */
  	/***/ (function(module, exports) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */

  	/** `Object#toString` result shortcuts */
  	var stringClass = '[object String]';

  	/** Used for native method references */
  	var objectProto = Object.prototype;

  	/** Used to resolve the internal [[Class]] of values */
  	var toString = objectProto.toString;

  	/**
  	 * Checks if `value` is a string.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Objects
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
  	 * @example
  	 *
  	 * _.isString('fred');
  	 * // => true
  	 */
  	function isString(value) {
  	  return typeof value == 'string' ||
  	    value && typeof value == 'object' && toString.call(value) == stringClass || false;
  	}

  	module.exports = isString;


  	/***/ }),
  	/* 130 */
  	/***/ (function(module, exports) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */

  	/**
  	 * Checks if `value` is `undefined`.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Objects
  	 * @param {*} value The value to check.
  	 * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
  	 * @example
  	 *
  	 * _.isUndefined(void 0);
  	 * // => true
  	 */
  	function isUndefined(value) {
  	  return typeof value == 'undefined';
  	}

  	module.exports = isUndefined;


  	/***/ }),
  	/* 131 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var isFunction = __webpack_require__(28);

  	/**
  	 * Resolves the value of property `key` on `object`. If `key` is a function
  	 * it will be invoked with the `this` binding of `object` and its result returned,
  	 * else the property value is returned. If `object` is falsey then `undefined`
  	 * is returned.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Utilities
  	 * @param {Object} object The object to inspect.
  	 * @param {string} key The name of the property to resolve.
  	 * @returns {*} Returns the resolved value.
  	 * @example
  	 *
  	 * var object = {
  	 *   'cheese': 'crumpets',
  	 *   'stuff': function() {
  	 *     return 'nonsense';
  	 *   }
  	 * };
  	 *
  	 * _.result(object, 'cheese');
  	 * // => 'crumpets'
  	 *
  	 * _.result(object, 'stuff');
  	 * // => 'nonsense'
  	 */
  	function result(object, key) {
  	  if (object) {
  	    var value = object[key];
  	    return isFunction(value) ? object[key]() : value;
  	  }
  	}

  	module.exports = result;


  	/***/ }),
  	/* 132 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var defaults = __webpack_require__(133);
  	    __webpack_require__(58);
  	    var escapeStringChar = __webpack_require__(136),
  	    keys = __webpack_require__(12),
  	    reInterpolate = __webpack_require__(60),
  	    templateSettings = __webpack_require__(137),
  	    values = __webpack_require__(138);

  	/** Used to match empty string literals in compiled template source */
  	var reEmptyStringLeading = /\b__p \+= '';/g,
  	    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
  	    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  	/**
  	 * Used to match ES6 template delimiters
  	 * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
  	 */
  	var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  	/** Used to ensure capturing order of template delimiters */
  	var reNoMatch = /($^)/;

  	/** Used to match unescaped characters in compiled string literals */
  	var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  	/**
  	 * A micro-templating method that handles arbitrary delimiters, preserves
  	 * whitespace, and correctly escapes quotes within interpolated code.
  	 *
  	 * Note: In the development build, `_.template` utilizes sourceURLs for easier
  	 * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
  	 *
  	 * For more information on precompiling templates see:
  	 * http://lodash.com/custom-builds
  	 *
  	 * For more information on Chrome extension sandboxes see:
  	 * http://developer.chrome.com/stable/extensions/sandboxingEval.html
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Utilities
  	 * @param {string} text The template text.
  	 * @param {Object} data The data object used to populate the text.
  	 * @param {Object} [options] The options object.
  	 * @param {RegExp} [options.escape] The "escape" delimiter.
  	 * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
  	 * @param {Object} [options.imports] An object to import into the template as local variables.
  	 * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
  	 * @param {string} [sourceURL] The sourceURL of the template's compiled source.
  	 * @param {string} [variable] The data object variable name.
  	 * @returns {Function|string} Returns a compiled function when no `data` object
  	 *  is given, else it returns the interpolated text.
  	 * @example
  	 *
  	 * // using the "interpolate" delimiter to create a compiled template
  	 * var compiled = _.template('hello <%= name %>');
  	 * compiled({ 'name': 'fred' });
  	 * // => 'hello fred'
  	 *
  	 * // using the "escape" delimiter to escape HTML in data property values
  	 * _.template('<b><%- value %></b>', { 'value': '<script>' });
  	 * // => '<b>&lt;script&gt;</b>'
  	 *
  	 * // using the "evaluate" delimiter to generate HTML
  	 * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
  	 * _.template(list, { 'people': ['fred', 'barney'] });
  	 * // => '<li>fred</li><li>barney</li>'
  	 *
  	 * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
  	 * _.template('hello ${ name }', { 'name': 'pebbles' });
  	 * // => 'hello pebbles'
  	 *
  	 * // using the internal `print` function in "evaluate" delimiters
  	 * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
  	 * // => 'hello barney!'
  	 *
  	 * // using a custom template delimiters
  	 * _.templateSettings = {
  	 *   'interpolate': /{{([\s\S]+?)}}/g
  	 * };
  	 *
  	 * _.template('hello {{ name }}!', { 'name': 'mustache' });
  	 * // => 'hello mustache!'
  	 *
  	 * // using the `imports` option to import jQuery
  	 * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
  	 * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
  	 * // => '<li>fred</li><li>barney</li>'
  	 *
  	 * // using the `sourceURL` option to specify a custom sourceURL for the template
  	 * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
  	 * compiled(data);
  	 * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
  	 *
  	 * // using the `variable` option to ensure a with-statement isn't used in the compiled template
  	 * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
  	 * compiled.source;
  	 * // => function(data) {
  	 *   var __t, __p = '', __e = _.escape;
  	 *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
  	 *   return __p;
  	 * }
  	 *
  	 * // using the `source` property to inline compiled templates for meaningful
  	 * // line numbers in error messages and a stack trace
  	 * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
  	 *   var JST = {\
  	 *     "main": ' + _.template(mainText).source + '\
  	 *   };\
  	 * ');
  	 */
  	function template(text, data, options) {
  	  // based on John Resig's `tmpl` implementation
  	  // http://ejohn.org/blog/javascript-micro-templating/
  	  // and Laura Doktorova's doT.js
  	  // https://github.com/olado/doT
  	  var settings = templateSettings.imports._.templateSettings || templateSettings;
  	  text = String(text || '');

  	  // avoid missing dependencies when `iteratorTemplate` is not defined
  	  options = defaults({}, options, settings);

  	  var imports = defaults({}, options.imports, settings.imports),
  	      importsKeys = keys(imports),
  	      importsValues = values(imports);

  	  var isEvaluating,
  	      index = 0,
  	      interpolate = options.interpolate || reNoMatch,
  	      source = "__p += '";

  	  // compile the regexp to match each delimiter
  	  var reDelimiters = RegExp(
  	    (options.escape || reNoMatch).source + '|' +
  	    interpolate.source + '|' +
  	    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
  	    (options.evaluate || reNoMatch).source + '|$'
  	  , 'g');

  	  text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
  	    interpolateValue || (interpolateValue = esTemplateValue);

  	    // escape characters that cannot be included in string literals
  	    source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

  	    // replace delimiters with snippets
  	    if (escapeValue) {
  	      source += "' +\n__e(" + escapeValue + ") +\n'";
  	    }
  	    if (evaluateValue) {
  	      isEvaluating = true;
  	      source += "';\n" + evaluateValue + ";\n__p += '";
  	    }
  	    if (interpolateValue) {
  	      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
  	    }
  	    index = offset + match.length;

  	    // the JS engine embedded in Adobe products requires returning the `match`
  	    // string in order to produce the correct `offset` value
  	    return match;
  	  });

  	  source += "';\n";

  	  // if `variable` is not specified, wrap a with-statement around the generated
  	  // code to add the data object to the top of the scope chain
  	  var variable = options.variable,
  	      hasVariable = variable;

  	  if (!hasVariable) {
  	    variable = 'obj';
  	    source = 'with (' + variable + ') {\n' + source + '\n}\n';
  	  }
  	  // cleanup code by stripping empty strings
  	  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
  	    .replace(reEmptyStringMiddle, '$1')
  	    .replace(reEmptyStringTrailing, '$1;');

  	  // frame code as the function body
  	  source = 'function(' + variable + ') {\n' +
  	    (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
  	    "var __t, __p = '', __e = _.escape" +
  	    (isEvaluating
  	      ? ', __j = Array.prototype.join;\n' +
  	        "function print() { __p += __j.call(arguments, '') }\n"
  	      : ';\n'
  	    ) +
  	    source +
  	    'return __p\n}';

  	  try {
  	    var result = Function(importsKeys, 'return ' + source ).apply(undefined, importsValues);
  	  } catch(e) {
  	    e.source = source;
  	    throw e;
  	  }
  	  if (data) {
  	    return result(data);
  	  }
  	  // provide the compiled function's source by its `toString` method, in
  	  // supported environments, or the `source` property as a convenience for
  	  // inlining compiled templates during the build process
  	  result.source = source;
  	  return result;
  	}

  	module.exports = template;


  	/***/ }),
  	/* 133 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var keys = __webpack_require__(12),
  	    objectTypes = __webpack_require__(26);

  	/**
  	 * Assigns own enumerable properties of source object(s) to the destination
  	 * object for all destination properties that resolve to `undefined`. Once a
  	 * property is set, additional defaults of the same property will be ignored.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @type Function
  	 * @category Objects
  	 * @param {Object} object The destination object.
  	 * @param {...Object} [source] The source objects.
  	 * @param- {Object} [guard] Allows working with `_.reduce` without using its
  	 *  `key` and `object` arguments as sources.
  	 * @returns {Object} Returns the destination object.
  	 * @example
  	 *
  	 * var object = { 'name': 'barney' };
  	 * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
  	 * // => { 'name': 'barney', 'employer': 'slate' }
  	 */
  	var defaults = function(object, source, guard) {
  	  var index, iterable = object, result = iterable;
  	  if (!iterable) return result;
  	  var args = arguments,
  	      argsIndex = 0,
  	      argsLength = typeof guard == 'number' ? 2 : args.length;
  	  while (++argsIndex < argsLength) {
  	    iterable = args[argsIndex];
  	    if (iterable && objectTypes[typeof iterable]) {
  	    var ownIndex = -1,
  	        ownProps = objectTypes[typeof iterable] && keys(iterable),
  	        length = ownProps ? ownProps.length : 0;

  	    while (++ownIndex < length) {
  	      index = ownProps[ownIndex];
  	      if (typeof result[index] == 'undefined') result[index] = iterable[index];
  	    }
  	    }
  	  }
  	  return result
  	};

  	module.exports = defaults;


  	/***/ }),
  	/* 134 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var htmlEscapes = __webpack_require__(59);

  	/**
  	 * Used by `escape` to convert characters to HTML entities.
  	 *
  	 * @private
  	 * @param {string} match The matched character to escape.
  	 * @returns {string} Returns the escaped character.
  	 */
  	function escapeHtmlChar(match) {
  	  return htmlEscapes[match];
  	}

  	module.exports = escapeHtmlChar;


  	/***/ }),
  	/* 135 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var htmlEscapes = __webpack_require__(59),
  	    keys = __webpack_require__(12);

  	/** Used to match HTML entities and HTML characters */
  	var reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

  	module.exports = reUnescapedHtml;


  	/***/ }),
  	/* 136 */
  	/***/ (function(module, exports) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */

  	/** Used to escape characters for inclusion in compiled string literals */
  	var stringEscapes = {
  	  '\\': '\\',
  	  "'": "'",
  	  '\n': 'n',
  	  '\r': 'r',
  	  '\t': 't',
  	  '\u2028': 'u2028',
  	  '\u2029': 'u2029'
  	};

  	/**
  	 * Used by `template` to escape characters for inclusion in compiled
  	 * string literals.
  	 *
  	 * @private
  	 * @param {string} match The matched character to escape.
  	 * @returns {string} Returns the escaped character.
  	 */
  	function escapeStringChar(match) {
  	  return '\\' + stringEscapes[match];
  	}

  	module.exports = escapeStringChar;


  	/***/ }),
  	/* 137 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var escape = __webpack_require__(58),
  	    reInterpolate = __webpack_require__(60);

  	/**
  	 * By default, the template delimiters used by Lo-Dash are similar to those in
  	 * embedded Ruby (ERB). Change the following template settings to use alternative
  	 * delimiters.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @type Object
  	 */
  	var templateSettings = {

  	  /**
  	   * Used to detect `data` property values to be HTML-escaped.
  	   *
  	   * @memberOf _.templateSettings
  	   * @type RegExp
  	   */
  	  'escape': /<%-([\s\S]+?)%>/g,

  	  /**
  	   * Used to detect code to be evaluated.
  	   *
  	   * @memberOf _.templateSettings
  	   * @type RegExp
  	   */
  	  'evaluate': /<%([\s\S]+?)%>/g,

  	  /**
  	   * Used to detect `data` property values to inject.
  	   *
  	   * @memberOf _.templateSettings
  	   * @type RegExp
  	   */
  	  'interpolate': reInterpolate,

  	  /**
  	   * Used to reference the data object in the template text.
  	   *
  	   * @memberOf _.templateSettings
  	   * @type string
  	   */
  	  'variable': '',

  	  /**
  	   * Used to import variables into the compiled template.
  	   *
  	   * @memberOf _.templateSettings
  	   * @type Object
  	   */
  	  'imports': {

  	    /**
  	     * A reference to the `lodash` function.
  	     *
  	     * @memberOf _.templateSettings.imports
  	     * @type Function
  	     */
  	    '_': { 'escape': escape }
  	  }
  	};

  	module.exports = templateSettings;


  	/***/ }),
  	/* 138 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */
  	var keys = __webpack_require__(12);

  	/**
  	 * Creates an array composed of the own enumerable property values of `object`.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Objects
  	 * @param {Object} object The object to inspect.
  	 * @returns {Array} Returns an array of property values.
  	 * @example
  	 *
  	 * _.values({ 'one': 1, 'two': 2, 'three': 3 });
  	 * // => [1, 2, 3] (property order is not guaranteed across environments)
  	 */
  	function values(object) {
  	  var index = -1,
  	      props = keys(object),
  	      length = props.length,
  	      result = Array(length);

  	  while (++index < length) {
  	    result[index] = object[props[index]];
  	  }
  	  return result;
  	}

  	module.exports = values;


  	/***/ }),
  	/* 139 */
  	/***/ (function(module, exports) {

  	/**
  	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
  	 * Build: `lodash modularize modern exports="npm" -o ./npm/`
  	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
  	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
  	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  	 * Available under MIT license <http://lodash.com/license>
  	 */

  	/** Used to generate unique IDs */
  	var idCounter = 0;

  	/**
  	 * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
  	 *
  	 * @static
  	 * @memberOf _
  	 * @category Utilities
  	 * @param {string} [prefix] The value to prefix the ID with.
  	 * @returns {string} Returns the unique ID.
  	 * @example
  	 *
  	 * _.uniqueId('contact_');
  	 * // => 'contact_104'
  	 *
  	 * _.uniqueId();
  	 * // => '105'
  	 */
  	function uniqueId(prefix) {
  	  var id = ++idCounter;
  	  return String(prefix == null ? '' : prefix) + id;
  	}

  	module.exports = uniqueId;


  	/***/ }),
  	/* 140 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var config = __webpack_require__(2);

  	var utils = __webpack_require__(1);

  	var Locales = {
  	  en: {
  	    general: {
  	      'delete': 'Delete?',
  	      'drop': 'Drag __block__ here',
  	      'paste': 'Or paste URL here',
  	      'upload': '...or choose a file',
  	      'close': 'close',
  	      'position': 'Position',
  	      'wait': 'Please wait...',
  	      'link': 'Enter a link',
  	      'yes': 'Yes',
  	      'no': 'No'
  	    },
  	    errors: {
  	      'title': "You have the following errors:",
  	      'validation_fail': "__type__ block is invalid",
  	      'block_empty': "__name__ must not be empty",
  	      'type_missing': "You must have a block of type __type__",
  	      'required_type_empty': "A required block type __type__ is empty",
  	      'load_fail': "There was a problem loading the contents of the document"
  	    },
  	    blocks: {
  	      text: {
  	        'title': "Text"
  	      },
  	      list: {
  	        'title': "List"
  	      },
  	      quote: {
  	        'title': "Quote",
  	        'credit_field': "Credit"
  	      },
  	      image: {
  	        'title': "Image",
  	        'upload_error': "There was a problem with your upload"
  	      },
  	      video: {
  	        'title': "Video"
  	      },
  	      tweet: {
  	        'title': "Tweet",
  	        'fetch_error': "There was a problem fetching your tweet"
  	      },
  	      embedly: {
  	        'title': "Embedly",
  	        'fetch_error': "There was a problem fetching your embed",
  	        'key_missing': "An Embedly API key must be present"
  	      },
  	      heading: {
  	        'title': "Heading"
  	      }
  	    }
  	  }
  	};

  	if (window.i18n === undefined) {
  	  // Minimal i18n stub that only reads the English strings
  	  utils.log("Using i18n stub");
  	  window.i18n = {
  	    t: function t(key, options) {
  	      var parts = key.split(':'),
  	          str,
  	          obj,
  	          part,
  	          i;
  	      obj = Locales[config.language];

  	      for (i = 0; i < parts.length; i++) {
  	        part = parts[i];

  	        if (!_.isUndefined(obj[part])) {
  	          obj = obj[part];
  	        }
  	      }

  	      str = obj;

  	      if (!_.isString(str)) {
  	        return "";
  	      }

  	      if (str.indexOf('__') >= 0) {
  	        Object.keys(options).forEach(function (opt) {
  	          str = str.replace('__' + opt + '__', options[opt]);
  	        });
  	      }

  	      return str;
  	    }
  	  };
  	} else {
  	  utils.log("Using i18next"); // Only use i18next when the library has been loaded by the user, keeps
  	  // dependencies slim

  	  i18n.init({
  	    resStore: Locales,
  	    fallbackLng: config.language,
  	    ns: {
  	      namespaces: ['general', 'blocks'],
  	      defaultNs: 'general'
  	    }
  	  });
  	}

  	module.exports = Locales;

  	/***/ }),
  	/* 141 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
  	  {
  	    // AMD. Register as a module.
  	    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
  	      return (root.Eventable = factory());
  	    }).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  	  }
  	}(this, function() {

  	  // Copy and pasted straight out of Backbone 1.0.0
  	  // We'll try and keep this updated to the latest

  	  var array = [];
  	  var slice = array.slice;

  	  function once(func) {
  	    var memo, times = 2;

  	    return function() {
  	      if (--times > 0) {
  	        memo = func.apply(this, arguments);
  	      } else {
  	        func = null;
  	      }
  	      return memo;
  	    };
  	  }

  	  // Backbone.Events
  	  // ---------------

  	  // A module that can be mixed in to *any object* in order to provide it with
  	  // custom events. You may bind with `on` or remove with `off` callback
  	  // functions to an event; `trigger`-ing an event fires all callbacks in
  	  // succession.
  	  //
  	  //     var object = {};
  	  //     extend(object, Backbone.Events);
  	  //     object.on('expand', function(){ alert('expanded'); });
  	  //     object.trigger('expand');
  	  //
  	  var Eventable = {

  	    // Bind an event to a `callback` function. Passing `"all"` will bind
  	    // the callback to all events fired.
  	    on: function(name, callback, context) {
  	      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
  	      this._events || (this._events = {});
  	      var events = this._events[name] || (this._events[name] = []);
  	      events.push({callback: callback, context: context, ctx: context || this});
  	      return this;
  	    },

  	    // Bind an event to only be triggered a single time. After the first time
  	    // the callback is invoked, it will be removed.
  	    once: function(name, callback, context) {
  	      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
  	      var self = this;
  	      var func = once(function() {
  	        self.off(name, func);
  	        callback.apply(this, arguments);
  	      });
  	      func._callback = callback;
  	      return this.on(name, func, context);
  	    },

  	    // Remove one or many callbacks. If `context` is null, removes all
  	    // callbacks with that function. If `callback` is null, removes all
  	    // callbacks for the event. If `name` is null, removes all bound
  	    // callbacks for all events.
  	    off: function(name, callback, context) {
  	      var retain, ev, events, names, i, l, j, k;
  	      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
  	      if (!name && !callback && !context) {
  	        this._events = {};
  	        return this;
  	      }

  	      names = name ? [name] : Object.keys(this._events);
  	      for (i = 0, l = names.length; i < l; i++) {
  	        name = names[i];
  	        if (events = this._events[name]) {
  	          this._events[name] = retain = [];
  	          if (callback || context) {
  	            for (j = 0, k = events.length; j < k; j++) {
  	              ev = events[j];
  	              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
  	                  (context && context !== ev.context)) {
  	                retain.push(ev);
  	              }
  	            }
  	          }
  	          if (!retain.length) delete this._events[name];
  	        }
  	      }

  	      return this;
  	    },

  	    // Trigger one or many events, firing all bound callbacks. Callbacks are
  	    // passed the same arguments as `trigger` is, apart from the event name
  	    // (unless you're listening on `"all"`, which will cause your callback to
  	    // receive the true name of the event as the first argument).
  	    trigger: function(name) {
  	      if (!this._events) return this;
  	      var args = slice.call(arguments, 1);
  	      if (!eventsApi(this, 'trigger', name, args)) return this;
  	      var events = this._events[name];
  	      var allEvents = this._events.all;
  	      if (events) triggerEvents(events, args);
  	      if (allEvents) triggerEvents(allEvents, arguments);
  	      return this;
  	    },

  	    // Tell this object to stop listening to either specific events ... or
  	    // to every object it's currently listening to.
  	    stopListening: function(obj, name, callback) {
  	      var listeners = this._listeners;
  	      if (!listeners) return this;
  	      var deleteListener = !name && !callback;
  	      if (typeof name === 'object') callback = this;
  	      if (obj) (listeners = {})[obj._listenerId] = obj;
  	      for (var id in listeners) {
  	        listeners[id].off(name, callback, this);
  	        if (deleteListener) delete this._listeners[id];
  	      }
  	      return this;
  	    }

  	  };

  	  // Regular expression used to split event strings.
  	  var eventSplitter = /\s+/;

  	  // Implement fancy features of the Events API such as multiple event
  	  // names `"change blur"` and jQuery-style event maps `{change: action}`
  	  // in terms of the existing API.
  	  var eventsApi = function(obj, action, name, rest) {
  	    if (!name) return true;

  	    // Handle event maps.
  	    if (typeof name === 'object') {
  	      for (var key in name) {
  	        obj[action].apply(obj, [key, name[key]].concat(rest));
  	      }
  	      return false;
  	    }

  	    // Handle space separated event names.
  	    if (eventSplitter.test(name)) {
  	      var names = name.split(eventSplitter);
  	      for (var i = 0, l = names.length; i < l; i++) {
  	        obj[action].apply(obj, [names[i]].concat(rest));
  	      }
  	      return false;
  	    }

  	    return true;
  	  };

  	  // A difficult-to-believe, but optimized internal dispatch function for
  	  // triggering events. Tries to keep the usual cases speedy (most internal
  	  // Backbone events have 3 arguments).
  	  var triggerEvents = function(events, args) {
  	    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
  	    switch (args.length) {
  	      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
  	      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
  	      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
  	      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
  	      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
  	    }
  	  };

  	  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  	  // listen to an event in another object ... keeping track of what it's
  	  // listening to.
  	  function addListenMethod(method, implementation) {
  	    Eventable[method] = function(obj, name, callback) {
  	      var listeners = this._listeners || (this._listeners = {});
  	      var id = obj._listenerId || (obj._listenerId = (new Date()).getTime());
  	      listeners[id] = obj;
  	      if (typeof name === 'object') callback = this;
  	      obj[implementation](name, callback, this);
  	      return this;
  	    };
  	  }

  	  addListenMethod('listenTo', 'on');
  	  addListenMethod('listenToOnce', 'once');

  	  // Aliases for backwards compatibility.
  	  Eventable.bind   = Eventable.on;
  	  Eventable.unbind = Eventable.off;

  	  return Eventable;

  	}));


  	/***/ }),
  	/* 142 */
  	/***/ (function(module, __webpack_exports__, __webpack_require__) {
  	__webpack_require__.r(__webpack_exports__);
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Headers", function() { return Headers; });
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Response", function() { return Response; });
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMException", function() { return DOMException; });
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetch", function() { return fetch; });
  	var support = {
  	  searchParams: 'URLSearchParams' in self,
  	  iterable: 'Symbol' in self && 'iterator' in Symbol,
  	  blob:
  	    'FileReader' in self &&
  	    'Blob' in self &&
  	    (function() {
  	      try {
  	        new Blob();
  	        return true
  	      } catch (e) {
  	        return false
  	      }
  	    })(),
  	  formData: 'FormData' in self,
  	  arrayBuffer: 'ArrayBuffer' in self
  	};

  	function isDataView(obj) {
  	  return obj && DataView.prototype.isPrototypeOf(obj)
  	}

  	if (support.arrayBuffer) {
  	  var viewClasses = [
  	    '[object Int8Array]',
  	    '[object Uint8Array]',
  	    '[object Uint8ClampedArray]',
  	    '[object Int16Array]',
  	    '[object Uint16Array]',
  	    '[object Int32Array]',
  	    '[object Uint32Array]',
  	    '[object Float32Array]',
  	    '[object Float64Array]'
  	  ];

  	  var isArrayBufferView =
  	    ArrayBuffer.isView ||
  	    function(obj) {
  	      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
  	    };
  	}

  	function normalizeName(name) {
  	  if (typeof name !== 'string') {
  	    name = String(name);
  	  }
  	  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
  	    throw new TypeError('Invalid character in header field name')
  	  }
  	  return name.toLowerCase()
  	}

  	function normalizeValue(value) {
  	  if (typeof value !== 'string') {
  	    value = String(value);
  	  }
  	  return value
  	}

  	// Build a destructive iterator for the value list
  	function iteratorFor(items) {
  	  var iterator = {
  	    next: function() {
  	      var value = items.shift();
  	      return {done: value === undefined, value: value}
  	    }
  	  };

  	  if (support.iterable) {
  	    iterator[Symbol.iterator] = function() {
  	      return iterator
  	    };
  	  }

  	  return iterator
  	}

  	function Headers(headers) {
  	  this.map = {};

  	  if (headers instanceof Headers) {
  	    headers.forEach(function(value, name) {
  	      this.append(name, value);
  	    }, this);
  	  } else if (Array.isArray(headers)) {
  	    headers.forEach(function(header) {
  	      this.append(header[0], header[1]);
  	    }, this);
  	  } else if (headers) {
  	    Object.getOwnPropertyNames(headers).forEach(function(name) {
  	      this.append(name, headers[name]);
  	    }, this);
  	  }
  	}

  	Headers.prototype.append = function(name, value) {
  	  name = normalizeName(name);
  	  value = normalizeValue(value);
  	  var oldValue = this.map[name];
  	  this.map[name] = oldValue ? oldValue + ', ' + value : value;
  	};

  	Headers.prototype['delete'] = function(name) {
  	  delete this.map[normalizeName(name)];
  	};

  	Headers.prototype.get = function(name) {
  	  name = normalizeName(name);
  	  return this.has(name) ? this.map[name] : null
  	};

  	Headers.prototype.has = function(name) {
  	  return this.map.hasOwnProperty(normalizeName(name))
  	};

  	Headers.prototype.set = function(name, value) {
  	  this.map[normalizeName(name)] = normalizeValue(value);
  	};

  	Headers.prototype.forEach = function(callback, thisArg) {
  	  for (var name in this.map) {
  	    if (this.map.hasOwnProperty(name)) {
  	      callback.call(thisArg, this.map[name], name, this);
  	    }
  	  }
  	};

  	Headers.prototype.keys = function() {
  	  var items = [];
  	  this.forEach(function(value, name) {
  	    items.push(name);
  	  });
  	  return iteratorFor(items)
  	};

  	Headers.prototype.values = function() {
  	  var items = [];
  	  this.forEach(function(value) {
  	    items.push(value);
  	  });
  	  return iteratorFor(items)
  	};

  	Headers.prototype.entries = function() {
  	  var items = [];
  	  this.forEach(function(value, name) {
  	    items.push([name, value]);
  	  });
  	  return iteratorFor(items)
  	};

  	if (support.iterable) {
  	  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  	}

  	function consumed(body) {
  	  if (body.bodyUsed) {
  	    return Promise.reject(new TypeError('Already read'))
  	  }
  	  body.bodyUsed = true;
  	}

  	function fileReaderReady(reader) {
  	  return new Promise(function(resolve, reject) {
  	    reader.onload = function() {
  	      resolve(reader.result);
  	    };
  	    reader.onerror = function() {
  	      reject(reader.error);
  	    };
  	  })
  	}

  	function readBlobAsArrayBuffer(blob) {
  	  var reader = new FileReader();
  	  var promise = fileReaderReady(reader);
  	  reader.readAsArrayBuffer(blob);
  	  return promise
  	}

  	function readBlobAsText(blob) {
  	  var reader = new FileReader();
  	  var promise = fileReaderReady(reader);
  	  reader.readAsText(blob);
  	  return promise
  	}

  	function readArrayBufferAsText(buf) {
  	  var view = new Uint8Array(buf);
  	  var chars = new Array(view.length);

  	  for (var i = 0; i < view.length; i++) {
  	    chars[i] = String.fromCharCode(view[i]);
  	  }
  	  return chars.join('')
  	}

  	function bufferClone(buf) {
  	  if (buf.slice) {
  	    return buf.slice(0)
  	  } else {
  	    var view = new Uint8Array(buf.byteLength);
  	    view.set(new Uint8Array(buf));
  	    return view.buffer
  	  }
  	}

  	function Body() {
  	  this.bodyUsed = false;

  	  this._initBody = function(body) {
  	    this._bodyInit = body;
  	    if (!body) {
  	      this._bodyText = '';
  	    } else if (typeof body === 'string') {
  	      this._bodyText = body;
  	    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
  	      this._bodyBlob = body;
  	    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
  	      this._bodyFormData = body;
  	    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
  	      this._bodyText = body.toString();
  	    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
  	      this._bodyArrayBuffer = bufferClone(body.buffer);
  	      // IE 10-11 can't handle a DataView body.
  	      this._bodyInit = new Blob([this._bodyArrayBuffer]);
  	    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
  	      this._bodyArrayBuffer = bufferClone(body);
  	    } else {
  	      this._bodyText = body = Object.prototype.toString.call(body);
  	    }

  	    if (!this.headers.get('content-type')) {
  	      if (typeof body === 'string') {
  	        this.headers.set('content-type', 'text/plain;charset=UTF-8');
  	      } else if (this._bodyBlob && this._bodyBlob.type) {
  	        this.headers.set('content-type', this._bodyBlob.type);
  	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
  	        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
  	      }
  	    }
  	  };

  	  if (support.blob) {
  	    this.blob = function() {
  	      var rejected = consumed(this);
  	      if (rejected) {
  	        return rejected
  	      }

  	      if (this._bodyBlob) {
  	        return Promise.resolve(this._bodyBlob)
  	      } else if (this._bodyArrayBuffer) {
  	        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
  	      } else if (this._bodyFormData) {
  	        throw new Error('could not read FormData body as blob')
  	      } else {
  	        return Promise.resolve(new Blob([this._bodyText]))
  	      }
  	    };

  	    this.arrayBuffer = function() {
  	      if (this._bodyArrayBuffer) {
  	        return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
  	      } else {
  	        return this.blob().then(readBlobAsArrayBuffer)
  	      }
  	    };
  	  }

  	  this.text = function() {
  	    var rejected = consumed(this);
  	    if (rejected) {
  	      return rejected
  	    }

  	    if (this._bodyBlob) {
  	      return readBlobAsText(this._bodyBlob)
  	    } else if (this._bodyArrayBuffer) {
  	      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
  	    } else if (this._bodyFormData) {
  	      throw new Error('could not read FormData body as text')
  	    } else {
  	      return Promise.resolve(this._bodyText)
  	    }
  	  };

  	  if (support.formData) {
  	    this.formData = function() {
  	      return this.text().then(decode)
  	    };
  	  }

  	  this.json = function() {
  	    return this.text().then(JSON.parse)
  	  };

  	  return this
  	}

  	// HTTP methods whose capitalization should be normalized
  	var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  	function normalizeMethod(method) {
  	  var upcased = method.toUpperCase();
  	  return methods.indexOf(upcased) > -1 ? upcased : method
  	}

  	function Request(input, options) {
  	  options = options || {};
  	  var body = options.body;

  	  if (input instanceof Request) {
  	    if (input.bodyUsed) {
  	      throw new TypeError('Already read')
  	    }
  	    this.url = input.url;
  	    this.credentials = input.credentials;
  	    if (!options.headers) {
  	      this.headers = new Headers(input.headers);
  	    }
  	    this.method = input.method;
  	    this.mode = input.mode;
  	    this.signal = input.signal;
  	    if (!body && input._bodyInit != null) {
  	      body = input._bodyInit;
  	      input.bodyUsed = true;
  	    }
  	  } else {
  	    this.url = String(input);
  	  }

  	  this.credentials = options.credentials || this.credentials || 'same-origin';
  	  if (options.headers || !this.headers) {
  	    this.headers = new Headers(options.headers);
  	  }
  	  this.method = normalizeMethod(options.method || this.method || 'GET');
  	  this.mode = options.mode || this.mode || null;
  	  this.signal = options.signal || this.signal;
  	  this.referrer = null;

  	  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
  	    throw new TypeError('Body not allowed for GET or HEAD requests')
  	  }
  	  this._initBody(body);
  	}

  	Request.prototype.clone = function() {
  	  return new Request(this, {body: this._bodyInit})
  	};

  	function decode(body) {
  	  var form = new FormData();
  	  body
  	    .trim()
  	    .split('&')
  	    .forEach(function(bytes) {
  	      if (bytes) {
  	        var split = bytes.split('=');
  	        var name = split.shift().replace(/\+/g, ' ');
  	        var value = split.join('=').replace(/\+/g, ' ');
  	        form.append(decodeURIComponent(name), decodeURIComponent(value));
  	      }
  	    });
  	  return form
  	}

  	function parseHeaders(rawHeaders) {
  	  var headers = new Headers();
  	  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  	  // https://tools.ietf.org/html/rfc7230#section-3.2
  	  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  	  preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
  	    var parts = line.split(':');
  	    var key = parts.shift().trim();
  	    if (key) {
  	      var value = parts.join(':').trim();
  	      headers.append(key, value);
  	    }
  	  });
  	  return headers
  	}

  	Body.call(Request.prototype);

  	function Response(bodyInit, options) {
  	  if (!options) {
  	    options = {};
  	  }

  	  this.type = 'default';
  	  this.status = options.status === undefined ? 200 : options.status;
  	  this.ok = this.status >= 200 && this.status < 300;
  	  this.statusText = 'statusText' in options ? options.statusText : 'OK';
  	  this.headers = new Headers(options.headers);
  	  this.url = options.url || '';
  	  this._initBody(bodyInit);
  	}

  	Body.call(Response.prototype);

  	Response.prototype.clone = function() {
  	  return new Response(this._bodyInit, {
  	    status: this.status,
  	    statusText: this.statusText,
  	    headers: new Headers(this.headers),
  	    url: this.url
  	  })
  	};

  	Response.error = function() {
  	  var response = new Response(null, {status: 0, statusText: ''});
  	  response.type = 'error';
  	  return response
  	};

  	var redirectStatuses = [301, 302, 303, 307, 308];

  	Response.redirect = function(url, status) {
  	  if (redirectStatuses.indexOf(status) === -1) {
  	    throw new RangeError('Invalid status code')
  	  }

  	  return new Response(null, {status: status, headers: {location: url}})
  	};

  	var DOMException = self.DOMException;
  	try {
  	  new DOMException();
  	} catch (err) {
  	  DOMException = function(message, name) {
  	    this.message = message;
  	    this.name = name;
  	    var error = Error(message);
  	    this.stack = error.stack;
  	  };
  	  DOMException.prototype = Object.create(Error.prototype);
  	  DOMException.prototype.constructor = DOMException;
  	}

  	function fetch(input, init) {
  	  return new Promise(function(resolve, reject) {
  	    var request = new Request(input, init);

  	    if (request.signal && request.signal.aborted) {
  	      return reject(new DOMException('Aborted', 'AbortError'))
  	    }

  	    var xhr = new XMLHttpRequest();

  	    function abortXhr() {
  	      xhr.abort();
  	    }

  	    xhr.onload = function() {
  	      var options = {
  	        status: xhr.status,
  	        statusText: xhr.statusText,
  	        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
  	      };
  	      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
  	      var body = 'response' in xhr ? xhr.response : xhr.responseText;
  	      resolve(new Response(body, options));
  	    };

  	    xhr.onerror = function() {
  	      reject(new TypeError('Network request failed'));
  	    };

  	    xhr.ontimeout = function() {
  	      reject(new TypeError('Network request failed'));
  	    };

  	    xhr.onabort = function() {
  	      reject(new DOMException('Aborted', 'AbortError'));
  	    };

  	    xhr.open(request.method, request.url, true);

  	    if (request.credentials === 'include') {
  	      xhr.withCredentials = true;
  	    } else if (request.credentials === 'omit') {
  	      xhr.withCredentials = false;
  	    }

  	    if ('responseType' in xhr && support.blob) {
  	      xhr.responseType = 'blob';
  	    }

  	    request.headers.forEach(function(value, name) {
  	      xhr.setRequestHeader(name, value);
  	    });

  	    if (request.signal) {
  	      request.signal.addEventListener('abort', abortXhr);

  	      xhr.onreadystatechange = function() {
  	        // DONE (success or failure)
  	        if (xhr.readyState === 4) {
  	          request.signal.removeEventListener('abort', abortXhr);
  	        }
  	      };
  	    }

  	    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  	  })
  	}

  	fetch.polyfill = true;

  	if (!self.fetch) {
  	  self.fetch = fetch;
  	  self.Headers = Headers;
  	  self.Request = Request;
  	  self.Response = Response;
  	}


  	/***/ }),
  	/* 143 */
  	/***/ (function(module, exports) {

  	/**
  	 * MIT license
  	 */

  	// Callback index.
  	var count = 0;

  	/**
  	 * JSONP handler
  	 *
  	 * Options:
  	 * - prefix {String} callback prefix (defaults to `__jp`)
  	 * - param {String} qs parameter (defaults to `callback`)
  	 * - timeout {Number} how long after the request until a timeout error
  	 *   is emitted (defaults to `15000`)
  	 *
  	 * @param {String} url
  	 * @param {Object} options optional options
  	 * @return {Object} Returns a response promise and a cancel handler.
  	 */
  	var jsonp = function(url, options) {
  	    options = options || {};

  	    var prefix = options.prefix || '__jp';
  	    var param = options.param || 'callback';
  	    var timeout = options.timeout ? options.timeout : 15000;
  	    var target = document.getElementsByTagName('script')[0] || document.head;
  	    var script;
  	    var timer;
  	    var cleanup;
  	    var cancel;
  	    var promise;
  	    var noop = function() {};

  	    // Generate a unique id for the request.
  	    var id = prefix + (count++);

  	    cleanup = function() {
  	        // Remove the script tag.
  	        if (script && script.parentNode) {
  	            script.parentNode.removeChild(script);
  	        }

  	        window[id] = noop;

  	        if (timer) {
  	            clearTimeout(timer);
  	        }
  	    };

  	    promise = new Promise(function(resolve, reject) {
  	        if (timeout) {
  	            timer = setTimeout(function() {
  	                cleanup();
  	                reject(new Error('Timeout'));
  	            }, timeout);
  	        }

  	        window[id] = function(data) {
  	            cleanup();
  	            resolve(data);
  	        };

  	        // Add querystring component
  	        url += (~url.indexOf('?') ? '&' : '?') + param + '=' + encodeURIComponent(id);
  	        url = url.replace('?&', '?');

  	        // Create script.
  	        script = document.createElement('script');
  	        script.src = url;
  	        target.parentNode.insertBefore(script, target);

  	        cancel = function() {
  	            if (window[id]) {
  	                cleanup();
  	                reject(new Error('Canceled'));
  	            }
  	        };

  	    });

  	    return {
  	        promise: promise,
  	        cancel: cancel
  	    };
  	};

  	module.exports = jsonp;



  	/***/ }),
  	/* 144 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var cancellablePromise = function cancellablePromise(promise) {
  	  var resolve, reject;
  	  var proxyPromise = new Promise(function (res, rej) {
  	    resolve = res;
  	    reject = rej;
  	  });
  	  promise.then(function (value) {
  	    if (!proxyPromise.cancelled) {
  	      resolve(value);
  	    }
  	  }, function (value) {
  	    if (!proxyPromise.cancelled) {
  	      reject(value);
  	    }
  	  });

  	  proxyPromise.cancel = function () {
  	    this.cancelled = true;
  	  };

  	  return proxyPromise;
  	};

  	module.exports = cancellablePromise;

  	/***/ }),
  	/* 145 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var utils = __webpack_require__(1);

  	var config = __webpack_require__(2);

  	var Dom = __webpack_require__(3);

  	var Events = __webpack_require__(10);

  	module.exports = {
  	  mixinName: "Controllable",
  	  initializeControllable: function initializeControllable() {
  	    utils.log("Adding controllable to block " + this.blockID);
  	    this.inner.classList.add('st-block__inner--controllable');
  	    this.control_ui = Dom.createElement('div', {
  	      'class': 'st-block__control-ui'
  	    });
  	    Object.keys(this.controls).forEach(function (cmd) {
  	      // Bind configured handler to current block context
  	      this.addUiControl(cmd, this.controls[cmd].bind(this));
  	    }, this);
  	    this.inner.appendChild(this.control_ui);
  	  },
  	  getControlTemplate: function getControlTemplate(cmd) {
  	    return Dom.createElement("a", {
  	      'data-icon': cmd,
  	      'class': 'st-icon st-block-control-ui-btn st-block-control-ui-btn--' + cmd,
  	      'html': "<svg role=\"img\" class=\"st-icon\">\n                  <use xlink:href=\"".concat(config.defaults.iconUrl, "#").concat(cmd, "\"/>\n                </svg>")
  	    });
  	  },
  	  addUiControl: function addUiControl(cmd, handler) {
  	    var _this = this;

  	    this.control_ui.appendChild(this.getControlTemplate(cmd));
  	    Events.delegate(this.control_ui, '.st-block-control-ui-btn--' + cmd, 'click', function (e) {
  	      _this.selectUiControl(cmd);

  	      handler(e);
  	    });
  	  },
  	  selectUiControl: function selectUiControl(cmd) {
  	    var _this2 = this;

  	    var selectedClass = 'st-block-control-ui-btn--selected';
  	    Object.keys(this.controls).forEach(function (control) {
  	      _this2.getControlUiBtn(control).classList.remove(selectedClass);
  	    });
  	    this.getControlUiBtn(cmd).classList.add(selectedClass);
  	  },
  	  getControlUiBtn: function getControlUiBtn(cmd) {
  	    return this.control_ui.querySelector('.st-block-control-ui-btn--' + cmd);
  	  }
  	};

  	/***/ }),
  	/* 146 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/* Adds drop functionaltiy to this block */

  	var _ = __webpack_require__(0);

  	var config = __webpack_require__(2);

  	var utils = __webpack_require__(1);

  	var Dom = __webpack_require__(3);

  	var dropEvents = __webpack_require__(35);

  	var EventBus = __webpack_require__(4);

  	module.exports = {
  	  mixinName: "Droppable",
  	  valid_drop_file_types: ['File', 'Files', 'text/plain', 'text/uri-list'],
  	  requireInputs: true,
  	  initializeDroppable: function initializeDroppable() {
  	    utils.log("Adding droppable to block " + this.blockID);
  	    this.drop_options = Object.assign({}, config.defaults.Block.drop_options, this.drop_options);
  	    Dom.hide(this.editor);
  	    this.inputs.insertAdjacentHTML("beforeend", _.template(this.drop_options.html, {
  	      block: this,
  	      _: _,
  	      config: config
  	    })); // Bind our drop event

  	    dropEvents.dropArea(this.inputs.lastElementChild).addEventListener('drop', this._handleDrop.bind(this));
  	    this.el.classList.add('st-block--droppable');
  	    this.inner.classList.add('st-block__inner--droppable');

  	    this._setupKeyEvents();
  	  },
  	  _handleDrop: function _handleDrop(e) {
  	    e.preventDefault();
  	    e.stopPropagation();
  	    var el = e.target,
  	        types = [].slice.call(e.dataTransfer.types);
  	    el.classList.remove('st-dropzone--dragover');
  	    /*
  	      Check the type we just received,
  	      delegate it away to our blockTypes to process
  	    */

  	    if (types && types.some(function (type) {
  	      return this.valid_drop_file_types.includes(type);
  	    }, this)) {
  	      this.onDrop(e.dataTransfer);
  	    }

  	    EventBus.trigger('block:content:dropped', this.blockID);
  	  },
  	  focus: function focus() {
  	    this.inner.focus();
  	  },

  	  /**
  	    Allow this block to be managed with the keyboard
  	  **/
  	  _setupKeyEvents: function _setupKeyEvents() {
  	    var _this = this;

  	    this.inner.setAttribute('tabindex', 0);
  	    this.inner.addEventListener('keyup', function (e) {
  	      if (e.target !== _this.inner) {
  	        return;
  	      }

  	      switch (e.keyCode) {
  	        case 13:
  	          _this.mediator.trigger("block:create", 'Text', null, _this.el, {
  	            autoFocus: true
  	          });

  	          break;

  	        case 8:
  	          _this.onDeleteClick.call(_this, new CustomEvent('click'));

  	          return;
  	      }
  	    });
  	  }
  	};

  	/***/ }),
  	/* 147 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var Ajax = __webpack_require__(64);

  	module.exports = {
  	  mixinName: "Fetchable",
  	  initializeFetchable: function initializeFetchable() {
  	    this.withMixin(__webpack_require__(34));
  	  },
  	  fetch: function fetch(url, options, success, failure) {
  	    var uid = _.uniqueId(this.blockID + "_fetch"),
  	        xhr = Ajax.fetch(url, options);

  	    this.resetMessages();
  	    this.addQueuedItem(uid, xhr);

  	    function alwaysFunc(func, arg) {
  	      /*jshint validthis: true */
  	      func.call(this, arg);
  	      this.removeQueuedItem(uid);
  	    }

  	    if (!_.isUndefined(success)) {
  	      xhr.then(alwaysFunc.bind(this, success));
  	    }

  	    if (!_.isUndefined(failure)) {
  	      xhr.catch(alwaysFunc.bind(this, failure));
  	    }

  	    return xhr;
  	  }
  	};

  	/***/ }),
  	/* 148 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var config = __webpack_require__(2);

  	var utils = __webpack_require__(1);

  	module.exports = {
  	  mixinName: "Pastable",
  	  requireInputs: true,
  	  initializePastable: function initializePastable() {
  	    var _this = this;

  	    utils.log("Adding pastable to block " + this.blockID);
  	    this.paste_options = Object.assign({}, config.defaults.Block.paste_options, this.paste_options);
  	    this.inputs.insertAdjacentHTML("beforeend", _.template(this.paste_options.html, this));
  	    Array.prototype.forEach.call(this.$('.st-paste-block'), function (el) {
  	      el.addEventListener('click', function () {
  	        var event = document.createEvent('HTMLEvents');
  	        event.initEvent('select', true, false);
  	        this.dispatchEvent(event);
  	      });
  	      el.addEventListener('paste', _this._handleContentPaste);
  	      el.addEventListener('submit', _this._handleContentPaste);
  	    });
  	  }
  	};

  	/***/ }),
  	/* 149 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var config = __webpack_require__(2);

  	var utils = __webpack_require__(1);

  	var fileUploader = __webpack_require__(63);

  	module.exports = {
  	  mixinName: "Uploadable",
  	  uploadsCount: 0,
  	  requireInputs: true,
  	  initializeUploadable: function initializeUploadable() {
  	    utils.log("Adding uploadable to block " + this.blockID);
  	    this.withMixin(__webpack_require__(34));
  	    this.upload_options = Object.assign({}, config.defaults.Block.upload_options, this.upload_options);
  	    this.inputs.insertAdjacentHTML("beforeend", _.template(this.upload_options.html, this));
  	    Array.prototype.forEach.call(this.inputs.querySelectorAll('button'), function (button) {
  	      button.addEventListener('click', function (ev) {
  	        ev.preventDefault();
  	      });
  	    });
  	    Array.prototype.forEach.call(this.inputs.querySelectorAll('input'), function (input) {
  	      input.addEventListener('change', function (ev) {
  	        this.onDrop(ev.currentTarget);
  	      }.bind(this));
  	    }.bind(this));
  	  },
  	  uploader: function uploader(file, success, failure) {
  	    return fileUploader(this, file, success, failure);
  	  }
  	};

  	/***/ }),
  	/* 150 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var selectionRange = __webpack_require__(13);

  	var _ = __webpack_require__(0);

  	var ScribeInterface = __webpack_require__(68);

  	var _require = __webpack_require__(16),
  	    trimScribeContent = _require.trimScribeContent;

  	module.exports = {
  	  mixinName: 'MultiEditable',
  	  initializeMultiEditable: function initializeMultiEditable() {
  	    this.editors = {};
  	  },
  	  newTextEditor: function newTextEditor(template_or_node, content) {
  	    var editor, isTextTemplate, wrapper;
  	    isTextTemplate = template_or_node.tagName === undefined;

  	    if (isTextTemplate) {
  	      // render template outside of dom
  	      wrapper = document.createElement('div');
  	      wrapper.innerHTML = template_or_node;
  	      editor = wrapper.querySelector('.st-block__editor');
  	    } else {
  	      editor = template_or_node;
  	    }

  	    var id = _.uniqueId('editor-');

  	    editor.setAttribute('data-editorId', id);
  	    editor.addEventListener('keyup', this.getSelectionForFormatter);
  	    editor.addEventListener('mouseup', this.getSelectionForFormatter);
  	    var configureScribe = _.isFunction(this.configureScribe) ? this.configureScribe.bind(this) : null;
  	    var scribe = ScribeInterface.initScribeInstance(editor, this.scribeOptions, configureScribe);
  	    scribe.setContent(content);
  	    var editorObject = {
  	      node: isTextTemplate ? wrapper.removeChild(wrapper.firstChild) : editor,
  	      el: editor,
  	      scribe: scribe,
  	      id: id
  	    };
  	    this.editors[id] = editorObject;
  	    return editorObject;
  	  },
  	  getCurrentTextEditor: function getCurrentTextEditor() {
  	    var id = document.activeElement.getAttribute('data-editorId');
  	    var editor = this.getTextEditor(id);

  	    if (editor) {
  	      this.currentEditor = editor;
  	    }

  	    return this.currentEditor;
  	  },
  	  appendToTextEditor: function appendToTextEditor(id, content) {
  	    var scribe = this.getTextEditor(id).scribe;
  	    trimScribeContent(scribe);
  	    var range = document.createRange();
  	    range.selectNodeContents(scribe.el);
  	    range.collapse(false);
  	    var selection = new scribe.api.Selection();
  	    selection.selection.removeAllRanges();
  	    selection.selection.addRange(range);
  	    var caretPosition = selectionRange(scribe.el);

  	    if (content) {
  	      scribe.insertHTML(content);
  	    }

  	    selectionRange(scribe.el, {
  	      start: caretPosition.start,
  	      end: caretPosition.end
  	    });
  	  },
  	  getCurrentScribeInstance: function getCurrentScribeInstance() {
  	    return this.getCurrentTextEditor().scribe;
  	  },
  	  getTextEditor: function getTextEditor(id) {
  	    return this.editors[id];
  	  },
  	  removeTextEditor: function removeTextEditor(id) {
  	    delete this.editors[id];
  	  },
  	  // scribe commands for FormatBar
  	  execTextBlockCommand: function execTextBlockCommand(cmdName) {
  	    return ScribeInterface.execTextBlockCommand(this.getCurrentScribeInstance(), cmdName);
  	  },
  	  queryTextBlockCommandState: function queryTextBlockCommandState(cmdName) {
  	    return ScribeInterface.queryTextBlockCommandState(this.getCurrentScribeInstance(), cmdName);
  	  }
  	};

  	/***/ }),
  	/* 151 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/**
  	 * Module Dependencies
  	 */

  	var xor, props;

  	try {
  	  xor = __webpack_require__(66);
  	} catch (e) {
  	  xor = __webpack_require__(66);
  	}

  	try {
  	  props = __webpack_require__(67);
  	} catch (e) {
  	  props = __webpack_require__(67);
  	}

  	/**
  	 * Export `Iterator`
  	 */

  	module.exports = Iterator;

  	/**
  	 * Initialize `Iterator`
  	 *
  	 * @param {Node} node
  	 * @param {Node} root
  	 * @return {Iterator} self
  	 * @api public
  	 */

  	function Iterator(node, root) {
  	  if (!(this instanceof Iterator)) return new Iterator(node, root);
  	  this.node = this.start = this.peeked = node;
  	  this.root = root;
  	  this.closingTag = false;
  	  this._revisit = true;
  	  this._selects = [];
  	  this._rejects = [];

  	  if (node && this.higher(node)) {
  	    throw new Error('root must be a parent or ancestor to node');
  	  }
  	}

  	/**
  	 * Reset the Iterator
  	 *
  	 * @param {Node} node (optional)
  	 * @return {Iterator} self
  	 * @api public
  	 */

  	Iterator.prototype.reset = function(node) {
  	  this.node = node || this.start;
  	  return this;
  	};

  	/**
  	 * Revisit element nodes. Defaults to `true`
  	 */

  	Iterator.prototype.revisit = function(revisit) {
  	  this._revisit = undefined == revisit ? true : revisit;
  	  return this;
  	};

  	/**
  	 * Jump to the opening tag
  	 */

  	Iterator.prototype.opening = function() {
  	  if (1 == this.node.nodeType) this.closingTag = false;
  	  return this;
  	};

  	/**
  	 * Jump to the closing tag
  	 */

  	Iterator.prototype.atOpening = function() {
  	  return !this.closingTag;
  	};


  	/**
  	 * Jump to the closing tag
  	 */

  	Iterator.prototype.closing = function() {
  	  if (1 == this.node.nodeType) this.closingTag = true;
  	  return this;
  	};

  	/**
  	 * Jump to the closing tag
  	 */

  	Iterator.prototype.atClosing = function() {
  	  return this.closingTag;
  	};

  	/**
  	 * Next node
  	 *
  	 * @param {Number} type
  	 * @return {Node|null}
  	 * @api public
  	 */

  	Iterator.prototype.next = traverse('nextSibling', 'firstChild');

  	/**
  	 * Previous node
  	 *
  	 * @param {Number} type
  	 * @return {Node|null}
  	 * @api public
  	 */

  	Iterator.prototype.previous =
  	Iterator.prototype.prev = traverse('previousSibling', 'lastChild');

  	/**
  	 * Make traverse function
  	 *
  	 * @param {String} dir
  	 * @param {String} child
  	 * @return {Function}
  	 * @api private
  	 */

  	function traverse(dir, child) {
  	  var next = dir == 'nextSibling';
  	  return function walk(expr, n, peek) {
  	    expr = this.compile(expr);
  	    n = n && n > 0 ? n : 1;
  	    var node = this.node;
  	    var closing = this.closingTag;
  	    var revisit = this._revisit;

  	    while (node) {
  	      if (xor(next, closing) && node[child]) {
  	        // element with children: <em>...</em>
  	        node = node[child];
  	        closing = !next;
  	      } else if (1 == node.nodeType && !node[child] && xor(next, closing)) {
  	        // empty element tag: <em></em>
  	        closing = next;
  	        if (!revisit) continue;
  	      } else if (node[dir]) {
  	        // element has a neighbor: ...<em></em>...
  	        node = node[dir];
  	        closing = !next;
  	      } else {
  	        // done with current layer, move up.
  	        node = node.parentNode;
  	        closing = next;
  	        if (!revisit) continue;
  	      }

  	      if (!node || this.higher(node, this.root)) break;

  	      if (expr(node) && this.selects(node, peek) && this.rejects(node, peek)) {
  	        if (--n) continue;
  	        if (!peek) this.node = node;
  	        this.closingTag = closing;
  	        return node;
  	      }
  	    }

  	    return null;
  	  };
  	}

  	/**
  	 * Select nodes that cause `expr(node)`
  	 * to be truthy
  	 *
  	 * @param {Number|String|Function} expr
  	 * @return {Iterator} self
  	 * @api public
  	 */

  	Iterator.prototype.select = function(expr) {
  	  expr = this.compile(expr);
  	  this._selects.push(expr);
  	  return this;
  	};

  	/**
  	 * Run through the selects ORing each
  	 *
  	 * @param {Node} node
  	 * @param {Boolean} peek
  	 * @return {Boolean}
  	 * @api private
  	 */

  	Iterator.prototype.selects = function(node, peek) {
  	  var exprs = this._selects;
  	  var len = exprs.length;
  	  if (!len) return true;

  	  for (var i = 0; i < len; i++) {
  	    if (exprs[i].call(this, node, peek)) return true;
  	  }
  	  return false;
  	};

  	/**
  	 * Select nodes that cause `expr(node)`
  	 * to be falsy
  	 *
  	 * @param {Number|String|Function} expr
  	 * @return {Iterator} self
  	 * @api public
  	 */

  	Iterator.prototype.reject = function(expr) {
  	  expr = this.compile(expr);
  	  this._rejects.push(expr);
  	  return this;
  	};

  	/**
  	 * Run through the reject expressions ANDing each
  	 *
  	 * @param {Node} node
  	 * @param {Boolean} peek
  	 * @return {Boolean}
  	 * @api private
  	 */

  	Iterator.prototype.rejects = function(node, peek) {
  	  var exprs = this._rejects;
  	  var len = exprs.length;
  	  if (!len) return true;

  	  for (var i = 0; i < len; i++) {
  	    if (exprs[i].call(this, node, peek)) return false;
  	  }
  	  return true;
  	};

  	/**
  	 * Check if node is higher
  	 * than root.
  	 *
  	 * @param {Node} node
  	 * @param {Node} root
  	 * @return {Boolean}
  	 * @api private
  	 */

  	Iterator.prototype.higher = function(node) {
  	  var root = this.root;
  	  if (!root) return false;
  	  node = node.parentNode;
  	  while (node && node != root) node = node.parentNode;
  	  return node != root;
  	};

  	/**
  	 * Compile an expression
  	 *
  	 * @param {String|Function|Number} expr
  	 * @return {Function}
  	 */

  	Iterator.prototype.compile = function(expr) {
  	  switch (typeof expr) {
  	    case 'number':
  	      return function(node) { return expr == node.nodeType; };
  	    case 'string':
  	      return new Function('node', 'return ' + props(expr, 'node.'));
  	    case 'function':
  	      return expr;
  	    default:
  	      return function() { return true; };
  	  }
  	};

  	/**
  	 * Peek in either direction
  	 * `n` nodes. Peek backwards
  	 * using negative numbers.
  	 *
  	 * @param {Number} n (optional)
  	 * @return {Node|null}
  	 * @api public
  	 */

  	Iterator.prototype.peak =
  	Iterator.prototype.peek = function(expr, n) {
  	  if (arguments.length == 1) n = expr, expr = true;
  	  n = undefined == n ? 1 : n;
  	  if (!n) return this.node;
  	  else if (n > 0) return this.next(expr, n, true);
  	  else return this.prev(expr, Math.abs(n), true);
  	};

  	/**
  	 * Add a plugin
  	 *
  	 * @param {Function} fn
  	 * @return {Iterator}
  	 * @api public
  	 */

  	Iterator.prototype.use = function(fn) {
  	  fn(this);
  	  return this;
  	};


  	/***/ }),
  	/* 152 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(153),
  	  __webpack_require__(160),
  	  __webpack_require__(168),
  	  __webpack_require__(171),
  	  __webpack_require__(174),
  	  __webpack_require__(182),
  	  __webpack_require__(187),
  	  __webpack_require__(188),
  	  __webpack_require__(189),
  	  __webpack_require__(29),
  	  __webpack_require__(5),
  	  __webpack_require__(190),
  	  __webpack_require__(70)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (
  	  plugins,
  	  commands,
  	  formatters,
  	  events,
  	  patches,
  	  Api,
  	  buildTransactionManager,
  	  UndoManager,
  	  EventEmitter,
  	  nodeHelpers,
  	  Immutable,
  	  config,
  	  eventNames
  	) {

  	  function listenForUserInput() {
  	    /**
  	     * This section replaces a simple observation of the input event.
  	     * With Edge, Chrome, FF, this event triggers when either the user types
  	     * something.
  	     * With IE, the input event does not trigger on contenteditable element
  	     * that is why we have to simulate it.
  	     */

  	    var isComposing = false;
  	    var self = this;

  	    var handler = {
  	      handleEvent: function(e) {
  	        if (isComposing) return;

  	        if (e.type === 'compositionstart') {
  	           isComposing = true;
  	           return;
  	        } else if (e.type === 'compositionend') {
  	           isComposing = false;
  	           self.transactionManager.run();
  	        } else {
  	           self.transactionManager.run();
  	        }
  	      }
  	    };

  	    ['compositionstart', 'compositionend', 'keydown', 'cut', 'paste'].forEach(function(e) {
  	      this.el.addEventListener(e, handler, false);
  	    }.bind(this));
  	  }

  	  function Scribe(el, options) {
  	    EventEmitter.call(this);

  	    this.el = el;
  	    this.commands = {};

  	    this.options = config.checkOptions(options);

  	    this.commandPatches = {};
  	    this._plainTextFormatterFactory = new FormatterFactory();
  	    this._htmlFormatterFactory = new HTMLFormatterFactory();

  	    this.api = new Api(this);

  	    this.Immutable = Immutable;

  	    var TransactionManager = buildTransactionManager(this);
  	    this.transactionManager = new TransactionManager();

  	    //added for explicit checking later eg if (scribe.undoManager) { ... }
  	    this.undoManager = false;
  	    if (this.options.undo.enabled) {
  	      if (this.options.undo.manager) {
  	        this.undoManager = this.options.undo.manager;
  	      }
  	      else {
  	        this.undoManager = new UndoManager(this.options.undo.limit, this.el);
  	      }
  	      this._merge = false;
  	      this._forceMerge = false;
  	      this._mergeTimer = 0;
  	      this._lastItem = {content: ''};
  	    }

  	    this.setHTML(this.getHTML());

  	    this.el.setAttribute('contenteditable', true);

  	    listenForUserInput.call(this);

  	    /**
  	     * Core Plugins
  	     */
  	    var corePlugins = Immutable.OrderedSet(this.options.defaultPlugins)
  	      .sort(config.sortByPlugin('setRootPElement')) // Ensure `setRootPElement` is always loaded first
  	      .filter(config.filterByBlockLevelMode(this.allowsBlockElements()))
  	      .map(function (plugin) { return plugins[plugin]; });

  	    // Formatters
  	    var defaultFormatters = Immutable.List(this.options.defaultFormatters)
  	    .filter(function (formatter) { return !!formatters[formatter]; })
  	    .map(function (formatter) { return formatters[formatter]; });

  	    // Patches

  	    var defaultPatches = Immutable.List.of(
  	      patches.events
  	    );

  	    var defaultCommandPatches = Immutable.List(this.options.defaultCommandPatches).map(function(patch) { return patches.commands[patch]; });

  	    var defaultCommands = Immutable.List.of(
  	      'indent',
  	      'insertList',
  	      'outdent',
  	      'redo',
  	      'subscript',
  	      'superscript',
  	      'undo'
  	    ).map(function(command) { return commands[command]; });

  	    var allPlugins = Immutable.List().concat(
  	      corePlugins,
  	      defaultFormatters,
  	      defaultPatches,
  	      defaultCommandPatches,
  	      defaultCommands);

  	    allPlugins.forEach(function(plugin) {
  	      this.use(plugin());
  	    }.bind(this));

  	    this.use(events());
  	  }

  	  Scribe.prototype = Object.create(EventEmitter.prototype);
  	  Scribe.prototype.node = nodeHelpers;
  	  Scribe.prototype.element= Scribe.prototype.node;

  	  // For plugins
  	  // TODO: tap combinator?
  	  Scribe.prototype.use = function (configurePlugin) {
  	    configurePlugin(this);
  	    return this;
  	  };

  	  Scribe.prototype.setHTML = function (html, skipFormatters) {
  	    if (this.options.undo.enabled) {
  	      this._lastItem.content = html;
  	    }

  	    if (skipFormatters) {
  	      this._skipFormatters = true;
  	    }
  	    // IE11: Setting HTML to the value it already has causes breakages elsewhere (see #336)
  	    if (this.el.innerHTML !== html) {
  	      this.el.innerHTML = html;
  	    }
  	  };

  	  Scribe.prototype.getHTML = function () {
  	    return this.el.innerHTML;
  	  };

  	  Scribe.prototype.getContent = function () {
  	    // Remove bogus BR element for Firefox  see explanation in BR mode files.
  	    return this._htmlFormatterFactory.formatForExport(this.getHTML().replace(/<br>$/, ''));
  	  };

  	  Scribe.prototype.getTextContent = function () {
  	    return this.el.textContent;
  	  };

  	  Scribe.prototype.pushHistory = function () {
  	    /**
  	     * Chrome and Firefox: If we did push to the history, this would break
  	     * browser magic around `Document.queryCommandState` (http://jsbin.com/eDOxacI/1/edit?js,console,output).
  	     * This happens when doing any DOM manipulation.
  	     */
  	    var scribe = this;

  	    if (scribe.options.undo.enabled) {
  	      // Get scribe previous content, and strip markers.
  	      var lastContentNoMarkers = scribe._lastItem.content.replace(/<em [^>]*class="scribe-marker"[^>]*>[^<]*?<\/em>/g, '');

  	      // We only want to push the history if the content actually changed.
  	      if (scribe.getHTML() !== lastContentNoMarkers) {
  	        var selection = new scribe.api.Selection();

  	        selection.placeMarkers();
  	        var content = scribe.getHTML();
  	        selection.removeMarkers();

  	        // Checking if there is a need to merge, and that the previous history item
  	        // is the last history item of the same scribe instance.
  	        // It is possible the last transaction is not for the same instance, or
  	        // even not a scribe transaction (e.g. when using a shared undo manager).
  	        var previousItem = scribe.undoManager.item(scribe.undoManager.position);
  	        if ((scribe._merge || scribe._forceMerge) && previousItem && scribe._lastItem == previousItem[0]) {
  	          // If so, merge manually with the last item to save more memory space.
  	          scribe._lastItem.content = content;
  	        }
  	        else {
  	          // Otherwise, create a new history item, and register it as a new transaction
  	          scribe._lastItem = {
  	            previousItem: scribe._lastItem,
  	            content: content,
  	            scribe: scribe,
  	            execute: function () { },
  	            undo: function () { this.scribe.restoreFromHistory(this.previousItem); },
  	            redo: function () { this.scribe.restoreFromHistory(this); }
  	          };

  	          scribe.undoManager.transact(scribe._lastItem, false);
  	        }

  	        // Merge next transaction if it happens before the interval option, otherwise don't merge.
  	        clearTimeout(scribe._mergeTimer);
  	        scribe._merge = true;
  	        scribe._mergeTimer = setTimeout(function() { scribe._merge = false; }, scribe.options.undo.interval);

  	        return true;
  	      }
  	    }

  	    return false;
  	  };

  	  Scribe.prototype.getCommand = function (commandName) {
  	    return this.commands[commandName] || this.commandPatches[commandName] || new this.api.Command(commandName);
  	  };

  	  Scribe.prototype.restoreFromHistory = function (historyItem) {
  	    this._lastItem = historyItem;

  	    this.setHTML(historyItem.content, true);

  	    // Restore the selection
  	    var selection = new this.api.Selection();
  	    selection.selectMarkers();

  	    // Because we skip the formatters, a transaction is not run, so we have to
  	    // emit this event ourselves.
  	    this.trigger(eventNames.legacyContentChanged);
  	    this.trigger(eventNames.contentChanged);
  	  };

  	  // This will most likely be moved to another object eventually
  	  Scribe.prototype.allowsBlockElements = function () {
  	    return this.options.allowBlockElements;
  	  };

  	  Scribe.prototype.setContent = function (content) {
  	    if (! this.allowsBlockElements()) {
  	      // Set bogus BR element for Firefox  see explanation in BR mode files.
  	      content = content + '<br>';
  	    }

  	    this.setHTML(content);

  	    this.trigger(eventNames.legacyContentChanged);
  	    this.trigger(eventNames.contentChanged);
  	  };

  	  Scribe.prototype.insertPlainText = function (plainText) {
  	    this.insertHTML('<p>' + this._plainTextFormatterFactory.format(plainText) + '</p>');
  	  };

  	  Scribe.prototype.insertHTML = function (html) {
  	    /**
  	     * When pasting text from Google Docs in both Chrome and Firefox,
  	     * the resulting text will be wrapped in a B tag. So it would look
  	     * something like <b><p>Text</p></b>, which is invalid HTML. The command
  	     * insertHTML will then attempt to fix this content by moving the B tag
  	     * inside the P. The result is: <p><b></b></p><p>Text</p>, which is valid
  	     * but means an extra P is inserted into the text. To avoid this we run the
  	     * formatters before the insertHTML command as the formatter will
  	     * unwrap the P and delete the B tag. It is acceptable to remove invalid
  	     * HTML as Scribe should only accept valid HTML.
  	     *
  	     * See http://jsbin.com/cayosada/3/edit for more
  	     **/

  	    html = this._htmlFormatterFactory.format(html);

  	    // is IE11
  	    if(Object.hasOwnProperty.call(window, "ActiveXObject") && !window.ActiveXObject) {

  	      var htmlContent = document.createElement("span");
  	      htmlContent.innerHTML = html;
  	      if (htmlContent.children.length === 1 && htmlContent.children[0].tagName === 'P') {
  	        html = htmlContent.children[0].innerHTML;
  	      }

  	      if (this.getTextContent().trim() === '') {

  	        this.setContent(html);

  	      } else {

  	        var r = document.getSelection().getRangeAt(0);
  	        var n = document.createElement("span");
  	        
  	        r.surroundContents(n);
  	        n.innerHTML = html;
  	        r.collapse(false);

  	        nodeHelpers.removeChromeArtifacts(this.el);
  	      }

  	    } else {

  	      // TODO: error if the selection is not within the Scribe instance? Or
  	      // focus the Scribe instance if it is not already focused?
  	      this.getCommand('insertHTML').execute(html);
  	    }
  	  };

  	  Scribe.prototype.isDebugModeEnabled = function () {
  	    return this.options.debug;
  	  };

  	  /**
  	   * Applies HTML formatting to all editor text.
  	   * @param {String} phase sanitize/normalize/export are the standard phases
  	   * @param {Function} fn Function that takes the current editor HTML and returns a formatted version.
  	   */
  	  Scribe.prototype.registerHTMLFormatter = function (phase, formatter) {
  	    this._htmlFormatterFactory.formatters[phase]
  	      = this._htmlFormatterFactory.formatters[phase].push(formatter);
  	  };

  	  Scribe.prototype.registerPlainTextFormatter = function (formatter) {
  	    this._plainTextFormatterFactory.formatters
  	      = this._plainTextFormatterFactory.formatters.push(formatter);
  	  };

  	  Scribe.prototype.destroy = function (options) {
  	        this.trigger(eventNames.destroy);
  	  };

  	  // TODO: abstract
  	  function FormatterFactory() {
  	    this.formatters = Immutable.List();
  	  }

  	  FormatterFactory.prototype.format = function (html) {
  	    // Map the object to an array: Array[Formatter]
  	    var formatted = this.formatters.reduce(function (formattedData, formatter) {
  	      return formatter(formattedData);
  	    }, html);

  	    return formatted;
  	  };

  	  function HTMLFormatterFactory() {
  	    // Define phases
  	    // For a list of formatters, see https://github.com/guardian/scribe/issues/126
  	    this.formatters = {
  	      // Configurable sanitization of the HTML, e.g. converting/filter/removing
  	      // elements
  	      sanitize: Immutable.List(),
  	      // Normalize content to ensure it is ready for interaction
  	      normalize: Immutable.List(),
  	      'export': Immutable.List()
  	    };
  	  }

  	  HTMLFormatterFactory.prototype = Object.create(FormatterFactory.prototype);
  	  HTMLFormatterFactory.prototype.constructor = HTMLFormatterFactory;

  	  HTMLFormatterFactory.prototype.format = function (html) {
  	    var formatters = this.formatters.sanitize.concat(this.formatters.normalize);

  	    var formatted = formatters.reduce(function (formattedData, formatter) {
  	      return formatter(formattedData);
  	    }, html);

  	    return formatted;
  	  };

  	  HTMLFormatterFactory.prototype.formatForExport = function (html) {
  	    return this.formatters['export'].reduce(function (formattedData, formatter) {
  	      return formatter(formattedData);
  	    }, html);
  	  };

  	  return Scribe;

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 153 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(154),
  	  __webpack_require__(155),
  	  __webpack_require__(156),
  	  __webpack_require__(159)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (
  	  setRootPElement,
  	  enforcePElements,
  	  ensureSelectableContainers,
  	  inlineElementsMode
  	) {

  	  return {
  	    setRootPElement: setRootPElement,
  	    enforcePElements: enforcePElements,
  	    ensureSelectableContainers: ensureSelectableContainers,
  	    inlineElementsMode: inlineElementsMode
  	  };
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 154 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function () {
  	    return function (scribe) {
  	      // The content might have already been set, in which case we don't want
  	      // to apply.
  	      if (scribe.getHTML().trim() === '') {
  	        /**
  	         * We have to begin with the following HTML, because otherwise some
  	         * browsers(?) will position the caret outside of the P when the scribe is
  	         * focused.
  	         */

  	        // Force IE10 to not include br otherwise a linebreak is always included
  	        // in the textarea.
  	        if(window.navigator.userAgent.match(/MSIE 10/)) {
  	          scribe.setContent('<p></p>');
  	        } else {
  	          scribe.setContent('<p><br></p>');
  	        }
  	      }
  	    };
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 155 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(5)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Immutable) {

  	  return function () {
  	    return function (scribe) {
  	      var nodeHelpers = scribe.node;

  	      /**
  	       * Wrap consecutive inline elements and text nodes in a P element.
  	       */
  	      function wrapChildNodes(parentNode) {
  	        var index = 0;

  	        Immutable.List(parentNode.childNodes)
  	          .filterNot(function(node) {
  	            return nodeHelpers.isWhitespaceOnlyTextNode(Node, node);
  	          })
  	          .filter(function(node) {
  	            return node.nodeType === Node.TEXT_NODE || !nodeHelpers.isBlockElement(node);
  	          })
  	          .groupBy(function(node, key, list) {
  	            return key === 0 || node.previousSibling === list.get(key - 1) ?
  	              index :
  	              index += 1;
  	          })
  	          .forEach(function(nodeGroup) {
  	            nodeHelpers.wrap(nodeGroup.toArray(), document.createElement('p'));
  	          });
  	      }

  	      // Traverse the tree, wrapping child nodes as we go.
  	      function traverse(parentNode) {
  	        var i = 0, node;

  	        while (node = parentNode.children[i++]) {
  	          if (node.tagName === 'BLOCKQUOTE') {
  	            wrapChildNodes(node);
  	          }
  	        }
  	      }

  	      scribe.registerHTMLFormatter('normalize', function (html) {
  	        /**
  	         * Ensure P mode.
  	         *
  	         * Wrap any orphan text nodes in a P element.
  	         */
  	        // TODO: This should be configurable and also correct markup such as
  	        // `<ul>1</ul>` to <ul><li>2</li></ul>`. See skipped tests.
  	        // TODO: This should probably be a part of HTML Janitor, or some other
  	        // formatter.
  	        var bin = document.createElement('div');
  	        bin.innerHTML = html;

  	        wrapChildNodes(bin);
  	        traverse(bin);

  	        return bin.innerHTML;
  	      });

  	    };
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 156 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	    __webpack_require__(29),
  	    __webpack_require__(5)
  	  ], __WEBPACK_AMD_DEFINE_RESULT__ = (function (
  	    nodeHelpers,
  	    Immutable
  	  ) {

  	  // http://www.w3.org/TR/html-markup/syntax.html#syntax-elements
  	  var html5VoidElements = Immutable.Set.of('AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT', 'KEYGEN', 'LINK', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR');

  	  function parentHasNoTextContent(node) {
  	    if (nodeHelpers.isCaretPositionNode(node)) {
  	      return true;
  	    } else {
  	      return node.parentNode.textContent.trim() === '';
  	    }
  	  }


  	  function traverse(parentNode) {
  	    // Instead of TreeWalker, which gets confused when the BR is added to the dom,
  	    // we recursively traverse the tree to look for an empty node that can have childNodes

  	    var node = parentNode.firstElementChild;

  	    function isEmpty(node) {

  	      if ((node.children.length === 0 && nodeHelpers.isBlockElement(node))
  	        || (node.children.length === 1 && nodeHelpers.isSelectionMarkerNode(node.children[0]))) {
  	         return true;
  	      }

  	      // Do not insert BR in empty non block elements with parent containing text
  	      if (!nodeHelpers.isBlockElement(node) && node.children.length === 0) {
  	        return parentHasNoTextContent(node);
  	      }

  	      return false;
  	    }

  	    while (node) {
  	      if (!nodeHelpers.isSelectionMarkerNode(node)) {
  	        // Find any node that contains no child *elements*, or just contains
  	        // whitespace, is not self-closing and is not a custom element
  	        if (isEmpty(node) &&
  	          node.textContent.trim() === '' &&
  	          !html5VoidElements.includes(node.nodeName) &&
  	          node.nodeName.indexOf('-') === -1) {
  	          node.appendChild(document.createElement('br'));
  	        } else if (node.children.length > 0) {
  	          traverse(node);
  	        }
  	      }
  	      node = node.nextElementSibling;
  	    }
  	  }

  	  return function () {
  	    return function (scribe) {

  	      scribe.registerHTMLFormatter('normalize', function (html) {
  	        var bin = document.createElement('div');
  	        bin.innerHTML = html;

  	        traverse(bin);

  	        return bin.innerHTML;
  	      });

  	    };
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 157 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(5)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Immutable) {
  	  // Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elemente
  	  var inlineElementNames = Immutable.Set.of('B', 'BIG', 'I', 'SMALL', 'TT',
  	    'ABBR', 'ACRONYM', 'CITE', 'CODE', 'DFN', 'EM', 'KBD', 'STRONG', 'SAMP', 'VAR',
  	    'A', 'BDO', 'BR', 'IMG', 'MAP', 'OBJECT', 'Q', 'SCRIPT', 'SPAN', 'SUB', 'SUP',
  	    'BUTTON', 'INPUT', 'LABEL', 'SELECT', 'TEXTAREA');

  	  return inlineElementNames;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 158 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(5)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Immutable) {
  	  var blockElementNames = Immutable.Set.of('ADDRESS', 'ARTICLE', 'ASIDE', 'AUDIO', 'BLOCKQUOTE', 'CANVAS', 'DD',
  	                           'DIV', 'FIELDSET', 'FIGCAPTION', 'FIGURE', 'FOOTER', 'FORM', 'H1',
  	                           'H2', 'H3', 'H4', 'H5', 'H6', 'HEADER', 'HGROUP', 'HR', 'LI',
  	                           'NOSCRIPT', 'OL', 'OUTPUT', 'P', 'PRE', 'SECTION', 'TABLE', 'TD',
  	                           'TH', 'TFOOT', 'UL', 'VIDEO');

  	  return blockElementNames;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 159 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(29)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (nodeHelpers) {

  	  // TODO: abstract
  	  function hasContent(rootNode) {
  	    var treeWalker = document.createTreeWalker(rootNode, NodeFilter.SHOW_ALL, null, false);

  	    while (treeWalker.nextNode()) {
  	      if (treeWalker.currentNode) {

  	        // If the node is a non-empty element or has content
  	        if(nodeHelpers.hasContent(treeWalker.currentNode) || nodeHelpers.isTextNodeWithContent(Node, treeWalker.currentNode)) {
  	          return true;
  	        }
  	      }
  	    }

  	    return false;
  	  }

  	  return function () {
  	    return function (scribe) {
  	      /**
  	       * Firefox has a `insertBrOnReturn` command, but this is not a part of
  	       * any standard. One day we might have an `insertLineBreak` command,
  	       * proposed by this spec:
  	       * https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#the-insertlinebreak-command
  	       * As per: http://jsbin.com/IQUraXA/1/edit?html,js,output
  	       */
  	      scribe.el.addEventListener('keydown', function (event) {
  	        if (event.keyCode === 13) { // enter
  	          var selection = new scribe.api.Selection();
  	          var range = selection.range;

  	          var blockNode = selection.getContaining(function (node) {
  	            return node.nodeName === 'LI' || (/^(H[1-6])$/).test(node.nodeName);
  	          });

  	          if (! blockNode) {
  	            event.preventDefault();

  	            scribe.transactionManager.run(function () {
  	              
  	              if (!range.collapsed) {
  	                range.deleteContents();
  	              }


  	              /**
  	               * Firefox: Delete the bogus BR as we insert another one later.
  	               * We have to do this because otherwise the browser will believe
  	               * there is content to the right of the selection.
  	               */
  	              if (scribe.el.lastChild && scribe.el.lastChild.nodeName === 'BR') {
  	                scribe.el.removeChild(scribe.el.lastChild);
  	              }

  	              var brNode = document.createElement('br');

  	              range.insertNode(brNode);

  	              // Safari does not update the endoffset after inserting the BR element
  	              // so we have to do it ourselves.
  	              // References: 
  	              // https://bugs.webkit.org/show_bug.cgi?id=63538#c3
  	              // https://dom.spec.whatwg.org/#dom-range-selectnode
  	              range.setEndAfter(brNode);
  	              
  	              // After inserting the BR into the range is no longer collapsed, so
  	              // we have to collapse it again.
  	              // TODO: Older versions of Firefox require this argument even though
  	              // it is supposed to be optional. Proxy/polyfill?
  	              range.collapse(false);

  	              /**
  	               * Chrome: If there is no right-hand side content, inserting a BR
  	               * will not appear to create a line break.
  	               * Firefox: If there is no right-hand side content, inserting a BR
  	               * will appear to create a weird "half-line break".
  	               *
  	               * Possible solution: Insert two BRs.
  	               *  Chrome: Inserting two BRs appears to create a line break.
  	               * Typing will then delete the bogus BR element.
  	               * Firefox: Inserting two BRs will create two line breaks.
  	               *
  	               * Solution: Only insert two BRs if there is no right-hand
  	               * side content.
  	               *
  	               * If the user types on a line immediately after a BR element,
  	               * Chrome will replace the BR element with the typed characters,
  	               * whereas Firefox will not. Thus, to satisfy Firefox we have to
  	               * insert a bogus BR element on initialization (see below).
  	               */

  	              var contentToEndRange = range.cloneRange();
  	              if (scribe.el.lastChild) {
  	                contentToEndRange.setEndAfter(scribe.el.lastChild);
  	              }

  	              // Get the content from the range to the end of the heading
  	              var contentToEndFragment = contentToEndRange.cloneContents();

  	              // If there is not already a right hand side content we need to
  	              // insert a bogus BR element.
  	              if (! hasContent(contentToEndFragment)) {
  	                var bogusBrNode = document.createElement('br');
  	                range.insertNode(bogusBrNode);
  	              }

  	              var newRange = range.cloneRange();

  	              newRange.setStartAfter(brNode);
  	              newRange.setEndAfter(brNode);

  	              selection.selection.removeAllRanges();
  	              selection.selection.addRange(newRange);
  	            });
  	          }
  	        }
  	      }.bind(this));

  	      if (scribe.getHTML().trim() === '') {
  	        // Bogus BR element for Firefox  see explanation above.
  	        // TODO: also append when consumer sets the content manually.
  	        // TODO: hide when the user calls `getHTML`?
  	        scribe.setContent('');
  	      }
  	    };
  	  };
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 160 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(161),
  	  __webpack_require__(162),
  	  __webpack_require__(163),
  	  __webpack_require__(164),
  	  __webpack_require__(165),
  	  __webpack_require__(166),
  	  __webpack_require__(167)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (
  	  indent,
  	  insertList,
  	  outdent,
  	  redo,
  	  subscript,
  	  superscript,
  	  undo
  	) {

  	  return {
  	    indent: indent,
  	    insertList: insertList,
  	    outdent: outdent,
  	    redo: redo,
  	    subscript: subscript,
  	    superscript: superscript,
  	    undo: undo
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 161 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function () {
  	    return function (scribe) {
  	      var indentCommand = new scribe.api.Command('indent');

  	      indentCommand.queryEnabled = function () {
  	        /**
  	         * FIXME: Chrome nests ULs inside of ULs
  	         * Currently we just disable the command when the selection is inside of
  	         * a list.
  	         * As per: http://jsbin.com/ORikUPa/3/edit?html,js,output
  	         */
  	        var selection = new scribe.api.Selection();
  	        var listElement = selection.getContaining(function (element) {
  	          return element.nodeName === 'UL' || element.nodeName === 'OL';
  	        });

  	        return scribe.api.Command.prototype.queryEnabled.call(this) && scribe.allowsBlockElements() && ! listElement;
  	      };

  	      scribe.commands.indent = indentCommand;
  	    };
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 162 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(5)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Immutable) {

  	  return function () {
  	    return function (scribe) {
  	      var nodeHelpers = scribe.node;

  	      var InsertListCommand = function (commandName) {
  	        scribe.api.Command.call(this, commandName);
  	      };

  	      InsertListCommand.prototype = Object.create(scribe.api.Command.prototype);
  	      InsertListCommand.prototype.constructor = InsertListCommand;

  	      InsertListCommand.prototype.execute = function (value) {
  	        function splitList(listItemElements) {
  	          if (!!listItemElements.size) {
  	            var newListNode = document.createElement(listNode.nodeName);

  	            while (!!listItemElements.size) {
  	              newListNode.appendChild(listItemElements.first());
  	              listItemElements = listItemElements.shift();
  	            }

  	            listNode.parentNode.insertBefore(newListNode, listNode.nextElementSibling);
  	          }
  	        }

  	        if (this.queryState()) {
  	          var selection = new scribe.api.Selection();
  	          var range = selection.range;

  	          var listNode = selection.getContaining(function (node) {
  	            return node.nodeName === 'OL' || node.nodeName === 'UL';
  	          });

  	          var listItemElement = selection.getContaining(function (node) {
  	            return node.nodeName === 'LI';
  	          });

  	          scribe.transactionManager.run(function () {
  	            if (listItemElement) {
  	              var nextListItemElements = nodeHelpers.nextSiblings(listItemElement);

  	              /**
  	               * If we are not at the start or end of a UL/OL, we have to
  	               * split the node and insert the P(s) in the middle.
  	               */
  	              splitList(nextListItemElements);

  	              /**
  	               * Insert a paragraph in place of the list item.
  	               */

  	              selection.placeMarkers();

  	              var pNode = document.createElement('p');
  	              pNode.innerHTML = listItemElement.innerHTML;

  	              listNode.parentNode.insertBefore(pNode, listNode.nextElementSibling);
  	              listItemElement.parentNode.removeChild(listItemElement);
  	            } else {
  	              /**
  	               * When multiple list items are selected, we replace each list
  	               * item with a paragraph.
  	               */

  	              // We can't query for list items in the selection so we loop
  	              // through them all and find the intersection ourselves.
  	              var selectedListItemElements = Immutable.List(listNode.querySelectorAll('li'))
  	                .filter(function (listItemElement) {
  	                  return range.intersectsNode(listItemElement);
  	                });
  	              var lastSelectedListItemElement = selectedListItemElements.last();
  	              var listItemElementsAfterSelection = nodeHelpers.nextSiblings(lastSelectedListItemElement);

  	              /**
  	               * If we are not at the start or end of a UL/OL, we have to
  	               * split the node and insert the P(s) in the middle.
  	               */
  	              splitList(listItemElementsAfterSelection);

  	              // Store the caret/range positioning inside of the list items so
  	              // we can restore it from the newly created P elements soon
  	              // afterwards.
  	              selection.placeMarkers();

  	              var documentFragment = document.createDocumentFragment();
  	              selectedListItemElements.forEach(function (listItemElement) {
  	                var pElement = document.createElement('p');
  	                pElement.innerHTML = listItemElement.innerHTML;
  	                documentFragment.appendChild(pElement);
  	              });

  	              // Insert the Ps
  	              listNode.parentNode.insertBefore(documentFragment, listNode.nextElementSibling);

  	              // Remove the LIs
  	              selectedListItemElements.forEach(function (listItemElement) {
  	                listItemElement.parentNode.removeChild(listItemElement);
  	              });
  	            }

  	            // If the list is now empty, clean it up.
  	            if (listNode.childNodes.length === 0) {
  	              listNode.parentNode.removeChild(listNode);
  	            }

  	            selection.selectMarkers();
  	          }.bind(this));
  	        } else {
  	          scribe.api.Command.prototype.execute.call(this, value);
  	        }
  	      };

  	      InsertListCommand.prototype.queryEnabled = function () {
  	        return scribe.api.Command.prototype.queryEnabled.call(this) && scribe.allowsBlockElements();
  	      };

  	      scribe.commands.insertOrderedList = new InsertListCommand('insertOrderedList');
  	      scribe.commands.insertUnorderedList = new InsertListCommand('insertUnorderedList');
  	    };
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 163 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function () {
  	    return function (scribe) {
  	      var outdentCommand = new scribe.api.Command('outdent');

  	      outdentCommand.queryEnabled = function () {
  	        /**
  	         * FIXME: If the paragraphs option is set to true, then when the
  	         * list is unapplied, ensure that we enter a P element.
  	         * Currently we just disable the command when the selection is inside of
  	         * a list.
  	         */
  	        var selection = new scribe.api.Selection();
  	        var listElement = selection.getContaining(function (element) {
  	          return element.nodeName === 'UL' || element.nodeName === 'OL';
  	        });

  	        // FIXME: define block element rule here?
  	        return scribe.api.Command.prototype.queryEnabled.call(this) && scribe.allowsBlockElements() && ! listElement;
  	      };

  	      scribe.commands.outdent = outdentCommand;
  	    };
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 164 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(69)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (keystrokes) {

  	  return function () {
  	    return function (scribe) {
  	      var redoCommand = new scribe.api.Command('redo');

  	      redoCommand.execute = function () {
  	        scribe.undoManager.redo();
  	      };

  	      redoCommand.queryEnabled = function () {
  	        return scribe.undoManager.position > 0;
  	      };

  	      scribe.commands.redo = redoCommand;

  	      //is scribe is configured to undo assign listener
  	      if (scribe.options.undo.enabled) {
  	        scribe.el.addEventListener('keydown', function (event) {
  	          if (keystrokes.isRedoKeyCombination(event)) {
  	            event.preventDefault();
  	            redoCommand.execute();
  	          }
  	        });
  	      }
  	    };
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 165 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function () {
  	    return function (scribe) {
  	      var subscriptCommand = new scribe.api.Command('subscript');

  	      scribe.commands.subscript = subscriptCommand;
  	    };
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 166 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function () {
  	    return function (scribe) {
  	      var superscriptCommand = new scribe.api.Command('superscript');

  	      scribe.commands.superscript = superscriptCommand;
  	    };
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 167 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(69)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (keystrokes) {

  	  return function () {
  	    return function (scribe) {
  	      var undoCommand = new scribe.api.Command('undo');

  	      undoCommand.execute = function () {
  	        scribe.undoManager.undo();
  	      };

  	      undoCommand.queryEnabled = function () {
  	        return scribe.undoManager.position < scribe.undoManager.length;
  	      };

  	      scribe.commands.undo = undoCommand;

  	      if (scribe.options.undo.enabled) {
  	        scribe.el.addEventListener('keydown', function (event) {
  	          if (keystrokes.isUndoKeyCombination(event)) {
  	            event.preventDefault();
  	            undoCommand.execute();
  	          }
  	        });
  	      }
  	    };
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 168 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(169),
  	  __webpack_require__(170)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (
  	  replaceNbspCharsFormatter,
  	  escapeHtmlCharactersFormatter
  	) {

  	  return {
  	    replaceNbspCharsFormatter: replaceNbspCharsFormatter,
  	    escapeHtmlCharactersFormatter: escapeHtmlCharactersFormatter
  	  };
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 169 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function () {
  	    return function (scribe) {
  	      var nbspCharRegExp = /(\s|&nbsp;)+/g;

  	      // TODO: should we be doing this on paste?
  	      scribe.registerHTMLFormatter('export', function (html) {
  	        return html.replace(nbspCharRegExp, ' ');
  	      });
  	    };
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 170 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_1__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_2__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_0__ = ((function() {

  	  /**
  	   * Converts `value` to a string if it is not one. An empty string is returned
  	   * for `null` or `undefined` values.
  	   *
  	   * @private
  	   * @param {*} value The value to process.
  	   * @returns {string} Returns the string.
  	   */
  	  function baseToString(value) {
  	    if (typeof value == 'string') {
  	      return value;
  	    }
  	    return value == null ? '' : (value + '');
  	  }

  	  return baseToString;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));

  	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_1__ = ((function() {

  	  /** Used to map characters to HTML entities. */
  	  var htmlEscapes = {
  	    '&': '&amp;',
  	    '<': '&lt;',
  	    '>': '&gt;',
  	    '"': '&quot;',
  	    "'": '&#39;',
  	    '`': '&#96;'
  	  };

  	  /**
  	   * Used by `_.escape` to convert characters to HTML entities.
  	   *
  	   * @private
  	   * @param {string} chr The matched character to escape.
  	   * @returns {string} Returns the escaped character.
  	   */
  	  function escapeHtmlChar(chr) {
  	    return htmlEscapes[chr];
  	  }

  	  return escapeHtmlChar;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));

  	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_0__, __WEBPACK_LOCAL_MODULE_1__], __WEBPACK_LOCAL_MODULE_2__ = ((function(baseToString, escapeHtmlChar) {

  	  /** Used to match HTML entities and HTML characters. */
  	  var reUnescapedHtml = /[&<>"'`]/g,
  	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  	  /**
  	   * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
  	   * their corresponding HTML entities.
  	   *
  	   * **Note:** No other characters are escaped. To escape additional characters
  	   * use a third-party library like [_he_](https://mths.be/he).
  	   *
  	   * Though the ">" character is escaped for symmetry, characters like
  	   * ">" and "/" don't require escaping in HTML and have no special meaning
  	   * unless they're part of a tag or unquoted attribute value.
  	   * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
  	   * (under "semi-related fun fact") for more details.
  	   *
  	   * Backticks are escaped because in Internet Explorer < 9, they can break out
  	   * of attribute values or HTML comments. See [#102](https://html5sec.org/#102),
  	   * [#108](https://html5sec.org/#108), and [#133](https://html5sec.org/#133) of
  	   * the [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
  	   *
  	   * When working with HTML you should always quote attribute values to reduce
  	   * XSS vectors. See [Ryan Grove's article](http://wonko.com/post/html-escaping)
  	   * for more details.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category String
  	   * @param {string} [string=''] The string to escape.
  	   * @returns {string} Returns the escaped string.
  	   * @example
  	   *
  	   * _.escape('fred, barney, & pebbles');
  	   * // => 'fred, barney, &amp; pebbles'
  	   */
  	  function escape(string) {
  	    // Reset `lastIndex` because in IE < 9 `String#replace` does not.
  	    string = baseToString(string);
  	    return (string && reHasUnescapedHtml.test(string))
  	      ? string.replace(reUnescapedHtml, escapeHtmlChar)
  	      : string;
  	  }

  	  return escape;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));


  	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __WEBPACK_LOCAL_MODULE_2__
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (
  	  escape
  	) {

  	  return function () {
  	    return function (scribe) {
  	      scribe.registerPlainTextFormatter(escape);
  	    };
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 171 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(172),
  	  __webpack_require__(5)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (
  	  observeDomChanges,
  	  Immutable
  	) {

  	  return function () {
  	    return function (scribe) {
  	      var nodeHelpers = scribe.node;

  	      /**
  	       * Firefox: Giving focus to a `contenteditable` will place the caret
  	       * outside of any block elements. Chrome behaves correctly by placing the
  	       * caret at the  earliest point possible inside the first block element.
  	       * As per: http://jsbin.com/eLoFOku/1/edit?js,console,output
  	       *
  	       * We detect when this occurs and fix it by placing the caret ourselves.
  	       */
  	      scribe.el.addEventListener('focus', function placeCaretOnFocus() {
  	        var selection = new scribe.api.Selection();
  	        // In Chrome, the range is not created on or before this event loop.
  	        // It doesnt matter because this is a fix for Firefox.
  	        if (selection.range) {

  	          var isFirefoxBug = scribe.allowsBlockElements() &&
  	                  selection.range.startContainer === scribe.el;

  	          if (isFirefoxBug) {
  	            var focusElement = nodeHelpers.firstDeepestChild(scribe.el);

  	            var range = selection.range;

  	            range.setStart(focusElement, 0);
  	            range.setEnd(focusElement, 0);

  	            selection.selection.removeAllRanges();
  	            selection.selection.addRange(range);
  	          }
  	        }
  	      }.bind(scribe));

  	      /**
  	       * Apply the formatters when there is a DOM mutation.
  	       */
  	      var applyFormatters = function() {
  	        if (!scribe._skipFormatters) {
  	          var selection = new scribe.api.Selection();
  	          var isEditorActive = selection.range;

  	          var runFormatters = function () {
  	            if (isEditorActive) {
  	              selection.placeMarkers();
  	            }
  	            scribe.setHTML(scribe._htmlFormatterFactory.format(scribe.getHTML()));
  	            selection.selectMarkers();
  	          }.bind(scribe);

  	          // We only want to wrap the formatting in a transaction if the editor is
  	          // active. If the DOM is mutated when the editor isn't active (e.g.
  	          // `scribe.setContent`), we do not want to push to the history. (This
  	          // happens on the first `focus` event).

  	          // The previous check is no longer needed, and the above comments are no longer valid.
  	          // Now `scribe.setContent` updates the content manually, and `scribe.pushHistory`
  	          // will not detect any changes, and nothing will be push into the history.
  	          // Any mutations made without `scribe.getContent` will be pushed into the history normally.

  	          // Pass content through formatters, place caret back
  	          scribe.transactionManager.run(runFormatters);
  	        }

  	        delete scribe._skipFormatters;
  	      }.bind(scribe);

  	      observeDomChanges(scribe.el, applyFormatters);

  	      // TODO: disconnect on tear down:
  	      // observer.disconnect();

  	      /**
  	       * If the paragraphs option is set to true, we need to manually handle
  	       * keyboard navigation inside a heading to ensure a P element is created.
  	       */
  	      if (scribe.allowsBlockElements()) {
  	        scribe.el.addEventListener('keydown', function (event) {
  	          if (event.keyCode === 13) { // enter

  	            var selection = new scribe.api.Selection();
  	            var range = selection.range;

  	            var headingNode = selection.getContaining(function (node) {
  	              return (/^(H[1-6])$/).test(node.nodeName);
  	            });

  	            /**
  	             * If we are at the end of the heading, insert a P. Otherwise handle
  	             * natively.
  	             */
  	            if (headingNode && range.collapsed) {
  	              var contentToEndRange = range.cloneRange();
  	              contentToEndRange.setEndAfter(headingNode);

  	              // Get the content from the range to the end of the heading
  	              var contentToEndFragment = contentToEndRange.cloneContents();

  	              if (contentToEndFragment.firstChild.textContent === '') {
  	                event.preventDefault();

  	                scribe.transactionManager.run(function () {
  	                  // Default P
  	                  // TODO: Abstract somewhere
  	                  var pNode = document.createElement('p');
  	                  var brNode = document.createElement('br');
  	                  pNode.appendChild(brNode);

  	                  headingNode.parentNode.insertBefore(pNode, headingNode.nextElementSibling);

  	                  // Re-apply range
  	                  range.setStart(pNode, 0);
  	                  range.setEnd(pNode, 0);

  	                  selection.selection.removeAllRanges();
  	                  selection.selection.addRange(range);
  	                });
  	              }
  	            }
  	          }
  	        });
  	      }

  	      /**
  	       * If the paragraphs option is set to true, we need to manually handle
  	       * keyboard navigation inside list item nodes.
  	       */
  	      if (scribe.allowsBlockElements()) {
  	        scribe.el.addEventListener('keydown', function (event) {
  	          if (event.keyCode === 13 || event.keyCode === 8) { // enter || backspace

  	            var selection = new scribe.api.Selection();
  	            var range = selection.range;

  	            if (range.collapsed) {
  	              var containerLIElement = selection.getContaining(function (node) {
  	                return node.nodeName === 'LI';
  	              });
  	              if (containerLIElement && containerLIElement.textContent.trim() === '') {
  	                /**
  	                 * LIs
  	                 */

  	                event.preventDefault();

  	                var listNode = selection.getContaining(function (node) {
  	                  return node.nodeName === 'UL' || node.nodeName === 'OL';
  	                });

  	                var command = scribe.getCommand(listNode.nodeName === 'OL' ? 'insertOrderedList' : 'insertUnorderedList');

  	                command.event = event;

  	                command.execute();
  	              }
  	            }
  	          }
  	        });
  	      }

  	      /**
  	       * We have to hijack the paste event to ensure it uses
  	       * `scribe.insertHTML`, which executes the Scribe version of the command
  	       * and also runs the formatters.
  	       */

  	      /**
  	       * TODO: could we implement this as a polyfill for `event.clipboardData` instead?
  	       * I also don't like how it has the authority to perform `event.preventDefault`.
  	       */

  	      scribe.el.addEventListener('paste', function handlePaste(event) {
  	        /**
  	         * Browsers without the Clipboard API (specifically `ClipboardEvent.clipboardData`)
  	         * will execute the second branch here.
  	         *
  	         * Chrome on android provides `ClipboardEvent.clipboardData` but the types array is not filled
  	         */
  	        if (event.clipboardData && event.clipboardData.types.length > 0) {
  	          event.preventDefault();

  	          if (Immutable.List(event.clipboardData.types).includes('text/html')) {
  	            scribe.insertHTML(event.clipboardData.getData('text/html'));
  	          } else {
  	            scribe.insertPlainText(event.clipboardData.getData('text/plain'));
  	          }
  	        } else {
  	          /**
  	           * If the browser doesn't have `ClipboardEvent.clipboardData`, we run through a
  	           * sequence of events:
  	           *
  	           *   - Save the text selection
  	           *   - Focus another, hidden textarea so we paste there
  	           *   - Copy the pasted content of said textarea
  	           *   - Give focus back to the scribe
  	           *   - Restore the text selection
  	           *
  	           * This is required because, without access to the Clipboard API, there is literally
  	           * no other way to manipulate content on paste.
  	           * As per: https://github.com/jejacks0n/mercury/issues/23#issuecomment-2308347
  	           *
  	           * Firefox <= 21
  	           * https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent.clipboardData
  	           */

  	          var selection = new scribe.api.Selection();

  	          // Store the caret position
  	          selection.placeMarkers();

  	          var bin = document.createElement('div');
  	          bin.style.height = 0;
  	          bin.style.opacity = 0;
  	          bin.style.overflow = 'hidden';
  	          document.body.appendChild(bin);
  	          bin.setAttribute('contenteditable', true);
  	          bin.focus();

  	          // Wait for the paste to happen (next loop?)
  	          setTimeout(function () {
  	            var data = bin.innerHTML;
  	            bin.parentNode.removeChild(bin);

  	            // Restore the caret position
  	            selection.selectMarkers();
  	            /**
  	             * Firefox 19 (and maybe others): even though the applied range
  	             * exists within the Scribe instance, we need to focus it.
  	             */
  	            scribe.el.focus();

  	            scribe.insertHTML(data);
  	          }, 1);
  	        }
  	      });

  	    };
  	  };
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 172 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(29),
  	  __webpack_require__(173)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (nodeHelpers, mutations) {

  	  var maybeWindow = typeof window === 'object' ? window : undefined;

  	  var MutationObserver = mutations.determineMutationObserver(maybeWindow);

  	  function hasRealMutation(n) {
  	    return ! nodeHelpers.isEmptyTextNode(n) &&
  	      ! nodeHelpers.isSelectionMarkerNode(n);
  	  }

  	  function includeRealMutations(mutations) {
  	    return mutations.some(function(mutation) {
  	      return Array.prototype.some.call(mutation.addedNodes, hasRealMutation) ||
  	        Array.prototype.some.call(mutation.removedNodes, hasRealMutation);
  	    });
  	  }

  	  function observeDomChanges(el, callback) {
  	    // Flag to avoid running recursively
  	    var runningPostMutation = false;

  	    var observer = new MutationObserver(function(mutations) {
  	      if (! runningPostMutation && includeRealMutations(mutations)) {
  	        runningPostMutation = true;

  	        try {
  	          callback();
  	        } catch(e) {
  	          // The catch block is required but we don't want to swallow the error
  	          throw e;
  	        } finally {
  	          // We must yield to let any mutation we caused be triggered
  	          // in the next cycle
  	          setTimeout(function() {
  	            runningPostMutation = false;
  	          }, 0);
  	        }
  	      }
  	    });

  	    observer.observe(el, {
  	      childList: true,
  	      subtree: true
  	    });

  	    return observer;
  	  }

  	  return observeDomChanges;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 173 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  function determineMutationObserver(window) {
  	    // This enables server side rendering
  	    if (typeof window === 'undefined') {
  	      // Stub observe function to avoid error
  	      return function() {
  	        return {
  	          observe: function() {}
  	        };
  	      }
  	    } else {
  	      return window.MutationObserver ||
  	        window.WebKitMutationObserver ||
  	        window.MozMutationObserver;
  	    }
  	  }

  	  return {
  	    determineMutationObserver: determineMutationObserver
  	  };
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 174 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(175),
  	  __webpack_require__(176),
  	  __webpack_require__(177),
  	  __webpack_require__(178),
  	  __webpack_require__(179),
  	  __webpack_require__(180),
  	  __webpack_require__(181)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (
  	  boldCommand,
  	  indentCommand,
  	  insertHTMLCommand,
  	  insertListCommands,
  	  outdentCommand,
  	  createLinkCommand,
  	  events
  	) {

  	  return {
  	    commands: {
  	      bold: boldCommand,
  	      indent: indentCommand,
  	      insertHTML: insertHTMLCommand,
  	      insertList: insertListCommands,
  	      outdent: outdentCommand,
  	      createLink: createLinkCommand,
  	    },
  	    events: events
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 175 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function () {
  	    return function (scribe) {
  	      var boldCommand = new scribe.api.CommandPatch('bold');

  	      /**
  	       * Chrome: Executing the bold command inside a heading corrupts the markup.
  	       * Disabling for now.
  	       */
  	      boldCommand.queryEnabled = function () {
  	        var selection = new scribe.api.Selection();
  	        var headingNode = selection.getContaining(function (node) {
  	          return (/^(H[1-6])$/).test(node.nodeName);
  	        });

  	        return scribe.api.CommandPatch.prototype.queryEnabled.apply(this, arguments) && ! headingNode;
  	      };

  	      // TODO: We can't use STRONGs because this would mean we have to
  	      // re-implement the `queryState` command, which would be difficult.

  	      scribe.commandPatches.bold = boldCommand;
  	    };
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 176 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  var INVISIBLE_CHAR = '\uFEFF';

  	  return function () {
  	    return function (scribe) {
  	      var indentCommand = new scribe.api.CommandPatch('indent');

  	      indentCommand.execute = function (value) {
  	        scribe.transactionManager.run(function () {
  	          /**
  	           * Chrome: If we apply the indent command on an empty P, the
  	           * BLOCKQUOTE will be nested inside the P.
  	           * As per: http://jsbin.com/oDOriyU/3/edit?html,js,output
  	           */
  	          var selection = new scribe.api.Selection();
  	          var range = selection.range;

  	          var isCaretOnNewLine =
  	              (range.commonAncestorContainer.nodeName === 'P'
  	               && range.commonAncestorContainer.innerHTML === '<br>');
  	          if (isCaretOnNewLine) {
  	            // FIXME: this text node is left behind. Tidy it up somehow,
  	            // or don't use it at all.
  	            var textNode = document.createTextNode(INVISIBLE_CHAR);

  	            range.insertNode(textNode);

  	            range.setStart(textNode, 0);
  	            range.setEnd(textNode, 0);

  	            selection.selection.removeAllRanges();
  	            selection.selection.addRange(range);
  	          }

  	          scribe.api.CommandPatch.prototype.execute.call(this, value);

  	          /**
  	           * Chrome: The BLOCKQUOTE created contains a redundant style attribute.
  	           * As per: http://jsbin.com/AkasOzu/1/edit?html,js,output
  	           */

  	          // Renew the selection
  	          selection = new scribe.api.Selection();
  	          var blockquoteNode = selection.getContaining(function (node) {
  	            return node.nodeName === 'BLOCKQUOTE';
  	          });

  	          if (blockquoteNode) {
  	            blockquoteNode.removeAttribute('style');
  	          }
  	        }.bind(this));
  	      };

  	      scribe.commandPatches.indent = indentCommand;
  	    };
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 177 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  	  return function () {
  	    return function (scribe) {
  	      var insertHTMLCommandPatch = new scribe.api.CommandPatch('insertHTML');
  	      var nodeHelpers = scribe.node;

  	      insertHTMLCommandPatch.execute = function (value) {
  	        scribe.transactionManager.run(function () {
  	          scribe.api.CommandPatch.prototype.execute.call(this, value);
  	          nodeHelpers.removeChromeArtifacts(scribe.el);
  	        }.bind(this));
  	      };

  	      scribe.commandPatches.insertHTML = insertHTMLCommandPatch;
  	    };
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 178 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function () {
  	    return function (scribe) {
  	      var nodeHelpers = scribe.node;

  	      var InsertListCommandPatch = function (commandName) {
  	        scribe.api.CommandPatch.call(this, commandName);
  	      };

  	      InsertListCommandPatch.prototype = Object.create(scribe.api.CommandPatch.prototype);
  	      InsertListCommandPatch.prototype.constructor = InsertListCommandPatch;

  	      InsertListCommandPatch.prototype.execute = function (value) {
  	        scribe.transactionManager.run(function () {
  	          scribe.api.CommandPatch.prototype.execute.call(this, value);

  	          if (this.queryState()) {
  	            var selection = new scribe.api.Selection();

  	            var listElement = selection.getContaining(function (node) {
  	              return node.nodeName === 'OL' || node.nodeName === 'UL';
  	            });

  	            if (listElement) {

  	              /**
  	               * Firefox: If we apply the insertOrderedList or the insertUnorderedList
  	               * command on an empty block, a P will be inserted after the OL/UL.
  	               * As per: http://jsbin.com/cubacoli/3/edit?html,js,output
  	               */

  	              if (listElement.nextElementSibling &&
  	                  listElement.nextElementSibling.childNodes.length === 0) {
  	                nodeHelpers.removeNode(listElement.nextElementSibling);
  	              }

  	              /**
  	               * Chrome: If we apply the insertOrderedList or the insertUnorderedList
  	               * command on an empty block, the OL/UL will be nested inside the block.
  	               * As per: http://jsbin.com/eFiRedUc/1/edit?html,js,output
  	               */

  	              var listParentNode = listElement.parentNode;
  	              // If list is within a text block then split that block
  	              if (listParentNode && /^(H[1-6]|P)$/.test(listParentNode.nodeName)) {
  	                selection.placeMarkers();
  	                // Move listElement out of the block
  	                nodeHelpers.insertAfter(listElement, listParentNode);
  	                selection.selectMarkers();

  	                /**
  	                 * Chrome 27-34: An empty text node is inserted.
  	                 */
  	                if (listParentNode.childNodes.length === 2 &&
  	                    nodeHelpers.isEmptyTextNode(listParentNode.firstChild)) {
  	                  nodeHelpers.removeNode(listParentNode);
  	                }

  	                // Remove the block if it's empty
  	                if (listParentNode.childNodes.length === 0) {
  	                  nodeHelpers.removeNode(listParentNode);
  	                }
  	              }

  	              nodeHelpers.removeChromeArtifacts(listElement);
  	            }
  	          }
  	        }.bind(this));
  	      };

  	      InsertListCommandPatch.prototype.queryState = function() {
  	        try {
  	          return scribe.api.CommandPatch.prototype.queryState.apply(this, arguments);
  	        } catch (err) {
  	          // Explicitly catch unexpected error when calling queryState - bug in Firefox: https://github.com/guardian/scribe/issues/208
  	          if (err.name == 'NS_ERROR_UNEXPECTED') {
  	            return false;
  	          } else {
  	            throw err;
  	          }
  	        }
  	      };

  	      scribe.commandPatches.insertOrderedList = new InsertListCommandPatch('insertOrderedList');
  	      scribe.commandPatches.insertUnorderedList = new InsertListCommandPatch('insertUnorderedList');
  	    };
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 179 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function () {
  	    return function (scribe) {
  	      var nodeHelpers = scribe.node;
  	      var outdentCommand = new scribe.api.CommandPatch('outdent');

  	      outdentCommand.execute = function () {
  	        scribe.transactionManager.run(function () {
  	          var selection = new scribe.api.Selection();
  	          var range = selection.range;

  	          var blockquoteNode = selection.getContaining(function (node) {
  	            return node.nodeName === 'BLOCKQUOTE';
  	          });

  	          if (range.commonAncestorContainer.nodeName === 'BLOCKQUOTE') {
  	            /**
  	             * Chrome: Applying the outdent command when a whole BLOCKQUOTE is
  	             * selected removes the formatting of its contents.
  	             * As per: http://jsbin.com/okAYaHa/1/edit?html,js,output
  	             */

  	            // Insert a copy of the selection before the BLOCKQUOTE, and then
  	            // restore the selection on the copy.
  	            selection.placeMarkers();
  	            // We want to copy the selected nodes *with* the markers
  	            selection.selectMarkers(true);
  	            var selectedNodes = range.cloneContents();
  	            blockquoteNode.parentNode.insertBefore(selectedNodes, blockquoteNode);
  	            range.deleteContents();
  	            selection.selectMarkers();

  	            // Delete the BLOCKQUOTE if it's empty
  	            if (blockquoteNode.textContent === '') {
  	              blockquoteNode.parentNode.removeChild(blockquoteNode);
  	            }
  	          } else {
  	            /**
  	             * Chrome: If we apply the outdent command on a P, the contents of the
  	             * P will be outdented instead of the whole P element.
  	             * As per: http://jsbin.com/IfaRaFO/1/edit?html,js,output
  	             */

  	            var pNode = selection.getContaining(function (node) {
  	              return node.nodeName === 'P';
  	            });

  	            if (pNode) {
  	              /**
  	               * If we are not at the start of end of a BLOCKQUOTE, we have to
  	               * split the node and insert the P in the middle.
  	               */

  	              var nextSiblingNodes = nodeHelpers.nextSiblings(pNode);

  	              if (!!nextSiblingNodes.size) {
  	                var newContainerNode = document.createElement(blockquoteNode.nodeName);

  	                while (!!nextSiblingNodes.size) {
  	                  newContainerNode.appendChild(nextSiblingNodes.first());
  	                  nextSiblingNodes = nextSiblingNodes.shift();
  	                }

  	                blockquoteNode.parentNode.insertBefore(newContainerNode, blockquoteNode.nextElementSibling);
  	              }

  	              selection.placeMarkers();
  	              blockquoteNode.parentNode.insertBefore(pNode, blockquoteNode.nextElementSibling);
  	              selection.selectMarkers();

  	              // If the BLOCKQUOTE is now empty, clean it up.
  	              if (blockquoteNode.innerHTML === '') {
  	                blockquoteNode.parentNode.removeChild(blockquoteNode);
  	              }
  	            } else {
  	              scribe.api.CommandPatch.prototype.execute.call(this);
  	            }
  	          }
  	        }.bind(this));
  	      };

  	      scribe.commandPatches.outdent = outdentCommand;
  	    };
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 180 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function () {
  	    return function (scribe) {
  	      var createLinkCommand = new scribe.api.CommandPatch('createLink');
  	      scribe.commandPatches.createLink = createLinkCommand;

  	      createLinkCommand.execute = function (value) {
  	        var selection = new scribe.api.Selection();

  	        /**
  	         * make sure we're not touching any none Scribe elements
  	         * in the page
  	         */
  	        if (!selection.isInScribe()) {
  	          return;
  	        }

  	        /**
  	         * Firefox does not create a link when selection is collapsed
  	         * so we create it manually. http://jsbin.com/tutufi/2/edit?js,output
  	         */
  	        // using range.collapsed vs selection.isCollapsed - https://code.google.com/p/chromium/issues/detail?id=447523
  	        if (selection.range.collapsed) {
  	          var aElement = document.createElement('a');
  	          aElement.setAttribute('href', value);
  	          aElement.textContent = value;

  	          selection.range.insertNode(aElement);

  	          // Select the created link
  	          var newRange = document.createRange();
  	          newRange.setStartBefore(aElement);
  	          newRange.setEndAfter(aElement);

  	          selection.selection.removeAllRanges();
  	          selection.selection.addRange(newRange);
  	        } else {
  	          scribe.api.CommandPatch.prototype.execute.call(this, value);
  	        }
  	      };
  	    };
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 181 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function () {
  	    return function (scribe) {
  	      // TODO: do we need to run this on every key press, or could we
  	      //       detect when the issue may have occurred?
  	      // TODO: run in a transaction so as to record the change? how do
  	      //       we know in advance whether there will be a change though?
  	      // TODO: share somehow with `InsertList` command

  	      var nodeHelpers = scribe.node;

  	      if (scribe.allowsBlockElements()) {
  	        scribe.el.addEventListener('keyup', function (event) {
  	          if (event.keyCode === 8 || event.keyCode === 46) { // backspace or delete

  	            var selection = new scribe.api.Selection();

  	            // Note: the range is always collapsed on keyup here
  	            var containerPElement = selection.getContaining(function (node) {
  	              return node.nodeName === 'P';
  	            });
  	            if (containerPElement) {
  	              /**
  	               * The 'input' event listener has already triggered
  	               * and recorded the faulty content as an item in the
  	               * UndoManager. We interfere with the undoManager
  	               * by force merging that transaction with the next
  	               * transaction which produce a clean one instead.
  	               *
  	               * FIXME: ideally we would not trigger a
  	               * 'content-changed' event with faulty HTML at all, but
  	               * it's too late to cancel it at this stage (and it's
  	               * not happened yet at keydown time).
  	               */

  	              scribe.transactionManager.run(function () {
  	                // Store the caret position
  	                selection.placeMarkers();
  	                nodeHelpers.removeChromeArtifacts(containerPElement);
  	                selection.selectMarkers();
  	              }, true);
  	            }
  	          }
  	        });
  	      }
  	    };
  	  };
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 182 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(183),
  	  __webpack_require__(184),
  	  __webpack_require__(185),
  	  __webpack_require__(186)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (
  	  buildCommandPatch,
  	  buildCommand,
  	  buildSelection,
  	  buildSimpleCommand
  	) {

  	  return function Api(scribe) {
  	    this.CommandPatch = buildCommandPatch(scribe);
  	    this.Command = buildCommand(scribe);
  	    this.Selection = buildSelection(scribe);
  	    this.SimpleCommand = buildSimpleCommand(this, scribe);
  	  };
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 183 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function (scribe) {
  	    function CommandPatch(commandName) {
  	      this.commandName = commandName;
  	    }

  	    CommandPatch.prototype.execute = function (value) {
  	      scribe.transactionManager.run(function () {
  	        document.execCommand(this.commandName, false, value || null);
  	      }.bind(this));
  	    };

  	    CommandPatch.prototype.queryState = function () {
  	      return document.queryCommandState(this.commandName);
  	    };

  	    CommandPatch.prototype.queryEnabled = function () {
  	      return document.queryCommandEnabled(this.commandName);
  	    };

  	    return CommandPatch;
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 184 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function (scribe) {
  	    function Command(commandName) {
  	      this.commandName = commandName;
  	      this.patch = scribe.commandPatches[this.commandName];
  	    }

  	    Command.prototype.execute = function (value) {
  	      if (this.patch) {
  	        this.patch.execute(value);
  	      } else {
  	        scribe.transactionManager.run(function () {
  	          document.execCommand(this.commandName, false, value || null);
  	        }.bind(this));
  	      }
  	    };

  	    Command.prototype.queryState = function () {
  	      if (this.patch) {
  	        return this.patch.queryState();
  	      } else {
  	        return document.queryCommandState(this.commandName);
  	      }
  	    };

  	    Command.prototype.queryEnabled = function () {
  	      if (this.patch) {
  	        return this.patch.queryEnabled();
  	      } else {
  	        return document.queryCommandEnabled(this.commandName);
  	      }
  	    };

  	    return Command;
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 185 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function (scribe) {
  	    var rootDoc = scribe.el.ownerDocument;
  	    var nodeHelpers = scribe.node;

  	    // find the parent document or document fragment
  	    if( rootDoc.compareDocumentPosition(scribe.el) & Node.DOCUMENT_POSITION_DISCONNECTED ) {
  	      var currentElement = scribe.el.parentNode;
  	      while(currentElement && nodeHelpers.isFragment(currentElement)) {
  	        currentElement = currentElement.parentNode;
  	      }

  	      // if we found a document fragment and it has a getSelection method, set it to the root doc
  	      if (currentElement && currentElement.getSelection) {
  	        rootDoc = currentElement;
  	      }
  	    }

  	    function createMarker() {
  	      var node = document.createElement('em');
  	      node.style.display = 'none';
  	      node.classList.add('scribe-marker');
  	      return node;
  	    }

  	    function insertMarker(range, marker) {
  	      range.insertNode(marker);

  	      /**
  	       * Chrome and Firefox: `Range.insertNode` inserts a bogus text node after
  	       * the inserted element. We just remove it. This in turn creates several
  	       * bugs when perfoming commands on selections that contain an empty text
  	       * node (`removeFormat`, `unlink`).
  	       * As per: http://jsbin.com/hajim/5/edit?js,console,output
  	       */
  	      if (marker.nextSibling && nodeHelpers.isEmptyTextNode(marker.nextSibling)) {
  	        nodeHelpers.removeNode(marker.nextSibling);
  	      }

  	      /**
  	       * Chrome and Firefox: `Range.insertNode` inserts a bogus text node before
  	       * the inserted element when the child element is at the start of a block
  	       * element. We just remove it.
  	       * FIXME: Document why we need to remove this
  	       * As per: http://jsbin.com/sifez/1/edit?js,console,output
  	       */
  	      if (marker.previousSibling && nodeHelpers.isEmptyTextNode(marker.previousSibling)) {
  	        nodeHelpers.removeNode(marker.previousSibling);
  	      }
  	    }

  	    // With MS Edge, ranges that will be converted to selection require
  	    // to start or end on a text node otherwise when normalizing the text nodes
  	    // in the selection it won't be correct.

  	    function setRangeStart(range, marker) {
  	      var prevSibling = marker.previousSibling;
  	      var nextSibling = marker.nextSibling;

  	      if (prevSibling && prevSibling.nodeType === Node.TEXT_NODE) {
  	        range.setStart(prevSibling, prevSibling.data.length);
  	      } else if (nextSibling && nextSibling.nodeType === Node.TEXT_NODE) {
  	        range.setStart(nextSibling, 0);
  	      } else {
  	        range.setStartBefore(marker);
  	      }
  	    }

  	    function setRangeEnd(range, marker) {
  	      var prevSibling = marker.previousSibling;
  	      var nextSibling = marker.nextSibling;

  	      if (prevSibling && prevSibling.nodeType === Node.TEXT_NODE) {
  	        range.setEnd(prevSibling, prevSibling.data.length);
  	      } else if (nextSibling && nextSibling.nodeType === Node.TEXT_NODE) {
  	        range.setEnd(nextSibling, 0);
  	      } else {
  	        range.setEndAfter(marker);
  	      }
  	    }

  	    /**
  	     * Wrapper for object holding currently selected text.
  	     */
  	    function Selection() {
  	      this.selection = rootDoc.getSelection();
  	      if (this.selection.rangeCount && this.selection.anchorNode) {
  	        var startNode   = this.selection.anchorNode;
  	        var startOffset = this.selection.anchorOffset;
  	        var endNode     = this.selection.focusNode;
  	        var endOffset   = this.selection.focusOffset;

  	        // if the range starts and ends on the same node, then we must swap the
  	        // offsets if ever focusOffset is smaller than anchorOffset
  	        if (startNode === endNode && endOffset < startOffset) {
  	          var tmp = startOffset;
  	          startOffset = endOffset;
  	          endOffset = tmp;
  	        }
  	        // if the range ends *before* it starts, then we must reverse the range
  	        else if (nodeHelpers.isBefore(endNode, startNode)) {
  	          var tmpNode = startNode,
  	            tmpOffset = startOffset;
  	          startNode = endNode;
  	          startOffset = endOffset;
  	          endNode = tmpNode;
  	          endOffset = tmpOffset;
  	        }

  	        // create the range to avoid chrome bug from getRangeAt / window.getSelection()
  	        // https://code.google.com/p/chromium/issues/detail?id=380690
  	        this.range = document.createRange();
  	        this.range.setStart(startNode, startOffset);
  	        this.range.setEnd(endNode, endOffset);
  	      }
  	    }

  	    /**
  	     * @returns Closest ancestor Node satisfying nodeFilter. Undefined if none exist before reaching Scribe container.
  	     */
  	    Selection.prototype.getContaining = function (nodeFilter) {
  	      var range = this.range;
  	      if (!range) { return; }

  	      var node = this.range.commonAncestorContainer;
  	      return ! (node && scribe.el === node) && nodeFilter(node) ?
  	        node :
  	        nodeHelpers.getAncestor(node, scribe.el, nodeFilter);
  	    };

  	    Selection.prototype.isInScribe = function () {
  	      var range = this.range;
  	      return range
  	        //we need to ensure that the scribe's element lives within the current document to avoid errors with the range comparison (see below)
  	        //one way to do this is to check if it's visible (is this the best way?).
  	        && document.contains(scribe.el)
  	        //we want to ensure that the current selection is within the current scribe node
  	        //if this isn't true scribe will place markers within the selections parent
  	        //we want to ensure that scribe ONLY places markers within it's own element
  	        && scribe.el.contains(range.startContainer)
  	        && scribe.el.contains(range.endContainer);
  	    };

  	    Selection.prototype.placeMarkers = function () {
  	      var range = this.range;

  	      if (!this.isInScribe()) {
  	        return;
  	      }

  	      // insert start marker
  	      insertMarker(range.cloneRange(), createMarker());

  	      if (! range.collapsed ) {
  	        // End marker
  	        var rangeEnd = range.cloneRange();
  	        rangeEnd.collapse(false);
  	        insertMarker(rangeEnd, createMarker());
  	      }

  	      this.selection.removeAllRanges();
  	      this.selection.addRange(range);
  	    };

  	    Selection.prototype.getMarkers = function () {
  	      return scribe.el.querySelectorAll('em.scribe-marker');
  	    };

  	    Selection.prototype.removeMarkers = function () {
  	      Array.prototype.forEach.call(this.getMarkers(), function (marker) {
  	        var markerParent = marker.parentNode;
  	        nodeHelpers.removeNode(marker);

  	        // MSIE doesn't like normalize
  	        if (!window.navigator.userAgent.indexOf("MSIE ")) {
  	          // Placing the markers may have split a text node. Sew it up, otherwise
  	          // if the user presses space between the nodes the browser will insert
  	          // an `&nbsp;` and that will cause word wrapping issues.
  	          markerParent.normalize();
  	        }
  	      });
  	    };

  	    // This will select markers if there are any. You will need to focus the
  	    // Scribe instances element if it is not already for the selection to
  	    // become active.
  	    Selection.prototype.selectMarkers = function (keepMarkers) {
  	      var markers = this.getMarkers();
  	      if (!markers.length) {
  	        return;
  	      }

  	      var newRange = document.createRange();

  	      setRangeStart(newRange, markers[0]);
  	      // We always reset the end marker because otherwise it will just
  	      // use the current ranges end marker.
  	      setRangeEnd(newRange, markers.length >= 2 ? markers[1] : markers[0]);

  	      if (! keepMarkers) {
  	        this.removeMarkers();
  	      }

  	      this.selection.removeAllRanges();
  	      this.selection.addRange(newRange);
  	    };

  	    Selection.prototype.isCaretOnNewLine = function () {
  	      var containerPElement = this.getContaining(function (node) {
  	        return node.nodeName === 'P';
  	      });
  	      return !! containerPElement && nodeHelpers.isEmptyInlineElement(containerPElement);
  	    };

  	    return Selection;
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 186 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function (api, scribe) {
  	    function SimpleCommand(commandName, nodeName) {
  	      scribe.api.Command.call(this, commandName);

  	      this._nodeName = nodeName;
  	    }

  	    SimpleCommand.prototype = Object.create(api.Command.prototype);
  	    SimpleCommand.prototype.constructor = SimpleCommand;

  	    SimpleCommand.prototype.queryState = function () {
  	      var selection = new scribe.api.Selection();
  	      return scribe.api.Command.prototype.queryState.call(this) && !! selection.getContaining(function (node) {
  	        return node.nodeName === this._nodeName;
  	      }.bind(this));
  	    };

  	    return SimpleCommand;
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 187 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(70)
  	  ], __WEBPACK_AMD_DEFINE_RESULT__ = (function (events) {

  	  return function (scribe) {
  	    function TransactionManager() {
  	      this.history = [];
  	    }

  	    Object.assign(TransactionManager.prototype, {
  	      start: function () {
  	        this.history.push(1);
  	      },

  	      end: function () {
  	        this.history.pop();

  	        if (this.history.length === 0) {
  	          scribe.pushHistory();
  	          scribe.trigger(events.legacyContentChanged);
  	          scribe.trigger(events.contentChanged);
  	        }
  	      },

  	      run: function (transaction, forceMerge) {
  	        this.start();
  	        // If there is an error, don't prevent the transaction from ending.
  	        try {
  	          if (transaction) {
  	            transaction();
  	          }
  	        } finally {
  	          scribe._forceMerge = forceMerge === true;
  	          this.end();
  	          scribe._forceMerge = false;
  	        }
  	      }
  	    });

  	    return TransactionManager;
  	  };
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 188 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(5)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Immutable) {

  	  function UndoManager(limit, undoScopeHost) {
  	    this._stack = Immutable.List();
  	    this._limit = limit;
  	    this._fireEvent = undoScopeHost && undoScopeHost.dispatchEvent;
  	    this._ush = undoScopeHost;

  	    this.position = 0;
  	    this.length = 0;
  	  }

  	  UndoManager.prototype.transact = function (transaction, merge) {
  	    if (arguments.length < 2) {
  	      throw new TypeError('Not enough arguments to UndoManager.transact.');
  	    }

  	    transaction.execute();

  	    if (this.position > 0) {
  	      this.clearRedo();
  	    }

  	    var transactions;
  	    if (merge && this.length) {
  	      transactions = this._stack.first().push(transaction);
  	      this._stack = this._stack.shift().unshift(transactions);
  	    }
  	    else {
  	      transactions = Immutable.List.of(transaction);
  	      this._stack = this._stack.unshift(transactions);
  	      this.length++;

  	      if (this._limit && this.length > this._limit) {
  	        this.clearUndo(this._limit);
  	      }
  	    }

  	    this._dispatch('DOMTransaction', transactions);
  	  };

  	  UndoManager.prototype.undo = function () {
  	    if (this.position >= this.length) { return; }

  	    var transactions = this._stack.get(this.position);
  	    var i = transactions.size;
  	    while (i--) {
  	      transactions.get(i).undo();
  	    }
  	    this.position++;

  	    this._dispatch('undo', transactions);
  	  };

  	  UndoManager.prototype.redo = function () {
  	    if (this.position === 0) { return; }

  	    this.position--;
  	    var transactions = this._stack.get(this.position);
  	    for (var i = 0; i < transactions.size; i++) {
  	      transactions.get(i).redo();
  	    }

  	    this._dispatch('redo', transactions);
  	  };

  	  UndoManager.prototype.item = function (index) {
  	    return index >= 0 && index < this.length ?
  	      this._stack.get(index).toArray() :
  	      null;
  	  };

  	  UndoManager.prototype.clearUndo = function (position) {
  	    this._stack = this._stack.take(position !== undefined ? position : this.position);
  	    this.length = this._stack.size;
  	  };

  	  UndoManager.prototype.clearRedo = function () {
  	    this._stack = this._stack.skip(this.position);
  	    this.length = this._stack.size;
  	    this.position = 0;
  	  };

  	  UndoManager.prototype._dispatch = function(event, transactions) {
  	    if (this._fireEvent) {
  	      this._ush.dispatchEvent(new CustomEvent(event, {
  	        detail: {transactions: transactions.toArray()},
  	        bubbles: true,
  	        cancelable: false
  	      }));
  	    }
  	  };

  	  return UndoManager;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 189 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Immutable) {

  	  // TODO: once
  	  // TODO: unit test
  	  // Good example of a complete(?) implementation: https://github.com/Wolfy87/EventEmitter
  	  function EventEmitter() {
  	    this._listeners = {};
  	  }

  	  EventEmitter.prototype.on = function (eventName, fn) {
  	    var listeners = this._listeners[eventName] || Immutable.Set();

  	    this._listeners[eventName] = listeners.add(fn);
  	  };

  	  EventEmitter.prototype.off = function (eventName, fn) {
  	    var listeners = this._listeners[eventName] || Immutable.Set();
  	    if (fn) {
  	      this._listeners[eventName] = listeners.delete(fn);
  	    } else {
  	      this._listeners[eventName] = listeners.clear();
  	    }
  	  };

  	  EventEmitter.prototype.trigger = function (eventName, args) {

  	    //fire events like my:custom:event -> my:custom -> my
  	    var events = eventName.split(':');
  	    while(!!events.length){
  	      var currentEvent = events.join(':');
  	      var listeners = this._listeners[currentEvent] || Immutable.Set();
  	      //trigger handles
  	      listeners.forEach(function (listener) {
  	        listener.apply(null, args);
  	      });
  	      events.splice((events.length - 1), 1);
  	    }
  	  };

  	  return EventEmitter;

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 190 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (immutable) {

  	  var blockModePlugins = [
  	    'setRootPElement',
  	    'enforcePElements',
  	    'ensureSelectableContainers',
  	  ],
  	  inlineModePlugins = [
  	    'inlineElementsMode'
  	  ],
  	  defaultOptions = {
  	    allowBlockElements: true,
  	    debug: false,
  	    undo: {
  	      manager: false,
  	      enabled: true,
  	      limit: 100,
  	      interval: 250
  	    },
  	    defaultCommandPatches: [
  	      'bold',
  	      'indent',
  	      'insertHTML',
  	      'insertList',
  	      'outdent',
  	      'createLink'
  	    ],

  	    defaultPlugins: blockModePlugins.concat(inlineModePlugins),

  	    defaultFormatters: [
  	      'escapeHtmlCharactersFormatter',
  	      'replaceNbspCharsFormatter'
  	    ]
  	  };


  	  function defaults(options, defaultOptions) {
  	    var optionsCopy = immutable.fromJS(options);
  	    var defaultsCopy = immutable.fromJS(defaultOptions);
  	    var mergedOptions = defaultsCopy.merge(optionsCopy);
  	    return mergedOptions.toJS();
  	  }

  	  /**
  	   * Overrides defaults with user's options
  	   *
  	   * @param  {Object} userSuppliedOptions The user's options
  	   * @return {Object}                     The overridden options
  	   */
  	  function checkOptions(userSuppliedOptions) {
  	    var options = userSuppliedOptions || {};

  	    // Remove invalid plugins
  	    if (options.defaultPlugins) {
  	      options.defaultPlugins    = options.defaultPlugins.filter(filterByPluginExists(defaultOptions.defaultPlugins));
  	    }

  	    if (options.defaultFormatters) {
  	      options.defaultFormatters = options.defaultFormatters.filter(filterByPluginExists(defaultOptions.defaultFormatters));
  	    }

  	    return Object.freeze(defaults(options, defaultOptions));
  	  }

  	  /**
  	   * Sorts a plugin list by a specified plugin name
  	   *
  	   * @param  {String} priorityPlugin The plugin name to be given priority
  	   * @return {Function}              Sorting function for the given plugin name
  	   */
  	  function sortByPlugin(priorityPlugin) {
  	    return function (pluginCurrent, pluginNext) {
  	      if (pluginCurrent === priorityPlugin) {
  	        // pluginCurrent comes before plugin next
  	        return -1;
  	      } else if (pluginNext === priorityPlugin) {
  	        // pluginNext comes before pluginCurrent
  	        return 1;
  	      }

  	      // Do no swap
  	      return 0;
  	    }
  	  }

  	  /**
  	   * Filters a list of plugins by block level / inline level mode.
  	   *
  	   * @param  {Boolean} isBlockLevelMode Whether block level mode is enabled
  	   * @return {Function}                 Filtering function based upon the given mode
  	   */
  	  function filterByBlockLevelMode(isBlockLevelMode) {
  	    return function (plugin) {
  	      return (isBlockLevelMode ? blockModePlugins : inlineModePlugins).indexOf(plugin) !== -1;
  	    }
  	  }

  	  /**
  	   * Filters a list of plugins by their validity
  	   *
  	   * @param  {Array<String>} pluginList   List of plugins to check against
  	   * @return {Function}                   Filtering function based upon the given list
  	   */
  	  function filterByPluginExists(pluginList) {
  	    return function (plugin) {
  	      return pluginList.indexOf(plugin) !== -1;
  	    }
  	  }

  	  return {
  	    defaultOptions: defaultOptions,
  	    checkOptions: checkOptions,
  	    sortByPlugin: sortByPlugin,
  	    filterByBlockLevelMode: filterByBlockLevelMode,
  	    filterByPluginExists: filterByPluginExists
  	  }
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 191 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  return function () {
  	    return function (scribe) {
  	      scribe.registerPlainTextFormatter(function (html) {
  	        return html.replace(/\n([ \t]*\n)+/g, '</p><p>').replace(/\n/g, '<br>');
  	      });
  	    };
  	  };

  	}).call(exports, __webpack_require__, exports, module),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 192 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
  	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(193),
  	  __webpack_require__(194),
  	  __webpack_require__(195),
  	  __webpack_require__(196)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (checks, init, prompts, transforms) {

  	  return function (options) {
  	    var options = init.init(options);

  	    return function (scribe) {
  	      var linkPromptCommand = new scribe.api.Command('createLink');

  	      linkPromptCommand.nodeName = 'A';

  	      linkPromptCommand.execute = function (passedLink) {
  	        var link;
  	        var selection = new scribe.api.Selection();
  	        var range = selection.range;
  	        var anchorNode = selection.getContaining(function (node) {
  	          return node.nodeName === this.nodeName;
  	        }.bind(this));

  	        var initialLink = anchorNode ? anchorNode.href : '';

  	        if (!passedLink)  {
  	          link = window.prompt('Enter a link.', initialLink);
  	        } else {
  	          link = passedLink;
  	        }

  	        link = transforms.run(options.transforms.pre, link);

  	        if(!checks.emptyLink(link)) {
  	          window.alert('This link appears empty');
  	          return;
  	        }

  	        if(options && options.validation) {
  	          var validationResult = options.validation(link);

  	          if(!validationResult.valid) {
  	            window.alert(validationResult.message || 'The link is not valid');
  	            return;
  	          }
  	        }

  	        if (anchorNode) {
  	          range.selectNode(anchorNode);
  	          selection.selection.removeAllRanges();
  	          selection.selection.addRange(range);
  	        }

  	        if (link) {

  	          if (! checks.hasKnownProtocol(link) ) {
  	            link = prompts.process(window, link);
  	          }

  	          link = transforms.run(options.transforms.post, link);

  	          scribe.api.SimpleCommand.prototype.execute.call(this, link);
  	        }
  	      };

  	      linkPromptCommand.queryState = function () {
  	        /**
  	         * We override the native `document.queryCommandState` for links because
  	         * the `createLink` and `unlink` commands are not supported.
  	         * As per: http://jsbin.com/OCiJUZO/1/edit?js,console,output
  	         */
  	        var selection = new scribe.api.Selection();
  	        return !! selection.getContaining(function (node) {
  	          return node.nodeName === this.nodeName;
  	        }.bind(this));
  	      };

  	      scribe.commands.linkPrompt = linkPromptCommand;
  	    };
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 193 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  var urlProtocolRegExp = /^https?\:\/\//;
  	  var mailtoProtocolRegExp = /^mailto\:/;
  	  var telProtocolRegExp = /^tel\:/;

  	  var knownProtocols = [urlProtocolRegExp, mailtoProtocolRegExp, telProtocolRegExp];

  	  function emptyLink(string) {
  	    return /\w/.test(string);
  	  }

  	  function hasKnownProtocol(urlValue) {
  	    // If a http/s or mailto link is provided, then we will trust that an link is valid
  	    return knownProtocols.some(function(protocol) { return protocol.test(urlValue)});
  	  }

  	  return {
  	    emptyLink: emptyLink,
  	    hasKnownProtocol: hasKnownProtocol
  	  };
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 194 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {

  	  function init(options) {
  	    var options = options || {};

  	    if(!options.transforms) {
  	      options.transforms = {};
  	    }

  	    ['pre', 'post'].forEach(function(key) {
  	      if(!options.transforms[key]) {
  	        options.transforms[key] = [];
  	      }
  	    });

  	    return options;
  	  }

  	  return {
  	    init: init
  	  }
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 195 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  var userPrompts = [
  	    {
  	      // For emails we just look for a `@` symbol as it is easier.
  	      regexp: /@/,
  	      message: 'The URL you entered appears to be an email address. ' +
  	      'Do you want to add the required mailto: prefix?',
  	      action: function(link) {
  	        return 'mailto:' + link;
  	      }
  	    },
  	    {
  	      // For tel numbers check for + and numerical values
  	      regexp: /\+?\d+/,
  	      message: 'The URL you entered appears to be a telephone number. ' +
  	                'Do you want to add the required tel: prefix?',
  	      action: function(link) {
  	        return 'tel:' + link;
  	      }
  	    },
  	    {
  	      regexp: /.+/,
  	      message: 'The URL you entered appears to be a link. ' +
  	                'Do you want to add the required http:// prefix?',
  	      action: function(link) {
  	        return 'http://' + link;
  	      }
  	    }
  	  ];

  	  function process(window, link) {
  	    for (var i = 0; i < userPrompts.length; i++) {
  	      var prompt = userPrompts[i];

  	      if(prompt.regexp.test(link)) {
  	        var userResponse = window.confirm(prompt.message);

  	        if(userResponse) {
  	          // Only process the first prompt
  	          return prompt.action(link);
  	        }
  	      }

  	    }
  	    return link;
  	  }

  	  return {
  	    process: process
  	  }

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

  	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(55)));

  	/***/ }),
  	/* 196 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {


  	  function run(transforms, initialLink) {
  	    return transforms.reduce(function(currentLinkValue, transform) {
  	      return transform(currentLinkValue);
  	      }, initialLink);
  	  }

  	  return {
  	    run: run
  	  }
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 197 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  	  __webpack_require__(198),
  	  __webpack_require__(199),
  	  __webpack_require__(214)
  	], __WEBPACK_AMD_DEFINE_RESULT__ = (function (
  	  HTMLJanitor,
  	  merge,
  	  cloneDeep
  	) {

  	  return function (config) {
  	    // We extend the config to let through (1) Scribe position markers,
  	    // otherwise we lose the caret position when running the Scribe content
  	    // through this sanitizer, and (2) BR elements which are needed by the
  	    // browser to ensure elements are selectable.
  	    var configAllowMarkers = merge(cloneDeep(config), {
  	      tags: {
  	        em: {class: 'scribe-marker', style: true},
  	        br: {}
  	      }
  	    });

  	    return function (scribe) {
  	      var janitor = new HTMLJanitor(configAllowMarkers);

  	      scribe.registerHTMLFormatter('sanitize', janitor.clean.bind(janitor));
  	    };
  	  };

  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 198 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
  	  {
  	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
  					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
  					(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
  					__WEBPACK_AMD_DEFINE_FACTORY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  	  }
  	}(this, function () {

  	  /**
  	   * @param {Object} config.tags Dictionary of allowed tags.
  	   * @param {boolean} config.keepNestedBlockElements Default false.
  	   */
  	  function HTMLJanitor(config) {

  	    var tagDefinitions = config['tags'];
  	    var tags = Object.keys(tagDefinitions);

  	    var validConfigValues = tags
  	      .map(function(k) { return typeof tagDefinitions[k]; })
  	      .every(function(type) { return type === 'object' || type === 'boolean' || type === 'function'; });

  	    if(!validConfigValues) {
  	      throw new Error("The configuration was invalid");
  	    }

  	    this.config = config;
  	  }

  	  // TODO: not exhaustive?
  	  var blockElementNames = ['P', 'LI', 'TD', 'TH', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'PRE'];
  	  function isBlockElement(node) {
  	    return blockElementNames.indexOf(node.nodeName) !== -1;
  	  }

  	  var inlineElementNames = ['A', 'B', 'STRONG', 'I', 'EM', 'SUB', 'SUP', 'U', 'STRIKE'];
  	  function isInlineElement(node) {
  	    return inlineElementNames.indexOf(node.nodeName) !== -1;
  	  }

  	  function isScribeMarker(node) {
  	    return node.nodeName === "EM" && node.outerHTML === '<em class="scribe-marker" style=""></em>';
  	  }

  	  HTMLJanitor.prototype.clean = function (html) {
  	    const sandbox = document.implementation.createHTMLDocument('');
  	    const root = sandbox.createElement("div");
  	    root.innerHTML = html;

  	    this._sanitize(sandbox, root);

  	    return root.innerHTML;
  	  };

  	  HTMLJanitor.prototype._sanitize = function (document, parentNode) {
  	    var treeWalker = createTreeWalker(document, parentNode);
  	    var node = treeWalker.firstChild();

  	    if (!node) { return; }

  	    do {
  	      if (node.nodeType === Node.TEXT_NODE) {
  	        // If this text node is just whitespace and the previous or next element
  	        // sibling is a block element, remove it
  	        // N.B.: This heuristic could change. Very specific to a bug with
  	        // `contenteditable` in Firefox: http://jsbin.com/EyuKase/1/edit?js,output
  	        // FIXME: make this an option?
  	        if (node.data.trim() === ''
  	            && ((node.previousElementSibling && isBlockElement(node.previousElementSibling))
  	                 || (node.nextElementSibling && isBlockElement(node.nextElementSibling)))) {
  	          parentNode.removeChild(node);
  	          this._sanitize(document, parentNode);
  	          break;
  	        } else {
  	          continue;
  	        }
  	      }

  	      // Remove all comments
  	      if (node.nodeType === Node.COMMENT_NODE) {
  	        parentNode.removeChild(node);
  	        this._sanitize(document, parentNode);
  	        break;
  	      }

  	      var isInline = isInlineElement(node);
  	      var containsBlockElement;
  	      if (isInline) {
  	        containsBlockElement = Array.prototype.some.call(node.childNodes, isBlockElement);
  	      }

  	      // Block elements should not be nested (e.g. <li><p>...); if
  	      // they are, we want to unwrap the inner block element.
  	      var isNotTopContainer = !! parentNode.parentNode;
  	      var isNestedBlockElement =
  	            isBlockElement(parentNode) &&
  	            isBlockElement(node) &&
  	            isNotTopContainer;

  	      var nodeName = node.nodeName.toLowerCase();

  	      var allowedAttrs = getAllowedAttrs(this.config, nodeName, node);

  	      var isInvalid = isInline && containsBlockElement;

  	      // Drop tag entirely according to the whitelist *and* if the markup
  	      // is invalid.
  	      if (isInvalid || shouldRejectNode(node, allowedAttrs)
  	          || (!this.config.keepNestedBlockElements && isNestedBlockElement)) {
  	        // Do not keep the inner text of SCRIPT/STYLE elements.
  	        if (! (node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE')) {
  	          while (node.childNodes.length > 0) {
  	            parentNode.insertBefore(node.childNodes[0], node);
  	          }
  	        }
  	        parentNode.removeChild(node);

  	        this._sanitize(document, parentNode);
  	        break;
  	      }
  	      
  	      if (!isScribeMarker(node)) {
  	        // Sanitize attributes
  	        for (var a = 0; a < node.attributes.length; a += 1) {
  	          var attr = node.attributes[a];

  	          if (shouldRejectAttr(attr, allowedAttrs, node)) {
  	            node.removeAttribute(attr.name);
  	            // Shift the array to continue looping.
  	            a = a - 1;
  	          }
  	        }
  	      }

  	      // Sanitize children
  	      this._sanitize(document, node);

  	    } while ((node = treeWalker.nextSibling()));
  	  };

  	  function createTreeWalker(document, node) {
  	    return document.createTreeWalker(node,
  	                                     NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,
  	                                     null, false);
  	  }

  	  function getAllowedAttrs(config, nodeName, node){
  	    if (typeof config.tags[nodeName] === 'function') {
  	      return config.tags[nodeName](node);
  	    } else {
  	      return config.tags[nodeName];
  	    }
  	  }

  	  function shouldRejectNode(node, allowedAttrs){
  	    if (typeof allowedAttrs === 'undefined') {
  	      return true;
  	    } else if (typeof allowedAttrs === 'boolean') {
  	      return !allowedAttrs;
  	    }

  	    return false;
  	  }

  	  function shouldRejectAttr(attr, allowedAttrs, node){
  	    var attrName = attr.name.toLowerCase();

  	    if (allowedAttrs === true){
  	      return false;
  	    } else if (typeof allowedAttrs[attrName] === 'function'){
  	      return !allowedAttrs[attrName](attr.value, node);
  	    } else if (typeof allowedAttrs[attrName] === 'undefined'){
  	      return true;
  	    } else if (allowedAttrs[attrName] === false) {
  	      return true;
  	    } else if (typeof allowedAttrs[attrName] === 'string') {
  	      return (allowedAttrs[attrName] !== attr.value);
  	    }

  	    return false;
  	  }

  	  return HTMLJanitor;

  	}));


  	/***/ }),
  	/* 199 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(200), __webpack_require__(211)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(baseMerge, createAssigner) {

  	  /**
  	   * Recursively merges own enumerable properties of the source object(s), that
  	   * don't resolve to `undefined` into the destination object. Subsequent sources
  	   * overwrite property assignments of previous sources. If `customizer` is
  	   * provided it is invoked to produce the merged values of the destination and
  	   * source properties. If `customizer` returns `undefined` merging is handled
  	   * by the method instead. The `customizer` is bound to `thisArg` and invoked
  	   * with five arguments; (objectValue, sourceValue, key, object, source).
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Object
  	   * @param {Object} object The destination object.
  	   * @param {...Object} [sources] The source objects.
  	   * @param {Function} [customizer] The function to customize merging properties.
  	   * @param {*} [thisArg] The `this` binding of `customizer`.
  	   * @returns {Object} Returns `object`.
  	   * @example
  	   *
  	   * var users = {
  	   *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
  	   * };
  	   *
  	   * var ages = {
  	   *   'data': [{ 'age': 36 }, { 'age': 40 }]
  	   * };
  	   *
  	   * _.merge(users, ages);
  	   * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
  	   *
  	   * // using a customizer callback
  	   * var object = {
  	   *   'fruits': ['apple'],
  	   *   'vegetables': ['beet']
  	   * };
  	   *
  	   * var other = {
  	   *   'fruits': ['banana'],
  	   *   'vegetables': ['carrot']
  	   * };
  	   *
  	   * _.merge(object, other, function(a, b) {
  	   *   if (_.isArray(a)) {
  	   *     return a.concat(b);
  	   *   }
  	   * });
  	   * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
  	   */
  	  var merge = createAssigner(baseMerge);

  	  return merge;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 200 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(71), __webpack_require__(72), __webpack_require__(206), __webpack_require__(20), __webpack_require__(7), __webpack_require__(14), __webpack_require__(15), __webpack_require__(78)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(arrayEach, baseForOwn, baseMergeDeep, isArray, isLength, isObject, isObjectLike, isTypedArray) {

  	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  	  var undefined$1;

  	  /**
  	   * The base implementation of `_.merge` without support for argument juggling,
  	   * multiple sources, and `this` binding `customizer` functions.
  	   *
  	   * @private
  	   * @param {Object} object The destination object.
  	   * @param {Object} source The source object.
  	   * @param {Function} [customizer] The function to customize merging properties.
  	   * @param {Array} [stackA=[]] Tracks traversed source objects.
  	   * @param {Array} [stackB=[]] Associates values with source counterparts.
  	   * @returns {Object} Returns the destination object.
  	   */
  	  function baseMerge(object, source, customizer, stackA, stackB) {
  	    if (!isObject(object)) {
  	      return object;
  	    }
  	    var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
  	    (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
  	      if (isObjectLike(srcValue)) {
  	        stackA || (stackA = []);
  	        stackB || (stackB = []);
  	        return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
  	      }
  	      var value = object[key],
  	          result = customizer ? customizer(value, srcValue, key, object, source) : undefined$1,
  	          isCommon = typeof result == 'undefined';

  	      if (isCommon) {
  	        result = srcValue;
  	      }
  	      if ((isSrcArr || typeof result != 'undefined') &&
  	          (isCommon || (result === result ? (result !== value) : (value === value)))) {
  	        object[key] = result;
  	      }
  	    });
  	    return object;
  	  }

  	  return baseMerge;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 201 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(14)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(isObject) {

  	  /**
  	   * Converts `value` to an object if it is not one.
  	   *
  	   * @private
  	   * @param {*} value The value to process.
  	   * @returns {Object} Returns the object.
  	   */
  	  function toObject(value) {
  	    return isObject(value) ? value : Object(value);
  	  }

  	  return toObject;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 202 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(203)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(baseToString) {

  	  /**
  	   * Used to match `RegExp` special characters.
  	   * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
  	   * for more details.
  	   */
  	  var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
  	      reHasRegExpChars = RegExp(reRegExpChars.source);

  	  /**
  	   * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
  	   * "+", "(", ")", "[", "]", "{" and "}" in `string`.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category String
  	   * @param {string} [string=''] The string to escape.
  	   * @returns {string} Returns the escaped string.
  	   * @example
  	   *
  	   * _.escapeRegExp('[lodash](https://lodash.com/)');
  	   * // => '\[lodash\]\(https://lodash\.com/\)'
  	   */
  	  function escapeRegExp(string) {
  	    string = baseToString(string);
  	    return (string && reHasRegExpChars.test(string))
  	      ? string.replace(reRegExpChars, '\\$&')
  	      : string;
  	  }

  	  return escapeRegExp;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 203 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /**
  	   * Converts `value` to a string if it is not one. An empty string is returned
  	   * for `null` or `undefined` values.
  	   *
  	   * @private
  	   * @param {*} value The value to process.
  	   * @returns {string} Returns the string.
  	   */
  	  function baseToString(value) {
  	    if (typeof value == 'string') {
  	      return value;
  	    }
  	    return value == null ? '' : (value + '');
  	  }

  	  return baseToString;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 204 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(36), __webpack_require__(20), __webpack_require__(37), __webpack_require__(7), __webpack_require__(38), __webpack_require__(75)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(isArguments, isArray, isIndex, isLength, keysIn, support) {

  	  /** Used for native method references. */
  	  var objectProto = Object.prototype;

  	  /** Used to check objects for own properties. */
  	  var hasOwnProperty = objectProto.hasOwnProperty;

  	  /**
  	   * A fallback implementation of `Object.keys` which creates an array of the
  	   * own enumerable property names of `object`.
  	   *
  	   * @private
  	   * @param {Object} object The object to inspect.
  	   * @returns {Array} Returns the array of property names.
  	   */
  	  function shimKeys(object) {
  	    var props = keysIn(object),
  	        propsLength = props.length,
  	        length = propsLength && object.length;

  	    var allowIndexes = length && isLength(length) &&
  	      (isArray(object) || (support.nonEnumArgs && isArguments(object)));

  	    var index = -1,
  	        result = [];

  	    while (++index < propsLength) {
  	      var key = props[index];
  	      if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
  	        result.push(key);
  	      }
  	    }
  	    return result;
  	  }

  	  return shimKeys;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 205 */
  	/***/ (function(module, exports) {

  	module.exports = function(module) {
  		if (!module.webpackPolyfill) {
  			module.deprecate = function() {};
  			module.paths = [];
  			// module.parent = undefined by default
  			if (!module.children) module.children = [];
  			Object.defineProperty(module, "loaded", {
  				enumerable: true,
  				get: function() {
  					return module.l;
  				}
  			});
  			Object.defineProperty(module, "id", {
  				enumerable: true,
  				get: function() {
  					return module.i;
  				}
  			});
  			module.webpackPolyfill = 1;
  		}
  		return module;
  	};


  	/***/ }),
  	/* 206 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(77), __webpack_require__(36), __webpack_require__(20), __webpack_require__(7), __webpack_require__(207), __webpack_require__(78), __webpack_require__(210)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(arrayCopy, isArguments, isArray, isLength, isPlainObject, isTypedArray, toPlainObject) {

  	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  	  var undefined$1;

  	  /**
  	   * A specialized version of `baseMerge` for arrays and objects which performs
  	   * deep merges and tracks traversed objects enabling objects with circular
  	   * references to be merged.
  	   *
  	   * @private
  	   * @param {Object} object The destination object.
  	   * @param {Object} source The source object.
  	   * @param {string} key The key of the value to merge.
  	   * @param {Function} mergeFunc The function to merge values.
  	   * @param {Function} [customizer] The function to customize merging properties.
  	   * @param {Array} [stackA=[]] Tracks traversed source objects.
  	   * @param {Array} [stackB=[]] Associates values with source counterparts.
  	   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
  	   */
  	  function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
  	    var length = stackA.length,
  	        srcValue = source[key];

  	    while (length--) {
  	      if (stackA[length] == srcValue) {
  	        object[key] = stackB[length];
  	        return;
  	      }
  	    }
  	    var value = object[key],
  	        result = customizer ? customizer(value, srcValue, key, object, source) : undefined$1,
  	        isCommon = typeof result == 'undefined';

  	    if (isCommon) {
  	      result = srcValue;
  	      if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
  	        result = isArray(value)
  	          ? value
  	          : (value ? arrayCopy(value) : []);
  	      }
  	      else if (isPlainObject(srcValue) || isArguments(srcValue)) {
  	        result = isArguments(value)
  	          ? toPlainObject(value)
  	          : (isPlainObject(value) ? value : {});
  	      }
  	      else {
  	        isCommon = false;
  	      }
  	    }
  	    // Add the source value to the stack of traversed objects and associate
  	    // it with its merged value.
  	    stackA.push(srcValue);
  	    stackB.push(result);

  	    if (isCommon) {
  	      // Recursively merge objects and arrays (susceptible to call stack limits).
  	      object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
  	    } else if (result === result ? (result !== value) : (value === value)) {
  	      object[key] = result;
  	    }
  	  }

  	  return baseMergeDeep;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 207 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19), __webpack_require__(208)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(isNative, shimIsPlainObject) {

  	  /** `Object#toString` result references. */
  	  var objectTag = '[object Object]';

  	  /** Used for native method references. */
  	  var objectProto = Object.prototype;

  	  /**
  	   * Used to resolve the `toStringTag` of values.
  	   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
  	   * for more details.
  	   */
  	  var objToString = objectProto.toString;

  	  /** Native method references. */
  	  var getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf;

  	  /**
  	   * Checks if `value` is a plain object, that is, an object created by the
  	   * `Object` constructor or one with a `[[Prototype]]` of `null`.
  	   *
  	   * **Note:** This method assumes objects created by the `Object` constructor
  	   * have no inherited enumerable properties.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Lang
  	   * @param {*} value The value to check.
  	   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
  	   * @example
  	   *
  	   * function Foo() {
  	   *   this.a = 1;
  	   * }
  	   *
  	   * _.isPlainObject(new Foo);
  	   * // => false
  	   *
  	   * _.isPlainObject([1, 2, 3]);
  	   * // => false
  	   *
  	   * _.isPlainObject({ 'x': 0, 'y': 0 });
  	   * // => true
  	   *
  	   * _.isPlainObject(Object.create(null));
  	   * // => true
  	   */
  	  var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
  	    if (!(value && objToString.call(value) == objectTag)) {
  	      return false;
  	    }
  	    var valueOf = value.valueOf,
  	        objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

  	    return objProto
  	      ? (value == objProto || getPrototypeOf(value) == objProto)
  	      : shimIsPlainObject(value);
  	  };

  	  return isPlainObject;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 208 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(209), __webpack_require__(15)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(baseForIn, isObjectLike) {

  	  /** `Object#toString` result references. */
  	  var objectTag = '[object Object]';

  	  /** Used for native method references. */
  	  var objectProto = Object.prototype;

  	  /** Used to check objects for own properties. */
  	  var hasOwnProperty = objectProto.hasOwnProperty;

  	  /**
  	   * Used to resolve the `toStringTag` of values.
  	   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
  	   * for more details.
  	   */
  	  var objToString = objectProto.toString;

  	  /**
  	   * A fallback implementation of `_.isPlainObject` which checks if `value`
  	   * is an object created by the `Object` constructor or has a `[[Prototype]]`
  	   * of `null`.
  	   *
  	   * @private
  	   * @param {*} value The value to check.
  	   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
  	   */
  	  function shimIsPlainObject(value) {
  	    var Ctor;

  	    // Exit early for non `Object` objects.
  	    if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
  	        (!hasOwnProperty.call(value, 'constructor') &&
  	          (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
  	      return false;
  	    }
  	    // IE < 9 iterates inherited properties before own properties. If the first
  	    // iterated property is an object's own property then there are no inherited
  	    // enumerable properties.
  	    var result;
  	    // In most environments an object's own properties are iterated before
  	    // its inherited properties. If the last iterated property is an object's
  	    // own property then there are no inherited enumerable properties.
  	    baseForIn(value, function(subValue, key) {
  	      result = key;
  	    });
  	    return typeof result == 'undefined' || hasOwnProperty.call(value, result);
  	  }

  	  return shimIsPlainObject;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 209 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(73), __webpack_require__(38)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(baseFor, keysIn) {

  	  /**
  	   * The base implementation of `_.forIn` without support for callback
  	   * shorthands and `this` binding.
  	   *
  	   * @private
  	   * @param {Object} object The object to iterate over.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @returns {Object} Returns `object`.
  	   */
  	  function baseForIn(object, iteratee) {
  	    return baseFor(object, iteratee, keysIn);
  	  }

  	  return baseForIn;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 210 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(79), __webpack_require__(38)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(baseCopy, keysIn) {

  	  /**
  	   * Converts `value` to a plain object flattening inherited enumerable
  	   * properties of `value` to own properties of the plain object.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Lang
  	   * @param {*} value The value to convert.
  	   * @returns {Object} Returns the converted plain object.
  	   * @example
  	   *
  	   * function Foo() {
  	   *   this.b = 2;
  	   * }
  	   *
  	   * Foo.prototype.c = 3;
  	   *
  	   * _.assign({ 'a': 1 }, new Foo);
  	   * // => { 'a': 1, 'b': 2 }
  	   *
  	   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
  	   * // => { 'a': 1, 'b': 2, 'c': 3 }
  	   */
  	  function toPlainObject(value) {
  	    return baseCopy(value, keysIn(value));
  	  }

  	  return toPlainObject;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 211 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(80), __webpack_require__(213)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(bindCallback, isIterateeCall) {

  	  /**
  	   * Creates a function that assigns properties of source object(s) to a given
  	   * destination object.
  	   *
  	   * @private
  	   * @param {Function} assigner The function to assign values.
  	   * @returns {Function} Returns the new assigner function.
  	   */
  	  function createAssigner(assigner) {
  	    return function() {
  	      var args = arguments,
  	          length = args.length,
  	          object = args[0];

  	      if (length < 2 || object == null) {
  	        return object;
  	      }
  	      var customizer = args[length - 2],
  	          thisArg = args[length - 1],
  	          guard = args[3];

  	      if (length > 3 && typeof customizer == 'function') {
  	        customizer = bindCallback(customizer, thisArg, 5);
  	        length -= 2;
  	      } else {
  	        customizer = (length > 2 && typeof thisArg == 'function') ? thisArg : null;
  	        length -= (customizer ? 1 : 0);
  	      }
  	      if (guard && isIterateeCall(args[1], args[2], guard)) {
  	        customizer = length == 3 ? null : customizer;
  	        length = 2;
  	      }
  	      var index = 0;
  	      while (++index < length) {
  	        var source = args[index];
  	        if (source) {
  	          assigner(object, source, customizer);
  	        }
  	      }
  	      return object;
  	    };
  	  }

  	  return createAssigner;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 212 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /**
  	   * This method returns the first argument provided to it.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Utility
  	   * @param {*} value Any value.
  	   * @returns {*} Returns `value`.
  	   * @example
  	   *
  	   * var object = { 'user': 'fred' };
  	   *
  	   * _.identity(object) === object;
  	   * // => true
  	   */
  	  function identity(value) {
  	    return value;
  	  }

  	  return identity;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 213 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(37), __webpack_require__(7), __webpack_require__(14)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(isIndex, isLength, isObject) {

  	  /**
  	   * Checks if the provided arguments are from an iteratee call.
  	   *
  	   * @private
  	   * @param {*} value The potential iteratee value argument.
  	   * @param {*} index The potential iteratee index or key argument.
  	   * @param {*} object The potential iteratee object argument.
  	   * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
  	   */
  	  function isIterateeCall(value, index, object) {
  	    if (!isObject(object)) {
  	      return false;
  	    }
  	    var type = typeof index;
  	    if (type == 'number') {
  	      var length = object.length,
  	          prereq = isLength(length) && isIndex(index, length);
  	    } else {
  	      prereq = type == 'string' && index in object;
  	    }
  	    if (prereq) {
  	      var other = object[index];
  	      return value === value ? (value === other) : (other !== other);
  	    }
  	    return false;
  	  }

  	  return isIterateeCall;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 214 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(215), __webpack_require__(80)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(baseClone, bindCallback) {

  	  /**
  	   * Creates a deep clone of `value`. If `customizer` is provided it is invoked
  	   * to produce the cloned values. If `customizer` returns `undefined` cloning
  	   * is handled by the method instead. The `customizer` is bound to `thisArg`
  	   * and invoked with two argument; (value [, index|key, object]).
  	   *
  	   * **Note:** This method is loosely based on the structured clone algorithm.
  	   * The enumerable properties of `arguments` objects and objects created by
  	   * constructors other than `Object` are cloned to plain `Object` objects. An
  	   * empty object is returned for uncloneable values such as functions, DOM nodes,
  	   * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
  	   * for more details.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Lang
  	   * @param {*} value The value to deep clone.
  	   * @param {Function} [customizer] The function to customize cloning values.
  	   * @param {*} [thisArg] The `this` binding of `customizer`.
  	   * @returns {*} Returns the deep cloned value.
  	   * @example
  	   *
  	   * var users = [
  	   *   { 'user': 'barney' },
  	   *   { 'user': 'fred' }
  	   * ];
  	   *
  	   * var deep = _.cloneDeep(users);
  	   * deep[0] === users[0];
  	   * // => false
  	   *
  	   * // using a customizer callback
  	   * var el = _.cloneDeep(document.body, function(value) {
  	   *   if (_.isElement(value)) {
  	   *     return value.cloneNode(true);
  	   *   }
  	   * });
  	   *
  	   * el === document.body
  	   * // => false
  	   * el.nodeName
  	   * // => BODY
  	   * el.childNodes.length;
  	   * // => 20
  	   */
  	  function cloneDeep(value, customizer, thisArg) {
  	    customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
  	    return baseClone(value, true, customizer);
  	  }

  	  return cloneDeep;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 215 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(77), __webpack_require__(71), __webpack_require__(79), __webpack_require__(72), __webpack_require__(216), __webpack_require__(217), __webpack_require__(220), __webpack_require__(20), __webpack_require__(14), __webpack_require__(74)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(arrayCopy, arrayEach, baseCopy, baseForOwn, initCloneArray, initCloneByTag, initCloneObject, isArray, isObject, keys) {

  	  /** `Object#toString` result references. */
  	  var argsTag = '[object Arguments]',
  	      arrayTag = '[object Array]',
  	      boolTag = '[object Boolean]',
  	      dateTag = '[object Date]',
  	      errorTag = '[object Error]',
  	      funcTag = '[object Function]',
  	      mapTag = '[object Map]',
  	      numberTag = '[object Number]',
  	      objectTag = '[object Object]',
  	      regexpTag = '[object RegExp]',
  	      setTag = '[object Set]',
  	      stringTag = '[object String]',
  	      weakMapTag = '[object WeakMap]';

  	  var arrayBufferTag = '[object ArrayBuffer]',
  	      float32Tag = '[object Float32Array]',
  	      float64Tag = '[object Float64Array]',
  	      int8Tag = '[object Int8Array]',
  	      int16Tag = '[object Int16Array]',
  	      int32Tag = '[object Int32Array]',
  	      uint8Tag = '[object Uint8Array]',
  	      uint8ClampedTag = '[object Uint8ClampedArray]',
  	      uint16Tag = '[object Uint16Array]',
  	      uint32Tag = '[object Uint32Array]';

  	  /** Used to identify `toStringTag` values supported by `_.clone`. */
  	  var cloneableTags = {};
  	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  	  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  	  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  	  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  	  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  	  cloneableTags[numberTag] = cloneableTags[objectTag] =
  	  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  	  cloneableTags[errorTag] = cloneableTags[funcTag] =
  	  cloneableTags[mapTag] = cloneableTags[setTag] =
  	  cloneableTags[weakMapTag] = false;

  	  /** Used for native method references. */
  	  var objectProto = Object.prototype;

  	  /**
  	   * Used to resolve the `toStringTag` of values.
  	   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
  	   * for more details.
  	   */
  	  var objToString = objectProto.toString;

  	  /**
  	   * The base implementation of `_.clone` without support for argument juggling
  	   * and `this` binding `customizer` functions.
  	   *
  	   * @private
  	   * @param {*} value The value to clone.
  	   * @param {boolean} [isDeep] Specify a deep clone.
  	   * @param {Function} [customizer] The function to customize cloning values.
  	   * @param {string} [key] The key of `value`.
  	   * @param {Object} [object] The object `value` belongs to.
  	   * @param {Array} [stackA=[]] Tracks traversed source objects.
  	   * @param {Array} [stackB=[]] Associates clones with source counterparts.
  	   * @returns {*} Returns the cloned value.
  	   */
  	  function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
  	    var result;
  	    if (customizer) {
  	      result = object ? customizer(value, key, object) : customizer(value);
  	    }
  	    if (typeof result != 'undefined') {
  	      return result;
  	    }
  	    if (!isObject(value)) {
  	      return value;
  	    }
  	    var isArr = isArray(value);
  	    if (isArr) {
  	      result = initCloneArray(value);
  	      if (!isDeep) {
  	        return arrayCopy(value, result);
  	      }
  	    } else {
  	      var tag = objToString.call(value),
  	          isFunc = tag == funcTag;

  	      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
  	        result = initCloneObject(isFunc ? {} : value);
  	        if (!isDeep) {
  	          return baseCopy(value, result, keys(value));
  	        }
  	      } else {
  	        return cloneableTags[tag]
  	          ? initCloneByTag(value, tag, isDeep)
  	          : (object ? value : {});
  	      }
  	    }
  	    // Check for circular references and return corresponding clone.
  	    stackA || (stackA = []);
  	    stackB || (stackB = []);

  	    var length = stackA.length;
  	    while (length--) {
  	      if (stackA[length] == value) {
  	        return stackB[length];
  	      }
  	    }
  	    // Add the source value to the stack of traversed objects and associate it with its clone.
  	    stackA.push(value);
  	    stackB.push(result);

  	    // Recursively populate clone (susceptible to call stack limits).
  	    (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
  	      result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
  	    });
  	    return result;
  	  }

  	  return baseClone;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 216 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /** Used for native method references. */
  	  var objectProto = Object.prototype;

  	  /** Used to check objects for own properties. */
  	  var hasOwnProperty = objectProto.hasOwnProperty;

  	  /**
  	   * Initializes an array clone.
  	   *
  	   * @private
  	   * @param {Array} array The array to clone.
  	   * @returns {Array} Returns the initialized clone.
  	   */
  	  function initCloneArray(array) {
  	    var length = array.length,
  	        result = new array.constructor(length);

  	    // Add array properties assigned by `RegExp#exec`.
  	    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
  	      result.index = array.index;
  	      result.input = array.input;
  	    }
  	    return result;
  	  }

  	  return initCloneArray;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 217 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(218)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(bufferClone) {

  	  /** `Object#toString` result references. */
  	  var boolTag = '[object Boolean]',
  	      dateTag = '[object Date]',
  	      numberTag = '[object Number]',
  	      regexpTag = '[object RegExp]',
  	      stringTag = '[object String]';

  	  var arrayBufferTag = '[object ArrayBuffer]',
  	      float32Tag = '[object Float32Array]',
  	      float64Tag = '[object Float64Array]',
  	      int8Tag = '[object Int8Array]',
  	      int16Tag = '[object Int16Array]',
  	      int32Tag = '[object Int32Array]',
  	      uint8Tag = '[object Uint8Array]',
  	      uint8ClampedTag = '[object Uint8ClampedArray]',
  	      uint16Tag = '[object Uint16Array]',
  	      uint32Tag = '[object Uint32Array]';

  	  /** Used to match `RegExp` flags from their coerced string values. */
  	  var reFlags = /\w*$/;

  	  /**
  	   * Initializes an object clone based on its `toStringTag`.
  	   *
  	   * **Note:** This function only supports cloning values with tags of
  	   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
  	   *
  	   *
  	   * @private
  	   * @param {Object} object The object to clone.
  	   * @param {string} tag The `toStringTag` of the object to clone.
  	   * @param {boolean} [isDeep] Specify a deep clone.
  	   * @returns {Object} Returns the initialized clone.
  	   */
  	  function initCloneByTag(object, tag, isDeep) {
  	    var Ctor = object.constructor;
  	    switch (tag) {
  	      case arrayBufferTag:
  	        return bufferClone(object);

  	      case boolTag:
  	      case dateTag:
  	        return new Ctor(+object);

  	      case float32Tag: case float64Tag:
  	      case int8Tag: case int16Tag: case int32Tag:
  	      case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
  	        var buffer = object.buffer;
  	        return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

  	      case numberTag:
  	      case stringTag:
  	        return new Ctor(object);

  	      case regexpTag:
  	        var result = new Ctor(object.source, reFlags.exec(object));
  	        result.lastIndex = object.lastIndex;
  	    }
  	    return result;
  	  }

  	  return initCloneByTag;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 218 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(219), __webpack_require__(19), __webpack_require__(76)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(constant, isNative, root) {

  	  /** Native method references. */
  	  var ArrayBuffer = isNative(ArrayBuffer = root.ArrayBuffer) && ArrayBuffer,
  	      bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
  	      floor = Math.floor,
  	      Uint8Array = isNative(Uint8Array = root.Uint8Array) && Uint8Array;

  	  /** Used to clone array buffers. */
  	  var Float64Array = (function() {
  	    // Safari 5 errors when using an array buffer to initialize a typed array
  	    // where the array buffer's `byteLength` is not a multiple of the typed
  	    // array's `BYTES_PER_ELEMENT`.
  	    try {
  	      var func = isNative(func = root.Float64Array) && func,
  	          result = new func(new ArrayBuffer(10), 0, 1) && func;
  	    } catch(e) {}
  	    return result;
  	  }());

  	  /** Used as the size, in bytes, of each `Float64Array` element. */
  	  var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

  	  /**
  	   * Creates a clone of the given array buffer.
  	   *
  	   * @private
  	   * @param {ArrayBuffer} buffer The array buffer to clone.
  	   * @returns {ArrayBuffer} Returns the cloned array buffer.
  	   */
  	  function bufferClone(buffer) {
  	    return bufferSlice.call(buffer, 0);
  	  }
  	  if (!bufferSlice) {
  	    // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
  	    bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
  	      var byteLength = buffer.byteLength,
  	          floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
  	          offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
  	          result = new ArrayBuffer(byteLength);

  	      if (floatLength) {
  	        var view = new Float64Array(result, 0, floatLength);
  	        view.set(new Float64Array(buffer, 0, floatLength));
  	      }
  	      if (byteLength != offset) {
  	        view = new Uint8Array(result, offset);
  	        view.set(new Uint8Array(buffer, offset));
  	      }
  	      return result;
  	    };
  	  }

  	  return bufferClone;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 219 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /**
  	   * Creates a function that returns `value`.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @category Utility
  	   * @param {*} value The value to return from the new function.
  	   * @returns {Function} Returns the new function.
  	   * @example
  	   *
  	   * var object = { 'user': 'fred' };
  	   * var getter = _.constant(object);
  	   *
  	   * getter() === object;
  	   * // => true
  	   */
  	  function constant(value) {
  	    return function() {
  	      return value;
  	    };
  	  }

  	  return constant;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 220 */
  	/***/ (function(module, exports, __webpack_require__) {

  	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {

  	  /**
  	   * Initializes an object clone.
  	   *
  	   * @private
  	   * @param {Object} object The object to clone.
  	   * @returns {Object} Returns the initialized clone.
  	   */
  	  function initCloneObject(object) {
  	    var Ctor = object.constructor;
  	    if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
  	      Ctor = Object;
  	    }
  	    return new Ctor;
  	  }

  	  return initCloneObject;
  	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


  	/***/ }),
  	/* 221 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var selectionRange = __webpack_require__(13);

  	var _require = __webpack_require__(16),
  	    createBlocksFromParagraphs = _require.createBlocksFromParagraphs,
  	    getTotalLength = _require.getTotalLength;

  	module.exports = {
  	  mixinName: 'Textable',
  	  initializeTextable: function initializeTextable() {
  	    this.el.classList.add('st-block--textable');
  	  },
  	  focusAtEnd: function focusAtEnd() {
  	    this.focus();
  	    var length = getTotalLength(this._scribe);

  	    if (length > 0) {
  	      selectionRange(this._scribe.el, {
  	        start: length
  	      });
  	    }
  	  },
  	  selectText: function selectText() {
  	    var range = document.createRange();

  	    if (this._scribe.allowsBlockElements()) {
  	      range.setStartAfter(this._scribe.el.firstChild, 0);
  	    } else {
  	      range.selectNodeContents(this._scribe.el);
  	    }

  	    range.collapse(false);
  	    var selection = new this._scribe.api.Selection();
  	    selection.selection.removeAllRanges();
  	    selection.selection.addRange(range);
  	  },
  	  getScribeInnerContent: function getScribeInnerContent(block) {
  	    var content = '';

  	    if (this._scribe.getTextContent() !== '') {
  	      var fakeContent = document.createElement('div');
  	      fakeContent.innerHTML = this.getTextBlockHTML(); // We concatenate the content of each paragraph and take into account the new lines

  	      content = fakeContent.children && Array.prototype.slice.call(fakeContent.children).reduce(function (res, child) {
  	        return res + child.innerHTML;
  	      }, '') || fakeContent.innerHTML;
  	      return content.replace(/^[\s\uFEFF\xA0]+|$/g, '');
  	    }

  	    return content;
  	  },
  	  getCaretPositionAtEnd: function getCaretPositionAtEnd() {
  	    this.selectText();
  	    return selectionRange(this._scribe.el);
  	  },
  	  appendContent: function appendContent(content, options) {
  	    options = options || {};
  	    this.focusAtEnd();
  	    var caretPosition = this.getCaretPositionAtEnd();
  	    var currentContent = this.getScribeInnerContent();

  	    if (currentContent !== '') {
  	      content = currentContent + content;
  	    }

  	    if (content === '') {
  	      if (!window.navigator.userAgent.match(/MSIE 10/)) {
  	        content = '<br>';
  	      }
  	    }

  	    this.setTextBlockHTML(content);
  	    this.focus();

  	    if (options.keepCaretPosition && caretPosition.start !== 0 && caretPosition.end !== 0) {
  	      selectionRange(this._scribe.el, {
  	        start: caretPosition.start,
  	        end: caretPosition.end
  	      });
  	    }
  	  },
  	  split: function split() {
  	    createBlocksFromParagraphs(this, this._scribe);
  	  }
  	};

  	/***/ }),
  	/* 222 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/*
  	  Text Block
  	*/

  	var Block = __webpack_require__(8);

  	var stToHTML = __webpack_require__(22);

  	var ScribeTextBlockPlugin = __webpack_require__(90);

  	var ScribePastePlugin = __webpack_require__(228);

  	var ScribeHeadingPlugin = __webpack_require__(40);

  	var ScribeQuotePlugin = __webpack_require__(41);

  	module.exports = Block.extend({
  	  type: "text",
  	  editorHTML: '<div class="st-text-block" contenteditable="true"></div>',
  	  icon_name: 'text',
  	  mergeable: true,
  	  textable: true,
  	  toolbarEnabled: false,
  	  configureScribe: function configureScribe(scribe) {
  	    scribe.use(new ScribeTextBlockPlugin(this));
  	    scribe.use(new ScribePastePlugin(this));
  	    scribe.use(new ScribeHeadingPlugin(this));
  	    scribe.use(new ScribeQuotePlugin(this));
  	    scribe.on('content-changed', this.toggleEmptyClass.bind(this));
  	  },
  	  scribeOptions: {
  	    allowBlockElements: true,
  	    tags: {
  	      p: true
  	    }
  	  },
  	  loadData: function loadData(data) {
  	    if (this.options.convertFromMarkdown && data.format !== "html") {
  	      this.setTextBlockHTML(stToHTML(data.text, this.type));
  	    } else {
  	      this.setTextBlockHTML(data.text);
  	    }
  	  },
  	  onBlockRender: function onBlockRender() {
  	    this.toggleEmptyClass();
  	  },
  	  toggleEmptyClass: function toggleEmptyClass() {
  	    this.el.classList.toggle('st-block--empty', this.isEmpty());
  	  },
  	  isEmpty: function isEmpty() {
  	    return this._scribe.getTextContent() === '';
  	  },
  	  asClipboardHTML: function asClipboardHTML() {
  	    var data = this.getBlockData();
  	    return "".concat(data.text);
  	  }
  	});

  	/***/ }),
  	/* 223 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var BLOCK_ADDITION_TOP_TEMPLATE = __webpack_require__(224);

  	var BLOCK_ADDITION_TEMPLATE = __webpack_require__(88);

  	var BLOCK_REPLACER_TEMPLATE = __webpack_require__(225);

  	module.exports = function (editor_html) {
  	  return "\n    <div class='st-block__inner'>\n      ".concat(editor_html, "\n    </div>\n    ").concat(BLOCK_REPLACER_TEMPLATE(), "\n    ").concat(BLOCK_ADDITION_TOP_TEMPLATE(), "\n    ").concat(BLOCK_ADDITION_TEMPLATE(), "\n  ");
  	};

  	/***/ }),
  	/* 224 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var config = __webpack_require__(2);

  	module.exports = function () {
  	  return "\n    <div class=\"st-block-addition-top\">\n      <div class=\"st-block-addition-top__button\" type=\"button\"></div>\n      <div class=\"st-block-addition-top__icon\">\n        <svg role=\"img\" class=\"st-icon\">\n          <use xlink:href=\"".concat(config.defaults.iconUrl, "#add-block\"/>\n        </svg>\n      </div>\n    </div>\n  ");
  	};

  	/***/ }),
  	/* 225 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var config = __webpack_require__(2);

  	module.exports = function () {
  	  return "\n    <button class=\"st-block-replacer\" type=\"button\">\n      <span class=\"st-block-replacer__button\">\n        <svg role=\"img\" class=\"st-icon\">\n          <use xlink:href=\"".concat(config.defaults.iconUrl, "#add-block\"/>\n        </svg>\n      </span>\n    </button>\n  ");
  	};

  	/***/ }),
  	/* 226 */
  	/***/ (function(module, __webpack_exports__, __webpack_require__) {
  	__webpack_require__.r(__webpack_exports__);
  	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spinner", function() { return Spinner; });
  	var __assign = Object.assign || function(t) {
  	    for (var s, i = 1, n = arguments.length; i < n; i++) {
  	        s = arguments[i];
  	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
  	            t[p] = s[p];
  	    }
  	    return t;
  	};
  	var defaults = {
  	    lines: 12,
  	    length: 7,
  	    width: 5,
  	    radius: 10,
  	    scale: 1.0,
  	    corners: 1,
  	    color: '#000',
  	    fadeColor: 'transparent',
  	    animation: 'spinner-line-fade-default',
  	    rotate: 0,
  	    direction: 1,
  	    speed: 1,
  	    zIndex: 2e9,
  	    className: 'spinner',
  	    top: '50%',
  	    left: '50%',
  	    shadow: '0 0 1px transparent',
  	    position: 'absolute',
  	};
  	var Spinner = /** @class */ (function () {
  	    function Spinner(opts) {
  	        if (opts === void 0) { opts = {}; }
  	        this.opts = __assign({}, defaults, opts);
  	    }
  	    /**
  	     * Adds the spinner to the given target element. If this instance is already
  	     * spinning, it is automatically removed from its previous target by calling
  	     * stop() internally.
  	     */
  	    Spinner.prototype.spin = function (target) {
  	        this.stop();
  	        this.el = document.createElement('div');
  	        this.el.className = this.opts.className;
  	        this.el.setAttribute('role', 'progressbar');
  	        css(this.el, {
  	            position: this.opts.position,
  	            width: 0,
  	            zIndex: this.opts.zIndex,
  	            left: this.opts.left,
  	            top: this.opts.top,
  	            transform: "scale(" + this.opts.scale + ")",
  	        });
  	        if (target) {
  	            target.insertBefore(this.el, target.firstChild || null);
  	        }
  	        drawLines(this.el, this.opts);
  	        return this;
  	    };
  	    /**
  	     * Stops and removes the Spinner.
  	     * Stopped spinners may be reused by calling spin() again.
  	     */
  	    Spinner.prototype.stop = function () {
  	        if (this.el) {
  	            if (typeof requestAnimationFrame !== 'undefined') {
  	                cancelAnimationFrame(this.animateId);
  	            }
  	            else {
  	                clearTimeout(this.animateId);
  	            }
  	            if (this.el.parentNode) {
  	                this.el.parentNode.removeChild(this.el);
  	            }
  	            this.el = undefined;
  	        }
  	        return this;
  	    };
  	    return Spinner;
  	}());

  	/**
  	 * Sets multiple style properties at once.
  	 */
  	function css(el, props) {
  	    for (var prop in props) {
  	        el.style[prop] = props[prop];
  	    }
  	    return el;
  	}
  	/**
  	 * Returns the line color from the given string or array.
  	 */
  	function getColor(color, idx) {
  	    return typeof color == 'string' ? color : color[idx % color.length];
  	}
  	/**
  	 * Internal method that draws the individual lines.
  	 */
  	function drawLines(el, opts) {
  	    var borderRadius = (Math.round(opts.corners * opts.width * 500) / 1000) + 'px';
  	    var shadow = 'none';
  	    if (opts.shadow === true) {
  	        shadow = '0 2px 4px #000'; // default shadow
  	    }
  	    else if (typeof opts.shadow === 'string') {
  	        shadow = opts.shadow;
  	    }
  	    var shadows = parseBoxShadow(shadow);
  	    for (var i = 0; i < opts.lines; i++) {
  	        var degrees = ~~(360 / opts.lines * i + opts.rotate);
  	        var backgroundLine = css(document.createElement('div'), {
  	            position: 'absolute',
  	            top: -opts.width / 2 + "px",
  	            width: (opts.length + opts.width) + 'px',
  	            height: opts.width + 'px',
  	            background: getColor(opts.fadeColor, i),
  	            borderRadius: borderRadius,
  	            transformOrigin: 'left',
  	            transform: "rotate(" + degrees + "deg) translateX(" + opts.radius + "px)",
  	        });
  	        var delay = i * opts.direction / opts.lines / opts.speed;
  	        delay -= 1 / opts.speed; // so initial animation state will include trail
  	        var line = css(document.createElement('div'), {
  	            width: '100%',
  	            height: '100%',
  	            background: getColor(opts.color, i),
  	            borderRadius: borderRadius,
  	            boxShadow: normalizeShadow(shadows, degrees),
  	            animation: 1 / opts.speed + "s linear " + delay + "s infinite " + opts.animation,
  	        });
  	        backgroundLine.appendChild(line);
  	        el.appendChild(backgroundLine);
  	    }
  	}
  	function parseBoxShadow(boxShadow) {
  	    var regex = /^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/;
  	    var shadows = [];
  	    for (var _i = 0, _a = boxShadow.split(','); _i < _a.length; _i++) {
  	        var shadow = _a[_i];
  	        var matches = shadow.match(regex);
  	        if (matches === null) {
  	            continue; // invalid syntax
  	        }
  	        var x = +matches[2];
  	        var y = +matches[5];
  	        var xUnits = matches[4];
  	        var yUnits = matches[7];
  	        if (x === 0 && !xUnits) {
  	            xUnits = yUnits;
  	        }
  	        if (y === 0 && !yUnits) {
  	            yUnits = xUnits;
  	        }
  	        if (xUnits !== yUnits) {
  	            continue; // units must match to use as coordinates
  	        }
  	        shadows.push({
  	            prefix: matches[1] || '',
  	            x: x,
  	            y: y,
  	            xUnits: xUnits,
  	            yUnits: yUnits,
  	            end: matches[8],
  	        });
  	    }
  	    return shadows;
  	}
  	/**
  	 * Modify box-shadow x/y offsets to counteract rotation
  	 */
  	function normalizeShadow(shadows, degrees) {
  	    var normalized = [];
  	    for (var _i = 0, shadows_1 = shadows; _i < shadows_1.length; _i++) {
  	        var shadow = shadows_1[_i];
  	        var xy = convertOffset(shadow.x, shadow.y, degrees);
  	        normalized.push(shadow.prefix + xy[0] + shadow.xUnits + ' ' + xy[1] + shadow.yUnits + shadow.end);
  	    }
  	    return normalized.join(', ');
  	}
  	function convertOffset(x, y, degrees) {
  	    var radians = degrees * Math.PI / 180;
  	    var sin = Math.sin(radians);
  	    var cos = Math.cos(radians);
  	    return [
  	        Math.round((x * cos + y * sin) * 1000) / 1000,
  	        Math.round((-x * sin + y * cos) * 1000) / 1000,
  	    ];
  	}


  	/***/ }),
  	/* 227 */
  	/***/ (function(module, exports, __webpack_require__) {


  	module.exports = function () {
  	  return "\n    <div class=\"st-block__ui-delete-controls\">\n      <label class=\"st-block__delete-label\">\n        ".concat(i18n.t('general:delete'), "\n      </label>\n      <button class='st-block-ui__confirm js-st-block-confirm-delete' type=\"button\">\n        ").concat(i18n.t('general:yes'), "\n      </button>\n      <button class='st-block-ui__confirm js-st-block-deny-delete' type=\"button\">\n        ").concat(i18n.t('general:no'), "\n      </button>\n    </div>\n  ");
  	};

  	/***/ }),
  	/* 228 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/*
  	When content is pasted into a block take the sanitized html and create a block for each
  	paragraph that has been added.
  	*/

  	function createListBlock(block, listItems) {
  	  var listItemContent = listItems.map(function (listItemNode) {
  	    var content = listItemNode.innerHTML.substr(2);
  	    return {
  	      content: content
  	    };
  	  });
  	  var listData = {
  	    format: 'html',
  	    listItems: listItemContent.reverse()
  	  };
  	  block.mediator.trigger("block:create", 'List', listData, block.el, {
  	    autoFocus: true
  	  });
  	}

  	function handleListItems(block, listItemsToCreate) {
  	  if (listItemsToCreate.length > 0) {
  	    createListBlock(block, listItemsToCreate);
  	  }

  	  return [];
  	} // In firefox when you paste any text is wraps in a paragraph block which we don't want.


  	function removeWrappingParagraphForFirefox(value) {
  	  var fakeContent = document.createElement('div');
  	  fakeContent.innerHTML = value;

  	  if (fakeContent.childNodes.length === 1) {
  	    var node = [].slice.call(fakeContent.childNodes)[0];

  	    if (node && node.nodeName === "P") {
  	      value = node.innerHTML;
  	    }
  	  }

  	  return value;
  	}

  	var scribePastePlugin = function scribePastePlugin(block) {
  	  function isMsWordListParagraph(node) {
  	    if (block.editorOptions.blockTypes.indexOf("List") === -1) return false;
  	    var matchingClassnames = node.className.split(" ").filter(function (className) {
  	      return className.startsWith("MsoListParagraph");
  	    });
  	    return matchingClassnames.length > 0;
  	  }

  	  return function (scribe) {
  	    var insertHTMLCommandPatch = new scribe.api.CommandPatch('insertHTML');

  	    insertHTMLCommandPatch.execute = function (value) {
  	      var _this = this;

  	      scribe.transactionManager.run(function () {
  	        value = removeWrappingParagraphForFirefox(value);
  	        scribe.api.CommandPatch.prototype.execute.call(_this, value);
  	        var fakeContent = document.createElement('div');
  	        fakeContent.innerHTML = scribe.getContent();

  	        if (fakeContent.childNodes.length > 1) {
  	          var assignBlockToFocus = function assignBlockToFocus(focusBlock) {
  	            blockToFocus = focusBlock;
  	            block.mediator.off("block:created", assignBlockToFocus);
  	          };

  	          var nodes = [].slice.call(fakeContent.childNodes);
  	          var listItemsToCreate = [];
  	          var listIsFirstItem = false;
  	          var blockToFocus;
  	          var firstNode = nodes[0];

  	          if (isMsWordListParagraph(firstNode)) {
  	            listIsFirstItem = true;
  	            scribe.setContent("");
  	          } else {
  	            scribe.setContent(nodes.shift().innerHTML);
  	          }

  	          block.mediator.on("block:created", assignBlockToFocus);
  	          nodes.reverse().forEach(function (node) {
  	            if (isMsWordListParagraph(node)) {
  	              // Start building list
  	              listItemsToCreate.push(node);
  	            } else {
  	              // Previous blocks were list items, so create the list block first
  	              listItemsToCreate = handleListItems(block, listItemsToCreate); // Now create the text block

  	              var data = {
  	                format: 'html',
  	                text: node.innerHTML
  	              };
  	              block.mediator.trigger("block:create", 'Text', data, block.el, {
  	                autoFocus: true
  	              });
  	            }
  	          }); // If the last element was a list item, the list won't have been
  	          // created yet, so create it now

  	          listItemsToCreate = handleListItems(block, listItemsToCreate);

  	          if (listIsFirstItem) {
  	            block.mediator.trigger("block:remove", block.blockID);
  	          }

  	          blockToFocus.focusAtEnd();
  	        } else {
  	          var node = fakeContent.firstChild;

  	          if (isMsWordListParagraph(node)) {
  	            scribe.setContent("");
  	            createListBlock(block, [node]);
  	            block.mediator.trigger("block:remove", block.blockID);
  	          }
  	        }
  	      });
  	    };

  	    scribe.commandPatches.insertHTML = insertHTMLCommandPatch;
  	  };
  	};

  	module.exports = scribePastePlugin;

  	/***/ }),
  	/* 229 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/*
  	  Block Quote
  	*/

  	var _ = __webpack_require__(0);

  	var Block = __webpack_require__(8);

  	var stToHTML = __webpack_require__(22);

  	var ScribeHeadingPlugin = __webpack_require__(40);

  	var ScribeQuotePlugin = __webpack_require__(41);

  	var template = _.template(['<blockquote class="st-required st-text-block st-text-block--quote" contenteditable="true"></blockquote>', '<label class="st-input-label"> <%= i18n.t("blocks:quote:credit_field") %></label>', '<input maxlength="140" name="cite" placeholder="<%= i18n.t("blocks:quote:credit_field") %>"', ' class="st-input-string js-cite-input" type="text" />'].join("\n"));

  	module.exports = Block.extend({
  	  type: "quote",
  	  icon_name: 'quote',
  	  mergeable: true,
  	  textable: true,
  	  toolbarEnabled: false,
  	  editorHTML: function editorHTML() {
  	    return template(this);
  	  },
  	  configureScribe: function configureScribe(scribe) {
  	    scribe.use(new ScribeHeadingPlugin(this));
  	    scribe.use(new ScribeQuotePlugin(this));
  	  },
  	  loadData: function loadData(data) {
  	    if (this.options.convertFromMarkdown && data.format !== "html") {
  	      this.setTextBlockHTML(stToHTML(data.text, this.type));
  	    } else {
  	      this.setTextBlockHTML(data.text);
  	    }

  	    if (data.cite) {
  	      this.$('.js-cite-input')[0].value = data.cite;
  	    }
  	  },
  	  asClipboardHTML: function asClipboardHTML() {
  	    var data = this.getBlockData();
  	    return "<blockquote>".concat(data.text, "<cite>- ").concat(data.cite, "</cite></blockquote>");
  	  }
  	});

  	/***/ }),
  	/* 230 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var Dom = __webpack_require__(3);

  	var Block = __webpack_require__(8);

  	module.exports = Block.extend({
  	  type: "image",
  	  droppable: true,
  	  uploadable: true,
  	  icon_name: 'image',
  	  loadData: function loadData(data) {
  	    // Create our image tag
  	    this.editor.innerHTML = '';
  	    this.editor.appendChild(Dom.createElement('img', {
  	      src: data.file.url
  	    }));
  	  },
  	  onDrop: function onDrop(transferData) {
  	    var file = transferData.files[0],
  	        urlAPI = typeof URL !== "undefined" ? URL : typeof webkitURL !== "undefined" ? webkitURL : null; // Handle one upload at a time

  	    if (/image/.test(file.type)) {
  	      this.loading(); // Show this image on here

  	      Dom.hide(this.inputs);
  	      this.editor.innerHTML = '';
  	      this.editor.appendChild(Dom.createElement('img', {
  	        src: urlAPI.createObjectURL(file)
  	      }));
  	      Dom.show(this.editor);
  	      this.uploader(file, function (data) {
  	        this.setData(data);
  	        this.ready();
  	      }, function (error) {
  	        this.addMessage(i18n.t('blocks:image:upload_error'));
  	        this.ready();
  	      });
  	    }
  	  },
  	  asClipboardHTML: function asClipboardHTML() {
  	    var data = this.getBlockData();
  	    var url = data.file && data.file.url;
  	    if (!url) return;
  	    return "<img src=\"".concat(url, "\" alt=\"").concat(url, "\" />");
  	  }
  	});

  	/***/ }),
  	/* 231 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/*
  	  Heading Block
  	*/

  	var Block = __webpack_require__(8);

  	var stToHTML = __webpack_require__(22);

  	var ScribeTextBlockPlugin = __webpack_require__(90);

  	var ScribeHeadingPlugin = __webpack_require__(40);

  	var ScribeQuotePlugin = __webpack_require__(41);

  	module.exports = Block.extend({
  	  type: 'heading',
  	  editorHTML: '<h2 class="st-required st-text-block st-text-block--heading" contenteditable="true"></h2>',
  	  configureScribe: function configureScribe(scribe) {
  	    scribe.use(new ScribeTextBlockPlugin(this));
  	    scribe.use(new ScribeHeadingPlugin(this));
  	    scribe.use(new ScribeQuotePlugin(this));
  	    scribe.on('content-changed', this.toggleEmptyClass.bind(this));
  	  },
  	  mergeable: true,
  	  textable: true,
  	  toolbarEnabled: false,
  	  scribeOptions: {
  	    allowBlockElements: false,
  	    tags: {
  	      p: false
  	    }
  	  },
  	  icon_name: 'heading',
  	  loadData: function loadData(data) {
  	    if (this.options.convertFromMarkdown && data.format !== "html") {
  	      this.setTextBlockHTML(stToHTML(data.text, this.type));
  	    } else {
  	      this.setTextBlockHTML(data.text);
  	    }
  	  },
  	  onBlockRender: function onBlockRender() {
  	    this.toggleEmptyClass();
  	  },
  	  toggleEmptyClass: function toggleEmptyClass() {
  	    this.el.classList.toggle('st-block--empty', this._scribe.getTextContent().length === 0);
  	  },
  	  asClipboardHTML: function asClipboardHTML() {
  	    var data = this.getBlockData();
  	    return "<h2>".concat(data.text, "</h2>");
  	  }
  	});

  	/***/ }),
  	/* 232 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var selectionRange = __webpack_require__(13);

  	var Block = __webpack_require__(8);

  	var stToHTML = __webpack_require__(22);

  	var ScribeListBlockPlugin = __webpack_require__(233);

  	var _require = __webpack_require__(16),
  	    getTotalLength = _require.getTotalLength,
  	    rangeToHTML = _require.rangeToHTML,
  	    selectToEnd = _require.selectToEnd;

  	module.exports = Block.extend({
  	  type: 'list',
  	  icon_name: 'list',
  	  multi_editable: true,
  	  mergeable: true,
  	  scribeOptions: {
  	    allowBlockElements: false,
  	    tags: {
  	      p: false
  	    }
  	  },
  	  configureScribe: function configureScribe(scribe) {
  	    scribe.use(new ScribeListBlockPlugin(this));
  	    scribe.on('content-changed', function () {
  	      setTimeout(function () {
  	        if (scribe.getHTML() === "") {
  	          scribe.setHTML("<br>");
  	        }
  	      }, 0);
  	    });
  	  },
  	  editorHTML: '<ul class="st-list-block__list"></ul>',
  	  listItemEditorHTML: '<li class="st-list-block__item"><div class="st-list-block__editor st-block__editor"></div></li>',
  	  initialize: function initialize() {
  	    this.editorIds = [];
  	  },
  	  // Data functions (loading, converting, saving)
  	  beforeLoadingData: function beforeLoadingData() {
  	    this.setupListVariables();
  	    this.loadData(this._getData());
  	  },
  	  onBlockRender: function onBlockRender() {
  	    if (!this.ul) {
  	      this.setupListVariables();
  	    }

  	    if (this.editorIds.length < 1) {
  	      this.addListItem();
  	    }
  	  },
  	  setupListVariables: function setupListVariables() {
  	    this.ul = this.inner.querySelector('ul');
  	  },
  	  loadData: function loadData(data) {
  	    var block = this;

  	    if (this.options.convertFromMarkdown && data.format !== "html") {
  	      data = this.parseFromMarkdown(data.text);
  	    }

  	    if (data.listItems.length) {
  	      data.listItems.forEach(function (li) {
  	        block.addListItem(li.content);
  	      });
  	    } else {
  	      block.addListItem();
  	    }
  	  },
  	  parseFromMarkdown: function parseFromMarkdown(markdown) {
  	    var listItems = markdown.replace(/^ - (.+)$/mg, "$1").split("\n");
  	    listItems = listItems.filter(function (item) {
  	      return item.length;
  	    }).map(function (item) {
  	      return {
  	        content: stToHTML(item, this.type)
  	      };
  	    }.bind(this));
  	    return {
  	      listItems: listItems,
  	      format: 'html'
  	    };
  	  },
  	  _serializeData: function _serializeData() {
  	    var data = {
  	      format: 'html',
  	      listItems: []
  	    };
  	    this.editorIds.forEach(function (editorId) {
  	      var listItem = {
  	        content: this.getTextEditor(editorId).scribe.getContent()
  	      };
  	      data.listItems.push(listItem);
  	    }.bind(this));
  	    return data;
  	  },
  	  // List Items manipulation functions (add, remove, etc)
  	  addListItemAfterCurrent: function addListItemAfterCurrent(content) {
  	    this.addListItem(content, this.getCurrentTextEditor());
  	  },
  	  addListItem: function addListItem(content, after) {
  	    content = content || '';
  	    content = content.trim();

  	    if (content === "<br>") {
  	      content = '';
  	    }

  	    var editor = this.newTextEditor(this.listItemEditorHTML, content);

  	    if (after && this.ul.lastchild !== after.node) {
  	      var before = after.node.nextSibling;
  	      this.ul.insertBefore(editor.node, before);
  	      var idx = this.editorIds.indexOf(after.id) + 1;
  	      this.editorIds.splice(idx, 0, editor.id);
  	    } else {
  	      this.ul.appendChild(editor.node);
  	      this.editorIds.push(editor.id);
  	    }

  	    this.focusOn(editor);
  	  },
  	  focus: function focus() {
  	    var editor = this.getCurrentTextEditor();
  	    if (!editor) editor = this.getTextEditor(this.editorIds[0]);
  	    this.focusOn(editor);
  	  },
  	  focusOnNeighbor: function focusOnNeighbor(item) {
  	    var neighbor = this.previousListItem() || this.nextListItem();

  	    if (neighbor) {
  	      this.focusOn(neighbor);
  	    }
  	  },
  	  focusOn: function focusOn(editor) {
  	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	    var scribe = editor.scribe;
  	    var selection = new scribe.api.Selection();
  	    var lastChild = scribe.el.lastChild;
  	    var range;

  	    if (selection.range) {
  	      range = selection.range.cloneRange();
  	    }

  	    editor.el.focus();

  	    if (range) {
  	      range.setStartAfter(lastChild, 1);
  	      range.collapse(false);
  	    }

  	    if (options && options.focusAtEnd) {
  	      var start = getTotalLength(scribe);

  	      if (start > 0) {
  	        selectionRange(scribe.el, {
  	          start: start
  	        });
  	      }
  	    }

  	    if (options && options.caretPosition) {
  	      selectionRange(scribe.el, {
  	        start: options.caretPosition
  	      });
  	    }
  	  },
  	  focusAtStart: function focusAtStart() {
  	    var editor = this.getTextEditor(this.editorIds[0]);
  	    this.focusOn(editor);
  	  },
  	  focusAtEnd: function focusAtEnd() {
  	    var lastEditorId = this.editorIds[this.editorIds.length - 1];
  	    this.appendToTextEditor(lastEditorId);
  	  },
  	  removeCurrentListItem: function removeCurrentListItem() {
  	    if (this.editorIds.length === 1) {
  	      return;
  	    }

  	    var item = this.getCurrentTextEditor();
  	    var idx = this.editorIds.indexOf(item.id);
  	    this.focusOnNeighbor(item);
  	    this.editorIds.splice(idx, 1);
  	    this.ul.removeChild(item.node);
  	    this.removeTextEditor(item.id);
  	  },
  	  appendToCurrentItem: function appendToCurrentItem(content) {
  	    this.appendToTextEditor(this.getCurrentTextEditor().id, content);
  	  },
  	  isLastListItem: function isLastListItem() {
  	    return this.editorIds.length === 1;
  	  },
  	  nextListItem: function nextListItem() {
  	    var idx = this.editorIds.indexOf(this.getCurrentTextEditor().id);
  	    var editorId = this.editorIds[idx + 1];

  	    if (editorId !== undefined) {
  	      return this.getTextEditor(editorId);
  	    } else {
  	      return null;
  	    }
  	  },
  	  previousListItem: function previousListItem() {
  	    var idx = this.editorIds.indexOf(this.getCurrentTextEditor().id);
  	    var editorId = this.editorIds[idx - 1];

  	    if (editorId !== undefined) {
  	      return this.getTextEditor(editorId);
  	    } else {
  	      return null;
  	    }
  	  },
  	  asClipboardHTML: function asClipboardHTML() {
  	    var data = this.getBlockData();
  	    var listItems = data.listItems.map(function (item) {
  	      return "<li>".concat(item.content, "</li>");
  	    }).join("\n");
  	    return "<ul>".concat(listItems, "</ul>");
  	  },
  	  splitCurrentEditor: function splitCurrentEditor(scribe) {
  	    if (scribe.getTextContent().length === 0) return false;
  	    var content = rangeToHTML(selectToEnd(scribe));
  	    this.addListItemAfterCurrent(content);
  	    return true;
  	  },
  	  split: function split() {
  	    var currentEditor = this.getCurrentTextEditor();
  	    if (!currentEditor) return;
  	    var scribe = currentEditor.scribe;

  	    if (this.splitCurrentEditor(scribe)) {
  	      this.focusOnNeighbor();
  	      this.addListItemAfterCurrent("");
  	    }

  	    this.splitListItem(this.getCurrentTextEditor().scribe);
  	  },
  	  splitListItem: function splitListItem(scribe) {
  	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	    options = Object.assign({
  	      createTextBlock: false
  	    }, options);
  	    if (this.splitCurrentEditor(scribe)) return;
  	    var nextListItem = this.nextListItem();

  	    if (nextListItem) {
  	      var data = {
  	        format: 'html',
  	        listItems: []
  	      };
  	      this.removeCurrentListItem();
  	      this.focusOn(nextListItem);

  	      while (!!nextListItem) {
  	        data.listItems.push({
  	          content: nextListItem.scribe.getContent()
  	        });
  	        this.focusOn(nextListItem);
  	        this.removeCurrentListItem();
  	        nextListItem = this.nextListItem();
  	      }

  	      this.mediator.trigger("block:create", 'List', data, this.el, {
  	        autoFocus: true
  	      });
  	    } else {
  	      this.removeCurrentListItem();
  	    }

  	    if (options.createTextBlock) {
  	      this.mediator.trigger("block:create", 'Text', null, this.el, {
  	        autoFocus: true
  	      });
  	    }
  	  }
  	});

  	/***/ }),
  	/* 233 */
  	/***/ (function(module, exports, __webpack_require__) {


  	__webpack_require__(13);

  	var _require = __webpack_require__(16);
  	    _require.getTotalLength;
  	    var isAtStart = _require.isAtStart,
  	    isAtEnd = _require.isAtEnd,
  	    isSelectedFromStart = _require.isSelectedFromStart,
  	    isSelectedToEnd = _require.isSelectedToEnd;
  	    _require.rangeToHTML;
  	    _require.selectToEnd;

  	var ScribeListBlockPlugin = function ScribeListBlockPlugin(block) {
  	  return function (scribe) {
  	    scribe.el.addEventListener('keydown', function (ev) {
  	      if (block.supressKeyListeners) {
  	        return;
  	      }

  	      var content;

  	      if (ev.key === "Enter" && !ev.shiftKey) {
  	        ev.preventDefault();
  	        block.splitListItem(scribe, {
  	          createTextBlock: true
  	        });
  	      } else if (["Left", "ArrowLeft", "Up", "ArrowUp"].indexOf(ev.key) > -1) {
  	        if (ev.shiftKey && isSelectedFromStart(scribe)) {
  	          ev.preventDefault();
  	          ev.stopPropagation();
  	          document.activeElement && document.activeElement.blur();
  	          block.mediator.trigger("selection:block", block);
  	        } else if (isAtStart(scribe)) {
  	          ev.preventDefault();
  	          var previousListItem = block.previousListItem();

  	          if (previousListItem) {
  	            block.focusOn(previousListItem, {
  	              focusAtEnd: true
  	            });
  	          } else {
  	            block.mediator.trigger("block:focusPrevious", block.blockID);
  	          }
  	        }
  	      } else if (["Right", "ArrowRight", "Down", "ArrowDown"].indexOf(ev.key) > -1) {
  	        if (ev.shiftKey && isSelectedToEnd(scribe)) {
  	          ev.preventDefault();
  	          ev.stopPropagation();
  	          document.activeElement && document.activeElement.blur();
  	          block.mediator.trigger("selection:block", block);
  	        } else if (isAtEnd(scribe)) {
  	          ev.preventDefault();
  	          var nextListItem = block.nextListItem();

  	          if (nextListItem) {
  	            block.focusOn(nextListItem);
  	          } else {
  	            block.mediator.trigger("block:focusNext", block.blockID);
  	          }
  	        }
  	      } else if (ev.key === "Backspace" && isAtStart(scribe)) {
  	        ev.preventDefault();

  	        if (block.previousListItem()) {
  	          content = scribe.getContent();
  	          block.removeCurrentListItem();
  	          block.appendToCurrentItem(content);
  	        } else {
  	          var data = {
  	            format: 'html',
  	            text: scribe.getContent()
  	          };
  	          block.removeCurrentListItem();
  	          block.mediator.trigger("block:createBefore", 'Text', data, block, {
  	            autoFocus: true
  	          });

  	          if (block.isLastListItem()) {
  	            block.mediator.trigger('block:remove', block.blockID);
  	          }
  	        }
  	      }
  	    });
  	  };
  	};

  	module.exports = ScribeListBlockPlugin;

  	/***/ }),
  	/* 234 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var utils = __webpack_require__(1);

  	var Dom = __webpack_require__(3);

  	var Block = __webpack_require__(8);

  	var tweet_template = _.template(["<blockquote class='twitter-tweet' align='center'>", "<p><%= text %></p>", "&mdash; <%= user.name %> (@<%= user.screen_name %>)", "<a href='<%= status_url %>' data-datetime='<%= created_at %>'><%= created_at %></a>", "</blockquote>"].join("\n"));

  	module.exports = Block.extend({
  	  type: "tweet",
  	  icon_name: "tweet",
  	  droppable: true,
  	  pastable: true,
  	  fetchable: true,
  	  drop_options: {
  	    re_render_on_reorder: true
  	  },
  	  fetchUrl: function fetchUrl(tweetID) {
  	    return "/tweets/?tweet_id=" + tweetID;
  	  },
  	  loadData: function loadData(data) {
  	    if (_.isUndefined(data.status_url)) {
  	      data.status_url = '';
  	    }

  	    var twitterwidget = this.inner.querySelector('twitterwidget');
  	    Dom.remove(twitterwidget);
  	    this.inner.insertAdjacentHTML("afterbegin", tweet_template(data));
  	    var script = Dom.createElement('script', {
  	      src: '//platform.twitter.com/widgets.js'
  	    });
  	    this.inner.appendChild(script);
  	  },
  	  onContentPasted: function onContentPasted(event) {
  	    // Content pasted. Delegate to the drop parse method
  	    var input = event.target,
  	        val = input.value; // Pass this to the same handler as onDrop

  	    this.handleTwitterDropPaste(val);
  	  },
  	  handleTwitterDropPaste: function handleTwitterDropPaste(url) {
  	    if (!this.validTweetUrl(url)) {
  	      utils.log("Invalid Tweet URL");
  	      return;
  	    } // Twitter status


  	    var tweetID = url.match(/[^\/]+$/);

  	    if (!_.isEmpty(tweetID)) {
  	      this.loading();
  	      tweetID = tweetID[0];
  	      this.fetch(this.fetchUrl(tweetID), {
  	        dataType: 'json'
  	      }, this.onTweetSuccess, this.onTweetFail);
  	    }
  	  },
  	  validTweetUrl: function validTweetUrl(url) {
  	    return utils.isURI(url) && url.indexOf("twitter") !== -1 && url.indexOf("status") !== -1;
  	  },
  	  onTweetSuccess: function onTweetSuccess(data) {
  	    // Parse the twitter object into something a bit slimmer..
  	    var obj = {
  	      user: {
  	        profile_image_url: data.user.profile_image_url,
  	        profile_image_url_https: data.user.profile_image_url_https,
  	        screen_name: data.user.screen_name,
  	        name: data.user.name
  	      },
  	      id: data.id_str,
  	      text: data.text,
  	      created_at: data.created_at,
  	      entities: data.entities,
  	      status_url: "https://twitter.com/" + data.user.screen_name + "/status/" + data.id_str
  	    };
  	    this.setAndLoadData(obj);
  	    this.ready();
  	  },
  	  onTweetFail: function onTweetFail() {
  	    this.addMessage(i18n.t("blocks:tweet:fetch_error"));
  	    this.ready();
  	  },
  	  onDrop: function onDrop(transferData) {
  	    var url = transferData.getData('text/plain');
  	    this.handleTwitterDropPaste(url);
  	  },
  	  asClipboardHTML: function asClipboardHTML() {
  	    var data = this.getBlockData();
  	    if (!data.status_url) return;
  	    return "<p>".concat(data.status_url, "</p>");
  	  }
  	});

  	/***/ }),
  	/* 235 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var utils = __webpack_require__(1);

  	var Block = __webpack_require__(8);

  	module.exports = Block.extend({
  	  // more providers at https://gist.github.com/jeffling/a9629ae28e076785a14f
  	  providers: {
  	    vimeo: {
  	      regex: /(?:http[s]?:\/\/)?(?:www.)?vimeo\.co(?:.+(?:\/)([^\/].*)+$)/,
  	      html: "<iframe src=\"<%= protocol %>//player.vimeo.com/video/<%= remote_id %>?title=0&byline=0\" width=\"580\" height=\"320\" frameborder=\"0\"></iframe>",
  	      url: function url(remote_id) {
  	        return "https://player.vimeo.com/video/".concat(remote_id);
  	      }
  	    },
  	    youtube: {
  	      regex: /^.*(?:(?:youtu\.be\/)|(?:youtube\.com)\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*)/,
  	      html: "<iframe src=\"<%= protocol %>//www.youtube.com/embed/<%= remote_id %>\" width=\"580\" height=\"320\" frameborder=\"0\" allowfullscreen></iframe>",
  	      url: function url(remote_id) {
  	        return "https://www.youtube.com/embed/".concat(remote_id);
  	      }
  	    }
  	  },
  	  type: 'video',
  	  droppable: true,
  	  pastable: true,
  	  icon_name: 'video',
  	  loadData: function loadData(data) {
  	    if (!this.providers.hasOwnProperty(data.source)) {
  	      return;
  	    }

  	    var source = this.providers[data.source];
  	    var protocol = window.location.protocol === "file:" ? "http:" : window.location.protocol;
  	    var aspectRatioClass = source.square ? 'with-square-media' : 'with-sixteen-by-nine-media';
  	    this.editor.classList.add('st-block__editor--' + aspectRatioClass);
  	    this.editor.innerHTML = _.template(source.html, {
  	      protocol: protocol,
  	      remote_id: data.remote_id,
  	      width: this.editor.style.width // for videos like vine

  	    });
  	  },
  	  onContentPasted: function onContentPasted(event) {
  	    this.handleDropPaste(event.target.value);
  	  },
  	  matchVideoProvider: function matchVideoProvider(provider, index, url) {
  	    var match = provider.regex.exec(url);

  	    if (match == null || _.isUndefined(match[1])) {
  	      return {};
  	    }

  	    return {
  	      source: index,
  	      remote_id: match[1]
  	    };
  	  },
  	  handleDropPaste: function handleDropPaste(url) {
  	    if (!utils.isURI(url)) {
  	      return;
  	    }

  	    for (var key in this.providers) {
  	      if (!this.providers.hasOwnProperty(key)) {
  	        continue;
  	      }

  	      this.setAndLoadData(this.matchVideoProvider(this.providers[key], key, url));
  	    }
  	  },
  	  onDrop: function onDrop(transferData) {
  	    var url = transferData.getData('text/plain');
  	    this.handleDropPaste(url);
  	  },
  	  asClipboardHTML: function asClipboardHTML() {
  	    var data = this.getBlockData();
  	    var source = this.providers[data.source];
  	    var src = source.url(data.remote_id);
  	    return "<p>".concat(src, "</p>");
  	  }
  	});

  	/***/ }),
  	/* 236 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var config = __webpack_require__(2);

  	module.exports = function (_ref) {
  	  var name = _ref.name;
  	      _ref.text;
  	      var cmd = _ref.cmd,
  	      iconName = _ref.iconName;
  	  return "\n    <button type=\"button\" class=\"st-format-btn st-format-btn--".concat(name, "\" data-cmd=\"").concat(cmd, "\">\n      <svg role=\"img\" class=\"st-icon\">\n        <use xlink:href=\"").concat(config.defaults.iconUrl, "#").concat(iconName, "\"/>\n      </svg>\n    </button>\n  ");
  	};

  	/***/ }),
  	/* 237 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/*
  	 * Sir Trevor Editor
  	 * --
  	 * Represents one Sir Trevor editor instance (with multiple blocks)
  	 * Each block references this instance.
  	 * BlockTypes are global however.
  	 */

  	var _ = __webpack_require__(0);

  	var config = __webpack_require__(2);

  	var utils = __webpack_require__(1);

  	var Dom = __webpack_require__(3);

  	var Events = __webpack_require__(9);

  	var EventBus = __webpack_require__(4);

  	var FormEvents = __webpack_require__(92);

  	var BlockControls = __webpack_require__(238);

  	var BlockAddition = __webpack_require__(240);

  	var BlockAdditionTop = __webpack_require__(242);

  	var BlockManager = __webpack_require__(86);

  	var FormatBar = __webpack_require__(91);

  	var EditorStore = __webpack_require__(61);

  	var ErrorHandler = __webpack_require__(243);

  	var BlockPositionerSelect = __webpack_require__(82);

  	var SelectionHandler = __webpack_require__(244);

  	var Editor = function Editor(options) {
  	  this.initialize(options);
  	};

  	Object.assign(Editor.prototype, __webpack_require__(6), __webpack_require__(9), {
  	  bound: ['onFormSubmit', 'hideAllTheThings', 'changeBlockPosition', 'removeBlockDragOver', 'blockLimitReached', 'blockOrderUpdated', 'onBlockCountChange', 'renderBlockPositionerSelect'],
  	  events: {
  	    'block:reorder:dragend': 'removeBlockDragOver',
  	    'block:reorder:dropped': 'removeBlockDragOver',
  	    'block:content:dropped': 'removeBlockDragOver'
  	  },
  	  initialize: function initialize(options) {
  	    utils.log("Init SirTrevor.Editor");
  	    this.options = Object.assign({}, config.defaults, options || {});
  	    this.ID = _.uniqueId('st-editor-');

  	    if (!this._ensureAndSetElements()) {
  	      return false;
  	    }

  	    if (!_.isUndefined(this.options.onEditorRender) && _.isFunction(this.options.onEditorRender)) {
  	      this.onEditorRender = this.options.onEditorRender;
  	    } // Mediated events for *this* Editor instance


  	    this.mediator = Object.assign({}, Events);

  	    this._bindFunctions();

  	    config.instances.push(this);
  	    this.build();
  	    FormEvents.bindFormSubmit(this.form);
  	  },

  	  /*
  	   * Build the Editor instance.
  	   * Check to see if we've been passed JSON already, and if not try and
  	   * create a default block.
  	   * If we have JSON then we need to build all of our blocks from this.
  	   */
  	  build: function build() {
  	    Dom.hide(this.el);
  	    this.errorHandler = new ErrorHandler(this.outer, this.mediator, this.options.errorsContainer);
  	    this.store = new EditorStore(this.el.value, this.mediator);
  	    this.blockManager = new BlockManager(this);
  	    this.blockAddition = BlockAddition.create(this);
  	    this.BlockAdditionTop = BlockAdditionTop.create(this);
  	    this.blockControls = BlockControls.create(this);
  	    this.blockPositionerSelect = new BlockPositionerSelect(this.mediator);
  	    this.selectionHandler = new SelectionHandler(this.outer, this.mediator, this);
  	    this.formatBar = new FormatBar(this.options.formatBar, this.mediator, this);
  	    this.mediator.on('block:changePosition', this.changeBlockPosition);
  	    this.mediator.on('block:limitReached', this.blockLimitReached); // Apply specific classes when block order is updated

  	    this.mediator.on('block:rerender', this.blockOrderUpdated);
  	    this.mediator.on('block:create', this.blockOrderUpdated);
  	    this.mediator.on('block:remove', this.blockOrderUpdated);
  	    this.mediator.on('block:replace', this.blockOrderUpdated);
  	    this.mediator.on("block:countUpdate", this.onBlockCountChange);
  	    this.mediator.on("block-positioner-select:render", this.renderBlockPositionerSelect);
  	    this.dataStore = "Please use store.retrieve();";

  	    this._setEvents(); // External event listeners


  	    window.addEventListener('click', this.hideAllTheThings);
  	    document.body.addEventListener('keydown', this.disableBackButton);
  	    this.createBlocks();
  	    this.wrapper.classList.add('st-ready');

  	    if (!_.isUndefined(this.onEditorRender)) {
  	      this.onEditorRender();
  	    }
  	  },
  	  createBlocks: function createBlocks() {
  	    var store = this.store.retrieve();

  	    if (store.data.length > 0) {
  	      store.data.forEach(function (block) {
  	        this.mediator.trigger('block:create', block.type, block.data);
  	      }, this);
  	    } else if (this.options.defaultType !== false) {
  	      this.mediator.trigger('block:create', this.options.defaultType, {});
  	    }

  	    if (this.options.focusOnInit) {
  	      var blockElement = this.wrapper.querySelectorAll('.st-block')[0];

  	      if (blockElement) {
  	        var block = this.blockManager.findBlockById(blockElement.getAttribute('id'));
  	        block.focus();
  	      }
  	    }
  	  },
  	  destroy: function destroy() {
  	    // Destroy the rendered sub views
  	    this.formatBar.destroy();
  	    this.blockAddition.destroy();
  	    this.blockControls.destroy(); // Destroy all blocks

  	    this.blockManager.blocks.forEach(function (block) {
  	      this.mediator.trigger('block:remove', block.blockID);
  	    }, this); // Stop listening to events

  	    this.mediator.stopListening();
  	    this.stopListening(); // Remove instance

  	    config.instances = config.instances.filter(function (instance) {
  	      return instance.ID !== this.ID;
  	    }, this); // Remove external event listeners

  	    window.removeEventListener('click', this.hideAllTheThings);
  	    document.body.removeEventListener('keydown', this.disableBackButton); // Clear the store

  	    this.store.reset();
  	    Dom.replaceWith(this.outer, this.el);
  	  },
  	  getData: function getData() {
  	    this.onFormSubmit();
  	    return this.store.retrieve();
  	  },
  	  reinitialize: function reinitialize(options) {
  	    this.destroy();
  	    this.initialize(options || this.options);
  	  },
  	  restore: function restore(data) {
  	    this.el.value = data;
  	    this.reinitialize();
  	  },
  	  blockLimitReached: function blockLimitReached(toggle) {
  	    this.wrapper.classList.toggle('st--block-limit-reached', toggle);
  	  },
  	  blockOrderUpdated: function blockOrderUpdated() {
  	    // Detect first block and decide whether to hide top controls
  	    var blockElement = this.wrapper.querySelectorAll('.st-block')[0];
  	    var hideTopControls = false;

  	    if (blockElement) {
  	      var block = this.blockManager.findBlockById(blockElement.getAttribute('id'));
  	      hideTopControls = block && block.textable;
  	    }

  	    this._toggleHideTopControls(hideTopControls);
  	  },
  	  _toggleHideTopControls: function _toggleHideTopControls(toggle) {
  	    this.wrapper.classList.toggle('st--hide-top-controls', toggle);
  	  },
  	  onBlockCountChange: function onBlockCountChange(new_count) {
  	    this.blockPositionerSelect.onBlockCountChange(new_count);
  	  },
  	  renderBlockPositionerSelect: function renderBlockPositionerSelect(positioner) {
  	    this.blockPositionerSelect.renderInBlock(positioner);
  	  },
  	  _setEvents: function _setEvents() {
  	    Object.keys(this.events).forEach(function (type) {
  	      EventBus.on(type, this[this.events[type]], this);
  	    }, this);
  	  },
  	  hideAllTheThings: function hideAllTheThings(e) {
  	    this.blockControls.hide();
  	    this.blockAddition.hide();

  	    if (document.activeElement.getAttribute('contenteditable') === null) {
  	      this.formatBar.hide();
  	    }

  	    var popupSelectors = '.st-block__ui-delete-controls';
  	    Array.prototype.forEach.call(this.wrapper.querySelectorAll(popupSelectors), function (el) {
  	      el.classList.remove('active');
  	    });
  	  },
  	  store: function store(method, options) {
  	    utils.log("The store method has been removed, please call store[methodName]");
  	    return this.store[method].call(this, options || {});
  	  },
  	  removeBlockDragOver: function removeBlockDragOver() {
  	    var dragOver = this.outer.querySelector('.st-drag-over');

  	    if (!dragOver) {
  	      return;
  	    }

  	    dragOver.classList.remove('st-drag-over');
  	  },
  	  changeBlockPosition: function changeBlockPosition(block, selectedPosition) {
  	    selectedPosition = selectedPosition - 1;
  	    var blockPosition = this.blockManager.getBlockPosition(block),
  	        blockBy = this.wrapper.querySelectorAll('.st-block')[selectedPosition];

  	    if (blockBy && blockBy.getAttribute('id') !== block.getAttribute('id')) {
  	      this.hideAllTheThings();

  	      if (blockPosition > selectedPosition) {
  	        blockBy.parentNode.insertBefore(block, blockBy);
  	      } else {
  	        Dom.insertAfter(block, blockBy);
  	      }
  	    }
  	  },

  	  /*
  	   * Handle a form submission of this Editor instance.
  	   * Validate all of our blocks, and serialise all data onto the JSON objects
  	   */
  	  onFormSubmit: function onFormSubmit(shouldValidate) {
  	    // if undefined or null or anything other than false - treat as true
  	    shouldValidate = shouldValidate === false ? false : true;
  	    utils.log("Handling form submission for Editor " + this.ID);
  	    this.mediator.trigger('errors:reset');
  	    this.store.reset();
  	    this.validateBlocks(shouldValidate);
  	    this.blockManager.validateBlockTypesExist(shouldValidate);
  	    this.mediator.trigger('errors:render');
  	    this.el.value = this.store.toString();
  	    return this.errorHandler.errors.length;
  	  },

  	  /*
  	   * Call `validateAndSaveBlock` on each block found in the dom.
  	   */
  	  validateBlocks: function validateBlocks(shouldValidate) {
  	    var _this = this;

  	    Array.prototype.forEach.call(this.wrapper.querySelectorAll('.st-block'), function (block, idx) {
  	      var _block = _this.blockManager.findBlockById(block.getAttribute('id'));

  	      if (!_.isUndefined(_block)) {
  	        _this.validateAndSaveBlock(_block, shouldValidate);
  	      }
  	    });
  	  },

  	  /*
  	   * If block should be validated and is not valid then register an error.
  	   * Empty text blocks should be ignored.
  	   * Save any other valid blocks to the editor data store.
  	   */
  	  validateAndSaveBlock: function validateAndSaveBlock(block, shouldValidate) {
  	    if (!config.skipValidation && shouldValidate && !block.valid()) {
  	      this.mediator.trigger('errors:add', {
  	        text: _.result(block, 'validationFailMsg')
  	      });
  	      utils.log("Block " + block.blockID + " failed validation");
  	      return;
  	    }

  	    if (block.type === 'text' && block.isEmpty()) {
  	      return;
  	    }

  	    var blockData = block.getData();
  	    utils.log("Adding data for block " + block.blockID + " to block store:", blockData);
  	    this.store.addData(blockData);
  	  },

  	  /*
  	   * Disable back button so when a block loses focus the user
  	   * pressing backspace multiple times doesn't close the page.
  	   */
  	  disableBackButton: function disableBackButton(e) {
  	    var target = e.target || e.srcElement;

  	    if (e.keyCode === 8) {
  	      if (target.getAttribute('contenteditable') || target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
  	        return;
  	      }

  	      e.preventDefault();
  	    }
  	  },
  	  findBlockById: function findBlockById(block_id) {
  	    return this.blockManager.findBlockById(block_id);
  	  },
  	  getBlocksByType: function getBlocksByType(block_type) {
  	    return this.blockManager.getBlocksByType(block_type);
  	  },
  	  getBlocksByIDs: function getBlocksByIDs(block_ids) {
  	    return this.blockManager.getBlocksByIDs(block_ids);
  	  },
  	  getBlockPosition: function getBlockPosition(block) {
  	    utils.log("This method has been moved to blockManager.getBlockPosition()");
  	    return this.blockManager.getBlockPosition(block);
  	  },
  	  getBlocks: function getBlocks() {
  	    var _this2 = this;

  	    return [].map.call(this.wrapper.querySelectorAll('.st-block'), function (blockEl) {
  	      return _this2.findBlockById(blockEl.getAttribute('id'));
  	    });
  	  },

  	  /*
  	   * Set all dom elements required for the editor.
  	   */
  	  _ensureAndSetElements: function _ensureAndSetElements() {
  	    if (_.isUndefined(this.options.el)) {
  	      utils.log("You must provide an el");
  	      return false;
  	    }

  	    this.el = this.options.el;
  	    this.form = Dom.getClosest(this.el, 'form');
  	    var outer = Dom.createElement("div", {
  	      'id': this.ID,
  	      'class': 'st-outer notranslate',
  	      'dropzone': 'copy link move'
  	    });
  	    var wrapper = Dom.createElement("div", {
  	      'class': 'st-blocks'
  	    }); // Wrap our element in lots of containers *eww*

  	    Dom.wrap(Dom.wrap(this.el, outer), wrapper);
  	    this.outer = this.form.querySelector('#' + this.ID);
  	    this.wrapper = this.outer.querySelector('.st-blocks');
  	    return true;
  	  }
  	});
  	module.exports = Editor;

  	/***/ }),
  	/* 238 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/*
  	 * SirTrevor Block Controls
  	 * --
  	 * Gives an interface for adding new Sir Trevor blocks.
  	 */

  	var Blocks = __webpack_require__(21);

  	var Events = __webpack_require__(10);

  	var BLOCK_REPLACER_CONTROL_TEMPLATE = __webpack_require__(239);

  	function generateBlocksHTML(Blocks, availableTypes) {
  	  return availableTypes.reduce(function (memo, type) {
  	    if (Blocks.hasOwnProperty(type) && Blocks[type].prototype.toolbarEnabled) {
  	      return memo += BLOCK_REPLACER_CONTROL_TEMPLATE(Blocks[type].prototype);
  	    }

  	    return memo;
  	  }, "");
  	}

  	function render(Blocks, availableTypes) {
  	  var el = document.createElement('div');
  	  el.className = "st-block-controls__buttons";
  	  el.innerHTML = generateBlocksHTML.apply(null, arguments);
  	  var elButtons = document.createElement('div');
  	  elButtons.className = "st-block-controls";
  	  elButtons.appendChild(el);
  	  return elButtons;
  	}

  	module.exports.create = function (SirTrevor) {
  	  // REFACTOR - should probably not know about blockManager
  	  var el = render(Blocks, SirTrevor.blockManager.blockTypes);

  	  function replaceBlock(e) {
  	    // REFACTOR: mediator so that we can trigger events directly on instance?
  	    // REFACTOR: block create event expects data as second argument.

  	    /*jshint validthis:true */
  	    SirTrevor.mediator.trigger("block:replace", el.parentNode, this.getAttribute('data-type'));
  	  }

  	  function insert(e) {
  	    e.stopPropagation(); // we don't want el to be removed by the window click

  	    /*jshint validthis:true */

  	    var parent = this.parentNode;

  	    if (!parent || hide() === parent) {
  	      return;
  	    }

  	    parent.appendChild(el);
  	    parent.classList.toggle("st-block--controls-active");
  	  } // Public


  	  function hide() {
  	    var parent = el.parentNode;

  	    if (!parent) {
  	      return;
  	    }

  	    parent.removeChild(el);
  	    parent.classList.remove("st-block--controls-active");
  	    return parent;
  	  } // Public


  	  function destroy() {
  	    SirTrevor = null;
  	    el = null;
  	  }

  	  Events.delegate(SirTrevor.wrapper, ".st-block-replacer", "click", insert);
  	  Events.delegate(SirTrevor.wrapper, ".st-block-controls__button", "click", replaceBlock);
  	  return {
  	    el: el,
  	    hide: hide,
  	    destroy: destroy
  	  };
  	};

  	/***/ }),
  	/* 239 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var config = __webpack_require__(2);

  	module.exports = function (block) {
  	  return "\n    <button class=\"st-block-controls__button\" data-type=\"".concat(block.type, "\" type=\"button\">\n      <svg role=\"img\" class=\"st-icon\">\n        <use xlink:href=\"").concat(config.defaults.iconUrl, "#").concat(block.icon_name, "\"/>\n      </svg>\n      ").concat(block.title(), "\n    </button>\n  ");
  	};

  	/***/ }),
  	/* 240 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/*
  	 * SirTrevor Block Controls
  	 * --
  	 * Gives an interface for adding new Sir Trevor blocks.
  	 */

  	var dropEvents = __webpack_require__(35);

  	var EventBus = __webpack_require__(4);

  	var Dom = __webpack_require__(3);

  	var Events = __webpack_require__(10);

  	var TOP_CONTROLS_TEMPLATE = __webpack_require__(241);

  	module.exports.create = function (SirTrevor) {
  	  function createBlock(e) {
  	    // REFACTOR: mediator so that we can trigger events directly on instance?
  	    // REFACTOR: block create event expects data as second argument.

  	    /*jshint validthis:true */
  	    SirTrevor.mediator.trigger("block:create", 'Text', null, this.parentNode.parentNode.id ? this.parentNode.parentNode : this.parentNode);
  	  }

  	  function hide() {} // Public


  	  function destroy() {
  	    SirTrevor = null;
  	  }

  	  SirTrevor.wrapper.insertAdjacentHTML("beforeend", TOP_CONTROLS_TEMPLATE());
  	  var topControls = SirTrevor.wrapper.querySelector('.st-top-controls');

  	  function onDrop(ev) {
  	    ev.preventDefault();
  	    var dropped_on = topControls,
  	        item_id = ev.dataTransfer.getData("text/plain"),
  	        block = document.querySelector('#' + item_id);

  	    if (dropped_on.id !== item_id) {
  	      Dom.insertAfter(block, dropped_on);
  	    }

  	    SirTrevor.mediator.trigger("block:rerender", item_id);
  	    EventBus.trigger("block:reorder:dropped", item_id);
  	  }

  	  dropEvents.dropArea(topControls);
  	  topControls.addEventListener('drop', onDrop);
  	  Events.delegate(SirTrevor.wrapper, ".st-block-addition", "click", createBlock);
  	  return {
  	    destroy: destroy,
  	    hide: hide
  	  };
  	};

  	/***/ }),
  	/* 241 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var BLOCK_ADDITION_TEMPLATE = __webpack_require__(88);

  	module.exports = function () {
  	  return "\n    <div id=\"st_top\" class=\"st-top-controls\">\n      ".concat(BLOCK_ADDITION_TEMPLATE(), "\n    </div>\n  ");
  	};

  	/***/ }),
  	/* 242 */
  	/***/ (function(module, exports, __webpack_require__) {

  	/*
  	 * SirTrevor Block Controls
  	 * --
  	 * Gives an interface for adding new Sir Trevor blocks.
  	 */

  	var Events = __webpack_require__(10);

  	module.exports.create = function (SirTrevor) {
  	  function createBlock(e) {
  	    // REFACTOR: mediator so that we can trigger events directly on instance?
  	    // REFACTOR: block create event expects data as second argument.

  	    /*jshint validthis:true */
  	    SirTrevor.mediator.trigger("block:create", 'Text', null, this.parentNode.parentNode.previousSibling, {
  	      autoFocus: true
  	    });
  	  }

  	  function hide() {} // Public


  	  function destroy() {
  	    SirTrevor = null;
  	  }

  	  Events.delegate(SirTrevor.wrapper, ".st-block-addition-top__button", "click", createBlock);
  	  Events.delegate(SirTrevor.wrapper, ".st-block-addition-top__icon", "click", createBlock);
  	  return {
  	    destroy: destroy,
  	    hide: hide
  	  };
  	};

  	/***/ }),
  	/* 243 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var Dom = __webpack_require__(3);

  	var ErrorHandler = function ErrorHandler(wrapper, mediator, container) {
  	  this.wrapper = wrapper;
  	  this.mediator = mediator;
  	  this.el = container;

  	  if (_.isUndefined(this.el)) {
  	    this._ensureElement();

  	    this.wrapper.insertBefore(this.el, this.wrapper.firstChild);
  	  }

  	  Dom.hide(this.el);

  	  this._bindFunctions();

  	  this._bindMediatedEvents();

  	  this.initialize();
  	};

  	Object.assign(ErrorHandler.prototype, __webpack_require__(6), __webpack_require__(30), __webpack_require__(11), {
  	  errors: [],
  	  className: "st-errors",
  	  eventNamespace: 'errors',
  	  mediatedEvents: {
  	    'reset': 'reset',
  	    'add': 'addMessage',
  	    'render': 'render'
  	  },
  	  initialize: function initialize() {
  	    var list = document.createElement("ul");
  	    var p = document.createElement("p");
  	    p.innerHTML = i18n.t("errors:title");
  	    this.el.appendChild(p).appendChild(list);
  	    this.list = list;
  	  },
  	  render: function render() {
  	    if (this.errors.length === 0) {
  	      return false;
  	    }

  	    this.errors.forEach(this.createErrorItem, this);
  	    Dom.show(this.el);
  	  },
  	  createErrorItem: function createErrorItem(errorObj) {
  	    var error = document.createElement("li");
  	    error.classList.add("st-errors__msg");
  	    error.innerHTML = errorObj.text;
  	    this.list.appendChild(error);
  	  },
  	  addMessage: function addMessage(error) {
  	    this.errors.push(error);
  	  },
  	  reset: function reset() {
  	    if (this.errors.length === 0) {
  	      return false;
  	    }

  	    this.errors = [];
  	    this.list.innerHTML = '';
  	    Dom.hide(this.el);
  	  }
  	});
  	module.exports = ErrorHandler;

  	/***/ }),
  	/* 244 */
  	/***/ (function(module, exports, __webpack_require__) {


  	__webpack_require__(0);

  	var Dom = __webpack_require__(3);

  	var TYPE = 'application/vnd.sirtrevor+json';

  	var SelectionHandler = function SelectionHandler(wrapper, mediator, editor) {
  	  this.wrapper = wrapper;
  	  this.mediator = mediator;
  	  this.editor = editor;
  	  this.options = editor.options;
  	  this.startIndex = this.endIndex = 0;
  	  this.selecting = false;

  	  this._bindFunctions();

  	  this._bindMediatedEvents();

  	  this.initialize();
  	};

  	Object.assign(SelectionHandler.prototype, __webpack_require__(6), __webpack_require__(30), {
  	  eventNamespace: 'selection',
  	  bound: ['onCopy', 'onCut', 'onKeyDown', 'onMouseUp', 'onMouseDown', 'onPaste'],
  	  mediatedEvents: {
  	    'start': 'start',
  	    'render': 'render',
  	    'complete': 'complete',
  	    'all': 'all',
  	    'copy': 'copy',
  	    'update': 'update',
  	    'delete': 'delete',
  	    'cancel': 'cancel',
  	    'block': 'block'
  	  },
  	  canSelect: function canSelect() {
  	    // Don't select if within an input field
  	    var editorEl1 = Dom.getClosest(document.activeElement, 'input');
  	    if (editorEl1 !== document.body) return false;
  	    var editorEl2 = Dom.getClosest(document.activeElement, '.st-outer'); // Don't select all if focused on element outside of the editor.

  	    if (this.options.selectionLimitToEditor) {
  	      if (editorEl2 !== this.wrapper) return false;
  	    }

  	    return true;
  	  },
  	  initialize: function initialize() {
  	    if (!this.enabled()) return false;
  	    window.addEventListener("keydown", this.onKeyDown, false);
  	    window.addEventListener('mouseup', this.onMouseUp, false);
  	    document.addEventListener('copy', this.onCopy, false);

  	    if (this.options.selectionCut) {
  	      document.addEventListener('cut', this.onCut, false);
  	    }

  	    if (this.options.selectionPaste) {
  	      document.addEventListener('paste', this.onPaste, true);
  	    }
  	  },
  	  enabled: function enabled() {
  	    return !!this.options.selectionCopy;
  	  },
  	  start: function start(index) {
  	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	    if (!this.enabled()) return false;
  	    options = Object.assign({
  	      mouseEnabled: false,
  	      expand: false
  	    }, options);
  	    this.endIndex = index;
  	    if (!options.expand) this.startIndex = this.endIndex;
  	    this.selecting = true;

  	    if (options.mouseEnabled) {
  	      this.editor.mouseDown = true;
  	      this.selecting = this.startIndex !== this.endIndex;
  	      if (this.selecting) this.removeNativeSelection();
  	      window.addEventListener("mousemove", this.onMouseMove);
  	    }

  	    this.mediator.trigger("selection:render");
  	  },
  	  startAtEnd: function startAtEnd() {
  	    this.start(this.editor.getBlocks().length - 1);
  	  },
  	  move: function move(offset) {
  	    this.start(this.endIndex + offset);
  	  },
  	  onMouseMove: function onMouseMove() {},
  	  update: function update(index) {
  	    if (index < 0 || index >= this.editor.getBlocks().length) return;
  	    this.endIndex = index;
  	    if (this.startIndex !== this.endIndex) this.selecting = true;
  	    this.removeNativeSelection();
  	    this.mediator.trigger("selection:render");
  	  },
  	  expand: function expand(offset) {
  	    this.update(this.endIndex + offset);
  	  },
  	  expandToStart: function expandToStart() {
  	    this.update(0);
  	  },
  	  expandToEnd: function expandToEnd() {
  	    this.update(this.editor.getBlocks().length - 1);
  	  },
  	  focusAtEnd: function focusAtEnd() {
  	    var block = this.editor.getBlocks()[this.endIndex];
  	    block.el.scrollIntoView({
  	      behavior: "smooth"
  	    });
  	  },
  	  complete: function complete() {
  	    window.removeEventListener("mousemove", this.onMouseMove);
  	  },
  	  all: function all() {
  	    if (!this.enabled()) return false;
  	    this.removeNativeSelection();
  	    var blocks = this.editor.getBlocks();
  	    this.selecting = true;
  	    this.startIndex = 0;
  	    this.endIndex = blocks.length - 1;
  	    this.mediator.trigger("selection:render");
  	  },
  	  cancel: function cancel() {
  	    this.editor.mouseDown = false;
  	    this.selecting = false;
  	    this.render();
  	  },
  	  removeNativeSelection: function removeNativeSelection() {
  	    var sel = window.getSelection ? window.getSelection() : document.selection;

  	    if (sel) {
  	      if (sel.removeAllRanges) {
  	        sel.removeAllRanges();
  	      } else if (sel.empty) {
  	        sel.empty();
  	      }
  	    }

  	    document.activeElement && document.activeElement.blur();
  	  },
  	  render: function render() {
  	    var _this = this;

  	    var visible = this.selecting;
  	    this.editor.getBlocks().forEach(function (block, idx) {
  	      block.select(visible && _this.indexSelected(idx));
  	    });
  	  },
  	  getClipboardData: function getClipboardData() {
  	    var _this2 = this;

  	    this.editor.getData();
  	    var htmlOutput = [];
  	    var textOutput = [];
  	    var dataOutput = [];
  	    this.editor.getBlocks().forEach(function (block, idx) {
  	      if (_this2.indexSelected(idx)) {
  	        var html = block.asClipboardHTML();
  	        var text = html;
  	        htmlOutput.push(html);
  	        textOutput.push(text);
  	        dataOutput.push(block.getData());
  	      }
  	    });
  	    return {
  	      html: htmlOutput.join(""),
  	      text: textOutput.join("\n\n"),
  	      data: dataOutput
  	    };
  	  },
  	  copy: function copy() {
  	    var copyArea = this.createFakeCopyArea();
  	    copyArea.innerHTML = this.getClipboardData().html;
  	    var selection = window.getSelection();
  	    var range = document.createRange();
  	    range.selectNodeContents(copyArea);
  	    selection.removeAllRanges();
  	    selection.addRange(range);

  	    try {
  	      document.execCommand('copy');
  	      copyArea.blur();
  	    } catch (err) {
  	      console.log("Copy could not be performed");
  	    }
  	  },
  	  createFakeCopyArea: function createFakeCopyArea() {
  	    var copyArea = document.body.querySelector(".st-copy-area");

  	    if (!copyArea) {
  	      copyArea = Dom.createElement("div", {
  	        contenteditable: true,
  	        class: 'st-copy-area st-utils__hidden'
  	      });
  	      document.body.appendChild(copyArea);
  	    }

  	    return copyArea;
  	  },
  	  delete: function _delete() {
  	    var _this3 = this;

  	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  	    options = Object.assign({
  	      createNextBlock: true
  	    }, options);
  	    this.editor.getBlocks().forEach(function (block, idx) {
  	      if (!_this3.indexSelected(idx)) return;

  	      _this3.mediator.trigger("block:remove", block.blockID, {
  	        focusOnNext: true,
  	        createNextBlock: options.createNextBlock
  	      });
  	    });
  	    this.cancel();
  	  },
  	  indexSelected: function indexSelected(index) {
  	    return index >= this.getStartIndex() && index <= this.getEndIndex();
  	  },
  	  block: function block(_block) {
  	    var blockPosition = this.editor.blockManager.getBlockPosition(_block.el);
  	    this.mediator.trigger("formatter:hide");
  	    this.removeNativeSelection();
  	    this.start(blockPosition);
  	  },
  	  getStartIndex: function getStartIndex() {
  	    return Math.min(this.startIndex, this.endIndex);
  	  },
  	  getEndIndex: function getEndIndex() {
  	    return Math.max(this.startIndex, this.endIndex);
  	  },
  	  getStartBlock: function getStartBlock() {
  	    return this.editor.getBlocks()[this.getStartIndex()];
  	  },
  	  getEndBlock: function getEndBlock() {
  	    return this.editor.getBlocks()[this.getEndIndex()];
  	  },
  	  onKeyDown: function onKeyDown(ev) {
  	    ev = ev || window.event;
  	    var ctrlKey = ev.ctrlKey || ev.metaKey;
  	    var key = ev.key;

  	    if (this.selecting && key === "Backspace") {
  	      ev.preventDefault();
  	      this.delete();
  	    } else if (ctrlKey && key === "a") {
  	      if (!this.selecting && !this.canSelect()) return;
  	      ev.preventDefault();
  	      this.mediator.trigger("selection:all");
  	    } else if (this.selecting) {
  	      if (["Down", "ArrowDown"].indexOf(key) > -1) {
  	        ev.preventDefault();
  	        if (ev.shiftKey && ctrlKey) this.expandToEnd();else if (ev.shiftKey) this.expand(1);else if (ctrlKey) this.startAtEnd();else {
  	          this.cancel();
  	          this.mediator.trigger("block:focusNext", this.getEndBlock().blockID, {
  	            force: true
  	          });
  	          return;
  	        }
  	        this.focusAtEnd();
  	      } else if (["Up", "ArrowUp"].indexOf(key) > -1) {
  	        ev.preventDefault();
  	        if (ev.shiftKey && ctrlKey) this.expandToStart();else if (ev.shiftKey) this.expand(-1);else if (ctrlKey) this.start(0);else {
  	          this.cancel();
  	          this.mediator.trigger("block:focusPrevious", this.getStartBlock().blockID, {
  	            force: true
  	          });
  	          return;
  	        }
  	        this.focusAtEnd();
  	      }
  	    }
  	  },
  	  onMouseUp: function onMouseUp() {
  	    if (!this.editor.mouseDown) {
  	      window.addEventListener('mousedown', this.onMouseDown);
  	      this.mediator.trigger("selection:complete");
  	      this.mediator.trigger("selection:cancel");
  	      return;
  	    }

  	    this.editor.mouseDown = false;
  	    this.mediator.trigger("selection:complete");
  	    this.mediator.trigger("selection:render");
  	  },
  	  onMouseDown: function onMouseDown(ev) {
  	    if (!this.editor.mouseDown) {
  	      window.removeEventListener('mousedown', this.onMouseDown);
  	      this.mediator.trigger("selection:complete");
  	      this.mediator.trigger("selection:cancel");
  	      return;
  	    }
  	  },
  	  copySelection: function copySelection(ev) {
  	    var content = this.getClipboardData();
  	    ev.clipboardData.setData(TYPE, JSON.stringify(content.data));
  	    ev.clipboardData.setData('text/html', content.html);
  	    ev.clipboardData.setData('text/plain', content.text);
  	    ev.preventDefault();
  	  },
  	  onCopy: function onCopy(ev) {
  	    if (!this.selecting) return;
  	    this.copySelection(ev);
  	  },
  	  onCut: function onCut(ev) {
  	    if (!this.selecting) return;
  	    this.copySelection(ev);
  	    this.delete();
  	  },
  	  onPaste: function onPaste(ev) {
  	    // Fix Edge types DomStringList.
  	    var types = [].slice.call(ev.clipboardData.types);

  	    if (types.includes(TYPE)) {
  	      if (!this.selecting && !this.canSelect()) return;
  	      ev.preventDefault();
  	      ev.stopPropagation();
  	      var data = JSON.parse(ev.clipboardData.getData(TYPE));

  	      if (this.selecting) {
  	        var nextBlock = this.editor.getBlocks()[this.getEndIndex() + 1];
  	        this.delete({
  	          createNextBlock: false
  	        });

  	        if (nextBlock && !nextBlock.isEmpty()) {
  	          this.mediator.trigger("block:createBefore", "text", "", nextBlock, {
  	            autoFocus: true
  	          });
  	        } else {
  	          this.mediator.trigger("block:create", "text", "", null, {
  	            autoFocus: true
  	          });
  	        }
  	      }

  	      this.mediator.trigger("block:paste", data);
  	    }
  	  }
  	});
  	module.exports = SelectionHandler;

  	/***/ }),
  	/* 245 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var _ = __webpack_require__(0);

  	var utils = __webpack_require__(1);

  	module.exports = function (content, type) {
  	  // Deferring requiring these to sidestep a circular dependency:
  	  // Block -> this -> Blocks -> Block
  	  var Blocks = __webpack_require__(21);

  	  type = utils.classify(type);
  	  var markdown = content; //Normalise whitespace

  	  markdown = markdown.replace(/&nbsp;/g, " "); // First of all, strip any additional formatting
  	  // MSWord, I'm looking at you, punk.

  	  markdown = markdown.replace(/( class=(")?Mso[a-zA-Z]+(")?)/g, '').replace(/<!--(.*?)-->/g, '').replace(/\/\*(.*?)\*\//g, '').replace(/<(\/)*(meta|link|span|\\?xml:|st1:|o:|font)(.*?)>/gi, '');
  	  var badTags = ['style', 'script', 'applet', 'embed', 'noframes', 'noscript'],
  	      tagStripper,
  	      i;

  	  for (i = 0; i < badTags.length; i++) {
  	    tagStripper = new RegExp('<' + badTags[i] + '.*?' + badTags[i] + '(.*?)>', 'gi');
  	    markdown = markdown.replace(tagStripper, '');
  	  } // Escape anything in here that *could* be considered as MD
  	  // Markdown chars we care about: * [] _ () -


  	  markdown = markdown.replace(/\*/g, "\\*").replace(/\[/g, "\\[").replace(/\]/g, "\\]").replace(/\_/g, "\\_").replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\-/g, "\\-");
  	  var inlineTags = ["em", "i", "strong", "b"];

  	  for (i = 0; i < inlineTags.length; i++) {
  	    tagStripper = new RegExp('<' + inlineTags[i] + '><br></' + inlineTags[i] + '>', 'gi');
  	    markdown = markdown.replace(tagStripper, '<br>');
  	  }

  	  function replaceBolds(match, p1, p2) {
  	    if (_.isUndefined(p2)) {
  	      p2 = '';
  	    }

  	    return "**" + p1.replace(/<(.)?br(.)?>/g, '') + "**" + p2;
  	  }

  	  function replaceItalics(match, p1, p2) {
  	    if (_.isUndefined(p2)) {
  	      p2 = '';
  	    }

  	    return "_" + p1.replace(/<(.)?br(.)?>/g, '') + "_" + p2;
  	  }

  	  markdown = markdown.replace(/<(\w+)(?:\s+\w+="[^"]+(?:"\$[^"]+"[^"]+)?")*>\s*<\/\1>/gim, '') //Empty elements
  	  .replace(/\n/mg, "").replace(/<a.*?href=[""'](.*?)[""'].*?>(.*?)<\/a>/gim, function (match, p1, p2) {
  	    return "[" + p2.trim().replace(/<(.)?br(.)?>/g, '') + "](" + p1 + ")";
  	  }) // Hyperlinks
  	  .replace(/<strong>(?:\s*)(.*?)(\s)*?<\/strong>/gim, replaceBolds).replace(/<b>(?:\s*)(.*?)(\s*)?<\/b>/gim, replaceBolds).replace(/<em>(?:\s*)(.*?)(\s*)?<\/em>/gim, replaceItalics).replace(/<i>(?:\s*)(.*?)(\s*)?<\/i>/gim, replaceItalics); // Do our generic stripping out

  	  markdown = markdown.replace(/([^<>]+)(<div>)/g, "$1\n$2") // Divitis style line breaks (handle the first line)
  	  .replace(/<div><div>/g, '\n<div>') // ^ (double opening divs with one close from Chrome)
  	  .replace(/(?:<div>)([^<>]+)(?:<div>)/g, "$1\n") // ^ (handle nested divs that start with content)
  	  .replace(/(?:<div>)(?:<br>)?([^<>]+)(?:<br>)?(?:<\/div>)/g, "$1\n") // ^ (handle content inside divs)
  	  .replace(/<\/p>/g, "\n\n") // P tags as line breaks
  	  .replace(/<(.)?br(.)?>/g, "\n") // Convert normal line breaks
  	  .replace(/&lt;/g, "<").replace(/&gt;/g, ">"); // Encoding
  	  // Use custom block toMarkdown functions (if any exist)

  	  var block;

  	  if (Blocks.hasOwnProperty(type)) {
  	    block = Blocks[type]; // Do we have a toMarkdown function?

  	    if (!_.isUndefined(block.prototype.toMarkdown) && _.isFunction(block.prototype.toMarkdown)) {
  	      markdown = block.prototype.toMarkdown(markdown);
  	    }
  	  } // Strip remaining HTML


  	  markdown = markdown.replace(/<\/?[^>]+(>|$)/g, "");
  	  return markdown;
  	};

  	/***/ }),
  	/* 246 */
  	/***/ (function(module, exports, __webpack_require__) {

  	// extracted by mini-css-extract-plugin

  	/***/ })
  	/******/ ]);
  	}); 
  } (sirTrevor));

  var sirTrevorExports = sirTrevor.exports;
  const SirTrevor = /*@__PURE__*/getDefaultExportFromCjs(sirTrevorExports);

  // Place all the behaviors and hooks related to the matching controller here.
  // All this logic will automatically be available in application.js.

  class Pages {
    connect(){
      SirTrevor.setDefaults({
        iconUrl: Spotlight.sirTrevorIcon,
        uploadUrl: $('[data-attachment-endpoint]').data('attachment-endpoint'),
        ajaxOptions: {
          headers: {
            'X-CSRF-Token': Spotlight$1.csrfToken() || ''
          },
          credentials: 'same-origin'
        }
      });

      SirTrevor.Blocks.Heading.prototype.toolbarEnabled = true;
      SirTrevor.Blocks.Quote.prototype.toolbarEnabled = true;
      SirTrevor.Blocks.Text.prototype.toolbarEnabled = true;

      var instance = $('.js-st-instance').first();

      if (instance.length) {
        var editor = new SirTrevor.Editor({
          el: instance[0],
          blockTypes: instance.data('blockTypes'),
          defaultType:["Text"],
          onEditorRender: function() {
            $.SerializedForm();
          },
          blockTypeLimits: {
            "SearchResults": 1
          }
        });

        editor.blockControls = Spotlight$1.BlockControls.create(editor);

        new Spotlight$1.BlockLimits(editor).enforceLimits(editor);
      }
    }
  }

  class ProgressMonitor {
    connect() {
      var monitorElements = $('[data-behavior="progress-panel"]');
      var defaultRefreshRate = 3000;
      var panelContainer;
      var pollers = [];

      $(monitorElements).each(function() {
        panelContainer = $(this);
        panelContainer.hide();
        var monitorUrl = panelContainer.data('monitorUrl');
        var refreshRate = panelContainer.data('refreshRate') || defaultRefreshRate;
        pollers.push(
          setInterval(function() {
            checkMonitorUrl(monitorUrl);
          }, refreshRate)
        );
      });

      // Clear the intervals on turbolink:click event (e.g. when the user navigates away from the page)
      $(document).on('turbolinks:click', function() {
        if (pollers.length > 0) {
          $.each(pollers, function() {
            clearInterval(this);
          });
          pollers = [];
        }
      });

      function checkMonitorUrl(url) {
        $.ajax(url).done(success).fail(fail);
      }

      function success(data) {
        if (data.recently_in_progress) {
          updateMonitorPanel(data);
          monitorPanel().show();
        } else {
          monitorPanel().hide();
        }
      }

      function fail() { monitorPanel().hide(); }

      function updateMonitorPanel(data) {
        panelStartDate().text(data.started_at);
        panelCurrentDate().text(data.updated_at);
        panelCompletedDate().text(data.updated_at);
        panelCurrent().text(data.completed);
        setPanelCompleted(data.finished);
        updatePanelTotals(data);
        updatePanelErrorMessage(data);
        updateProgressBar(data);

        panelContainer.show();
      }

      function updateProgressBar(data) {
        var percentage = calculatePercentage(data);
        progressBar()
          .attr('aria-valuemax', data.total)
          .attr('aria-valuenow', percentage)
          .css('width', percentage + '%')
          .text(percentage + '%');

        if (data.finished) {
          progressBar().removeClass('active').removeClass('progress-bar-striped');
        }
      }

      function updatePanelErrorMessage(data) {
        // We currently do not store this state,
        // but with this code we can in the future.
        if ( data.errored ) {
          panelErrorMessage().show();
        } else {
          panelErrorMessage().hide();
        }
      }

      function updatePanelTotals(data) {
        panelTotals().each(function() {
          $(this).text(data.total);
        });
      }

      function calculatePercentage(data) {
        if (data.total == 0) return 0;
        return Math.floor((data.completed / data.total) * 100);
      }

      function monitorPanel() {
        return panelContainer.find('.index-status');
      }

      function panelStartDate() {
        return monitorPanel()
                 .find('[data-behavior="monitor-start"]')
                 .find('[data-behavior="date"]');
      }

      function panelCurrentDate() {
        return monitorPanel()
                 .find('[data-behavior="monitor-current"]')
                 .find('[data-behavior="date"]');
      }

      function panelCompletedDate() {
        return monitorPanel()
                 .find('[data-behavior="monitor-completed"]')
                 .find('[data-behavior="date"]');
      }

      function panelTotals() {
        return monitorPanel().find('[data-behavior="total"]');
      }

      function panelCurrent() {
        return monitorPanel()
                 .find('[data-behavior="monitor-current"]')
                 .find('[data-behavior="completed"]');
      }

      function progressBar() {
        return monitorPanel().find('.progress-bar');
      }

      function panelErrorMessage() {
        return monitorPanel().find('[data-behavior="monitor-error"]');
      }

      function setPanelCompleted(finished) {
        var panel = monitorPanel().find('[data-behavior="monitor-completed"]');

        if (finished) {
          panel.show();
        } else {
          panel.hide();
        }
      }

      return this;
    }
  }

  class ReadonlyCheckbox {
    connect() {
      // Don't allow unchecking of checkboxes with the data-readonly attribute 
      $("input[type='checkbox'][data-readonly]").on("click", function(event) {
        event.preventDefault();
      });
    }
  }

  (function($){
    $.fn.spotlightSearchTypeAhead = function( options ) {
      $.each(this, function(){
        addAutocompleteBehavior($(this));
      });

      function addAutocompleteBehavior( typeAheadInput, _ ) {
        var settings = $.extend({
          displayKey: 'title',
          minLength: 0,
          highlight: (typeAheadInput.data('autocomplete-highlight') || true),
          hint: (typeAheadInput.data('autocomplete-hint') || false),
          autoselect: (typeAheadInput.data('autocomplete-autoselect') || true)
        }, options);
        typeAheadInput.typeahead(settings, {
          displayKey: settings.displayKey,
          source: settings.bloodhound.ttAdapter(),
          templates: {
            suggestion: settings.template
          }
        });
      }
      return this;
    };
  })( jQuery );

  function itemsBloodhound() {
    var results = new Bloodhound({
      datumTokenizer: function(d) {
        return Bloodhound.tokenizers.whitespace(d.title);
      },
      queryTokenizer: Bloodhound.tokenizers.whitespace,
      limit: 100,
      remote: {
        url: $('form[data-autocomplete-exhibit-catalog-path]').data('autocomplete-exhibit-catalog-path').replace("%25QUERY", "%QUERY"),
        filter: function(response) {
          return $.map(response['docs'], function(doc) {
            return doc;
          })
        }
      }
    });
    results.initialize();
    return results;
  }
  function templateFunc(obj) {
    const thumbnail = obj.thumbnail ? `<div class="document-thumbnail"><img class="img-thumbnail" src="${obj.thumbnail}" /></div>` : '';
    return $(`<div class="autocomplete-item${obj.private ? ' blacklight-private' : ''}">${thumbnail}
  <span class="autocomplete-title">${obj.title}</span><br/><small>&nbsp;&nbsp;${obj.description}</small></div>`)
  }

  function addAutocompletetoFeaturedImage(){
    if($('[data-featured-image-typeahead]').length > 0) {
      $('[data-featured-image-typeahead]').spotlightSearchTypeAhead({bloodhound: itemsBloodhound(), template: templateFunc}).on('click', function() {
        $(this).select();
      }).on('typeahead:selected typeahead:autocompleted', function(e, data) {
        var panel = $($(this).data('target-panel'));
        addImageSelector($(this), panel, data.iiif_manifest, true);
        $($(this).data('id-field')).val(data['global_id']);
        $(this).attr('type', 'text');
      });
    }
  }

  /*
    Simple plugin to select form elements
    when other elements are clicked.
  */
  (function($) {
    $.fn.selectRelatedInput = function() {
      var clickElements = this;

      $(clickElements).each(function() {
        var target = $($(this).data('input-select-target'));

        var event;

        if ($(this).is("select")) {
          event = 'change';
        } else {
          event = 'click';
        }

        $(this).on(event, function() {
          if (target.is(":checkbox") || target.is(":radio")) {
            target.prop('checked', true);
          } else {
            target.focus();
          }
        });
      });

      return this;
    };
  })(jQuery);

  class SelectRelatedInput {
    connect() {
      $('[data-input-select-target]').selectRelatedInput();
    }
  }

  const Module = (function() {
      var nestableSelector = '[data-behavior="nestable"]';
      return {
        init: function(selector){

          $(selector || nestableSelector).each(function(){
            // Because the Rails helper will not maintain the case that Nestable
            // expects, we just need to do this manual conversion. :(
            var data = $(this).data();
            data.expandBtnHTML = data.expandBtnHtml;
            data.collapseBtnHTML = data.collapseBtnHtml;
            $(this).nestable(data);
            updateWeightsAndRelationships($(this));
          });
        }
      };
      function updateWeightsAndRelationships(nestedList){
        nestedList.on('change', function(event){
          var container = $(event.currentTarget);
          var data = $(this).nestable('serialize');
          var weight = 0;
          for(var i in data){
            var parent_id = data[i]['id'];
            const parent_node = findNode(parent_id, container);
            setWeight(parent_node, weight++);
            if(data[i]['children']){
              var children = data[i]['children'];
              for(var child in children){
                var id = children[child]['id'];
                var child_node = findNode(id, container);
                setWeight(child_node, weight++);
                setParent(child_node, parent_id);
              }
            } else {
              setParent(parent_node, "");
            }
          }
        });

      }
      function findNode(id, container) {
        return container.find("[data-id="+id+"]");
      }

      function setWeight(node, weight) {
        weight_field(node).val(weight);
      }

      function setParent(node, parent_id) {
        parent_page_field(node).val(parent_id);
      }

      /* find the input element with data-property="weight" that is nested under the given node */
      function weight_field(node) {
        return find_property(node, "weight");
      }

      /* find the input element with data-property="parent_page" that is nested under the given node */
      function parent_page_field(node){
        return find_property(node, "parent_page");
      }

      function find_property(node, property) {
        return node.find("input[data-property=" + property + "]");
      }
  })();

  class Tabs {
    connect() {
      if ($('[role=tabpanel]').length > 0 && window.location.hash) {
        var tabpanel = $(window.location.hash).closest('[role=tabpanel]');
        $('a[role=tab][href="#'+tabpanel.attr('id')+'"]').tab('show');
      }
    }
  }

  // translationProgress is a plugin that updates the "3/14" progress
  // counters in the tabs of the translation adminstration dashboard.
  // This works by counting the number of progress items and translations
  // present (indicated by data attributes) in each tab's content
  class TranslationProgress {
    connect() {
      $('[data-behavior="translation-progress"]').each(function(){
        var currentTab = $(this);
        var tabName = $(this).attr('aria-controls');
        var translationFields = $('#' + tabName).find('[data-translation-progress-item="true"]');
        var completedTranslations = $('#' + tabName).find('[data-translation-present="true"]');

        currentTab.find('span').text(completedTranslations.length + '/' + translationFields.length);
      });
    }
  }

  // Blacklight's BookmarkToggle is doing the real work, this only adds/removes the "blacklight-private" class.
  const VisibilityToggle = (e) => {
    if (e.target.matches('[data-checkboxsubmit-target="checkbox"]')) {
      const form = e.target.closest('form');
      if (form) {
        // Add/remove the "private" label to the document row when visibility is toggled
        const docRow = form.closest('tr');
        if (docRow) docRow.classList.toggle('blacklight-private');
      }
    }
  };
  document.addEventListener('click', VisibilityToggle);

  class Users {
    connect() {
      var container;
      function edit_user(event) {
        event.preventDefault();
        $(this).closest('tr').hide();
        const id = $(this).attr('data-target') || $(this).attr('data-bs-target');
        const edit_view = $("[data-edit-for='"+id+"']", container).show();
        $.each(edit_view.find('input[type="text"], select'), function() {
          // Cache original values incase editing is canceled
          $(this).data('orig', $(this).val());
        });
      }

      function cancel_edit(event) {
        event.preventDefault();
        const id = $(this).closest('tr').attr('data-edit-for');
        const edit_view = $("[data-edit-for='"+id+"']", container).hide();
        clear_errors(edit_view);
        rollback_changes(edit_view);
        $("[data-show-for='"+id+"']", container).show();
      }

      function clear_errors(element) {
        element.find('.has-error')
               .removeClass('has-error')
               .find('.form-text')
               .remove(); // Remove the error messages
      }

      function rollback_changes(element) {
        $.each(element.find('input[type="text"], select'), function() {
          $(this).val($(this).data('orig')).trigger('change');
        });
      }

      function destroy_user(event) {
        const id = $(this).attr('data-target') || $(this).attr('data-bs-target');
        $("[data-destroy-for='"+id+"']", container).val('1');
      }

      function new_user(event) {
        event.preventDefault();
        const edit_view = $("[data-edit-for='new']", container).show();
        $.each(edit_view.find('input[type="text"], select'), function() {
          // Cache original values incase editing is canceled
          $(this).data('orig', $(this).val());
        });
      }

      function open_errors() {
        const edit_row = container.find('.has-error').closest('[data-edit-for]');
        edit_row.show();
        // The following row has the controls, so show it too.
        edit_row.next().show();
      }

      $('.edit_exhibit, .admin-users').each(function() {

        container = $(this);
        $('[data-edit-for]', container).hide();
        open_errors();
        $("[data-behavior='edit-user']", container).on('click', edit_user);
        $("[data-behavior='cancel-edit']", container).on('click', cancel_edit);
        $("[data-behavior='destroy-user']", container).on('click', destroy_user);
        $("[data-behavior='new-user']", container).on('click', new_user);
      });
    }
  }

  (function ($){
    SirTrevor.BlockMixins.Autocompleteable = {
      mixinName: "Autocompleteable",
      preload: true,

      initializeAutocompleteable: function() {
        this.on("onRender", this.addAutocompletetoSirTrevorForm);

        if (this['autocomplete_url'] === undefined) {
          this.autocomplete_url = function() { return $('form[data-autocomplete-url]').data('autocomplete-url').replace("%25QUERY", "%QUERY"); };
        }

        if (this['transform_autocomplete_results'] === undefined) {
          this.transform_autocomplete_results = (val) => val;
        }

        if (this['autocomplete_control'] === undefined) {
          this.autocomplete_control = function() { return `<input type="text" class="st-input-string form-control item-input-field" data-twitter-typeahead="true" placeholder="${i18n.t("blocks:autocompleteable:placeholder")}"/>` };
        }

        if (this['bloodhoundOptions'] === undefined) {
          this.bloodhoundOptions = function() {
            return {
              remote: {
                url: this.autocomplete_url(),
                filter: this.transform_autocomplete_results
              }
            };
          };
        }
      },

      addAutocompletetoSirTrevorForm: function() {
        $('[data-twitter-typeahead]', this.inner).spotlightSearchTypeAhead({bloodhound: this.bloodhound(), template: this.autocomplete_template}).on('typeahead:selected typeahead:autocompleted', this.autocompletedHandler()).on( 'focus', function() {
          if($(this).val() === '') {
            $(this).data().ttTypeahead.input.trigger('queryChanged', '');
          }
        });
      },

      autocompletedHandler: function(e, data) {
        var context = this;

        return function(e, data) {
          $(this).typeahead("val", "");
          $(this).val("");

          context.createItemPanel($.extend(data, {display: "true"}));
        }
      },

      bloodhound: function() {
        var block = this;
        var results = new Bloodhound(Object.assign({
          datumTokenizer: function(d) {
            return Bloodhound.tokenizers.whitespace(d.title);
          },
          queryTokenizer: Bloodhound.tokenizers.whitespace,
          limit: 100,
        }, block.bloodhoundOptions()));
        results.initialize();
        return results;
      },
    },


    SirTrevor.Block.prototype.availableMixins.push("autocompleteable");
  })(jQuery);

  (function ($){
    SirTrevor.BlockMixins.Formable = {
      mixinName: "Formable",
      preload: true,

      initializeFormable: function() {

        if (this['afterLoadData'] === undefined) {
          this['afterLoadData'] = function(data) { };
        }
      },

      formId: function(id) {
        return this.blockID + "_" + id;
      },

      _serializeData: function() {

        var data = $(":input,textarea,select", this.inner).not(':input:radio').serializeJSON();

        $(':input:radio:checked', this.inner).each(function(index, input) {
          var key = $(input).data('key') || input.getAttribute('name');

          if (!key.match("\\[")) {
            data[key] = $(input).val();
          }
        });

        /* Simple to start. Add conditions later */
        if (this.hasTextBlock()) {
          data.text = this.getTextBlockHTML();
          data.format = 'html';
          if (data.text && data.text.length > 0 && this.options.convertToMarkdown) {
            data.text = stToMarkdown(data.text, this.type);
            data.format = 'markdown';
          }
        }

        return data;
      },

      loadData: function(data){
        if (this.hasTextBlock()) {
          if (data.text && data.text.length > 0 && this.options.convertFromMarkdown && data.format !== "html") {
            this.setTextBlockHTML(SirTrevor.toHTML(data.text, this.type));
          } else {
            this.setTextBlockHTML(data.text);
          }
        }
        this.loadFormDataByKey(data);
        this.afterLoadData(data);
      },

      loadFormDataByKey: function(data) {
        $(':input', this.inner).not('button,:input[type=hidden]').each(function(index, input) {
          var key = $(input).data('key') || input.getAttribute('name');

          if (key) {

            if (key.match("\\[\\]$")) {
              key = key.replace("[]", "");
            }

            // by wrapping it in an array, this'll "just work" for radio and checkbox fields too
            var input_data = data[key];

            if (!(input_data instanceof Array)) {
              input_data = [input_data];
            }
            $(this).val(input_data);
          }
        });
      },
    },


    SirTrevor.Block.prototype.availableMixins.push("formable");
  })(jQuery);

  (function ($){
    SirTrevor.BlockMixins.Plustextable = {
      mixinName: "Textable",
      preload: true,

      initializeTextable: function() {
        if (this['formId'] === undefined) {
          this.withMixin(SirTrevor.BlockMixins.Formable);
        }
        
        if (this['show_heading'] === undefined) {
          this.show_heading = true;
        }
      },
      
      align_key:"text-align",
      text_key:"item-text",
      heading_key: "title",
      
      text_area: function() { 
        return `
      <div class="row">
        <div class="col-md-8">
          <div class="form-group mb-3">
            ${this.heading()}
            <div class="field">
              <label for="${this.formId(this.text_key)}" class="col-form-label">${i18n.t("blocks:textable:text")}</label>
              <div id="${this.formId(this.text_key)}" class="st-text-block form-control" contenteditable="true"></div>
            </div>
          </div>
        </div>
        <div class="col-md-4">
          <div class="text-align">
            <p>${i18n.t("blocks:textable:align:title")}</p>
            <input data-key="${this.align_key}" type="radio" name="${this.formId(this.align_key)}" id="${this.formId(this.align_key + "-left")}" value="left" checked="true">
            <label for="${this.formId(this.align_key + "-left")}">${i18n.t("blocks:textable:align:left")}</label>
            <input data-key="${this.align_key}" type="radio" name="${this.formId(this.align_key)}" id="${this.formId(this.align_key + "-right")}" value="right">
            <label for="${this.formId(this.align_key + "-right")}">${i18n.t("blocks:textable:align:right")}</label>
          </div>
        </div>
      </div>`
      },
      
      heading: function() {
        if(this.show_heading) {
          return `<div class="field">
          <label for="${this.formId(this.heading_key)}" class="col-form-label">${i18n.t("blocks:textable:heading")}</label>
          <input type="text" class="form-control" id="${this.formId(this.heading_key)}" name="${this.heading_key}" />
        </div>`
        } else {
          return "";
        }
      },
    };
    

    SirTrevor.Block.prototype.availableMixins.push("plustextable");
  })(jQuery);

  (function ($){
    Spotlight$1.Block = SirTrevor.Block.extend({
      scribeOptions: {
        allowBlockElements: true,
        tags: { p: true }
      },
      formable: true,
      editorHTML: function() {
        return '';
      },
      beforeBlockRender: function() {
        this.availableMixins.forEach(function(mixin) {
          if (this[mixin] && SirTrevor.BlockMixins[this.capitalize(mixin)].preload) {
            this.withMixin(SirTrevor.BlockMixins[this.capitalize(mixin)]);
          }
        }, this);
      },
      $instance: function() { return $('#' + this.instanceID); },
      capitalize: function(string) {
        return string.charAt(0).toUpperCase() + string.substring(1).toLowerCase();
      }
    });
  })(jQuery);

  Spotlight$1.Block.Resources = (function(){

    return Spotlight$1.Block.extend({
      type: "resources",
      formable: true,
      autocompleteable: true,
      show_heading: true,
      show_alt_text: true,

      title: function() { return i18n.t("blocks:" + this.type + ":title"); },
      description: function() { return i18n.t("blocks:" + this.type + ":description"); },
      alt_text_guidelines: function() { 
        if (this.show_alt_text) {
          return i18n.t("blocks:alt_text_guidelines:intro"); 
        }
        return "";
      },
      alt_text_guidelines_link: function() {
        if (this.show_alt_text) {
          var link_url = i18n.t("blocks:alt_text_guidelines:link_url");
          var link_label = i18n.t("blocks:alt_text_guidelines:link_label");
          return '<a target="_blank" href="' + link_url + '">' +  link_label + '</a>'; 
        }
        return "";
      },
      icon_name: "resources",
      blockGroup: function() { return i18n.t("blocks:group:items") },

      primary_field_key: "primary-caption-field",
      show_primary_field_key: "show-primary-caption",
      secondary_field_key: "secondary-caption-field",
      show_secondary_field_key: "show-secondary-caption",

      display_checkbox: "display-checkbox",
      decorative_checkbox: "decorative-checkbox",
      alt_text_textarea: "alt-text-textarea",

      globalIndex: 0,

      _itemPanelIiifFields: function(index, data) {
        return [];
      },

      _altTextFieldsHTML: function(index, data) {
        if (this.show_alt_text) {
          return this.altTextHTML(index, data);
        }
        return "";
      },

      _itemPanel: function(data) {
        var index = "item_" + this.globalIndex++;
        var checked;
        if (data.display == "true") {
          checked = "checked='checked'";
        } else {
          checked = "";
        }
        var resource_id = data.slug || data.id;
        var markup = `
          <li class="field form-inline dd-item dd3-item" data-resource-id="${resource_id}" data-id="${index}" id="${this.formId("item_" + data.id)}">
            <input type="hidden" name="item[${index}][id]" value="${resource_id}" />
            <input type="hidden" name="item[${index}][title]" value="${data.title}" />
            ${this._itemPanelIiifFields(index, data)}
            <input data-property="weight" type="hidden" name="item[${index}][weight]" value="${data.weight}" />
              <div class="card d-flex dd3-content">
                <div class="dd-handle dd3-handle">${i18n.t("blocks:resources:panel:drag")}</div>
                <div class="card-header item-grid">
                  <div class="d-flex">
                    <div class="checkbox">
                      <input name="item[${index}][display]" type="hidden" value="false" />
                      <input name="item[${index}][display]" id="${this.formId(this.display_checkbox + '_' + data.id)}" type="checkbox" ${checked} class="item-grid-checkbox" value="true"  />
                      <label class="sr-only visually-hidden" for="${this.formId(this.display_checkbox + '_' + data.id)}">${i18n.t("blocks:resources:panel:display")}</label>
                    </div>
                    <div class="pic">
                      <img class="img-thumbnail" src="${(data.thumbnail_image_url || ((data.iiif_tilesource || "").replace("/info.json", "/full/!100,100/0/default.jpg")))}" />
                    </div>
                    <div class="main">
                      <div class="title card-title">${data.title}</div>
                      <div>${(data.slug || data.id)}</div>
                      ${this._altTextFieldsHTML(index, data)}
                    </div>
                    <div class="remove float-right float-end">
                      <a data-item-grid-panel-remove="true" href="#">${i18n.t("blocks:resources:panel:remove")}</a>
                    </div>
                  </div>
                  <div data-panel-image-pagination="true"></div>
                </div>
              </div>
            </li>
      `;

        const panel = $(markup);
        var context = this;

        $('.remove a', panel).on('click', function(e) {
          e.preventDefault();
          $(this).closest('.field').remove();
          context.afterPanelDelete();

        });

        this.afterPanelRender(data, panel);

        return panel;
      },

      afterPanelRender: function(data, panel) {

      },

      afterPanelDelete: function() {

      },

      createItemPanel: function(data) {
        var panel = this._itemPanel(data);
        this.attachAltTextHandlers(panel);
        $(panel).appendTo($('.panels > ol', this.inner));
        $('[data-behavior="nestable"]', this.inner).trigger('change');
      },

      item_options: function() { return ""; },

      content: function() {
        var templates = [this.items_selector()];
        if (this.plustextable) {
          templates.push(this.text_area());
        }
        return templates.join("<hr />\n");
      },

      items_selector: function() { return [
      '<div class="row">',
        '<div class="col-md-8">',
          '<div class="form-group mb-3">',
          '<div class="panels dd nestable-item-grid" data-behavior="nestable" data-max-depth="1"><ol class="dd-list"></ol></div>',
            this.autocomplete_control(),
          '</div>',
        '</div>',
        '<div class="col-md-4">',
          this.item_options(),
        '</div>',
      '</div>'].join("\n")
      },

      editorHTML: function() {
        return `<div class="form resources-admin clearfix">
        <div class="widget-header">
          ${this.description()}
          ${this.alt_text_guidelines()}
          ${this.alt_text_guidelines_link()}
        </div>
        ${this.content()}
      </div>`
      },

      _altTextData: function(data) {
        const isDecorative = data.decorative;
        const altText = isDecorative ? '' : (data.alt_text || '');
        const altTextBackup = data.alt_text_backup || '';
        const placeholderAttr = isDecorative ? '' : `placeholder="${i18n.t("blocks:resources:alt_text:placeholder")}"`;
        const disabledAttr = isDecorative ? 'disabled' : '';

        return { isDecorative, altText, altTextBackup, placeholderAttr, disabledAttr };
      },

      altTextHTML: function(index, data) {
        const { isDecorative, altText, altTextBackup, placeholderAttr, disabledAttr } = this._altTextData(data);
        return `<div class="mt-2 pt-2 d-flex">
          <div class="me-2 mr-2">
            <label class="col-form-label pb-0 pt-1" for="${this.formId(this.alt_text_textarea + '_' + data.id)}">${i18n.t("blocks:resources:alt_text:alternative_text")}</label>
            <div class="form-check mb-1 justify-content-end">
              <input class="form-check-input" type="checkbox" 
                id="${this.formId(this.decorative_checkbox + '_' + data.id)}" name="item[${index}][decorative]" ${isDecorative ? 'checked' : ''}>
              <label class="form-check-label" for="${this.formId(this.decorative_checkbox + '_' + data.id)}">${i18n.t("blocks:resources:alt_text:decorative")}</label>
            </div>
          </div>
          <div class="flex-grow-1 flex-fill d-flex">
            <input type="hidden" name="item[${index}][alt_text_backup]" value="${altTextBackup}" />
            <textarea class="form-control w-100" rows="2" ${placeholderAttr}
              id="${this.formId(this.alt_text_textarea + '_' + data.id)}" name="item[${index}][alt_text]" ${disabledAttr}>${altText}</textarea>
          </div>
        </div>`
      },

      attachAltTextHandlers: function(panel) {
        if (this.show_alt_text) {
          const decorativeCheckbox = $('input[name$="[decorative]"]', panel);
          const altTextInput = $('textarea[name$="[alt_text]"]', panel);
          const altTextBackupInput = $('input[name$="[alt_text_backup]"]', panel);

          decorativeCheckbox.on('change', function() {
            const isDecorative = this.checked;
            if (isDecorative) {
              altTextBackupInput.val(altTextInput.val());
              altTextInput.val('');
            } else {
              altTextInput.val(altTextBackupInput.val());
            }
            altTextInput
              .prop('disabled', isDecorative)
              .attr('placeholder', isDecorative ? '' : i18n.t("blocks:resources:alt_text:placeholder"));
          });

          altTextInput.on('input', function() {
            $(this).data('lastValue', $(this).val());
          });
        }
      },

      onBlockRender: function() {
        Module.init($('[data-behavior="nestable"]', this.inner));

        $('[data-input-select-target]', this.inner).selectRelatedInput();
      },

      afterLoadData: function(data) {
        var context = this;
        $.each(Object.keys(data.item || {}).map(function(k) { return data.item[k]}).sort(function(a,b) { return a.weight - b.weight; }), function(index, item) {
          context.createItemPanel(item);
        });
      },
    });

  })();

  SirTrevor.Blocks.Browse = (function(){

    return Spotlight$1.Block.Resources.extend({
      type: "browse",

      icon_name: "browse",

      autocomplete_url: function() {
        return $(this.inner).closest('form[data-autocomplete-exhibit-searches-path]').data('autocomplete-exhibit-searches-path').replace("%25QUERY", "%QUERY");
      },

      autocomplete_template: function(obj) {
        const thumbnail = obj.thumbnail_image_url ? `<div class="document-thumbnail"><img class="img-thumbnail" src="${obj.thumbnail_image_url}" /></div>` : '';
        return `<div class="autocomplete-item${!obj.published ? ' blacklight-private' : ''}">${thumbnail}
      <span class="autocomplete-title">${obj.full_title}</span><br/><small>&nbsp;&nbsp;${obj.description}</small></div>`
      },

      bloodhoundOptions: function() {
        return {
          prefetch: {
            url: this.autocomplete_url(),
            ttl: 0
          }
        };
      },

      _itemPanel: function(data) {
        var index = "item_" + this.globalIndex++;
        var checked;
        if (data.display == "true") {
          checked = "checked='checked'";
        } else {
          checked = "";
        }
        var resource_id = data.slug || data.id;
        var markup = `
           <li class="field form-inline dd-item dd3-item" data-resource-id="${resource_id}" data-id="${index}" id="${this.formId("item_" + data.id)}">
            <input type="hidden" name="item[${index}][id]" value="${resource_id}" />
            <input type="hidden" name="item[${index}][full_title]" value="${(data.full_title || data.title)}" />
            <input data-property="weight" type="hidden" name="item[${index}][weight]" value="${data.weight}" />
              <div class="card d-flex dd3-content">
                <div class="dd-handle dd3-handle">${i18n.t("blocks:resources:panel:drag")}</div>
                <div class="card-header item-grid">
                  <div class="d-flex">
                    <div class="checkbox">
                      <input name="item[${index}][display]" type="hidden" value="false" />
                      <input name="item[${index}][display]" id="${this.formId(this.display_checkbox + '_' + data.id)}" type="checkbox" ${checked} class="item-grid-checkbox" value="true"  />
                      <label class="sr-only visually-hidden" for="${this.formId(this.display_checkbox + '_' + data.id)}">${i18n.t("blocks:resources:panel:display")}</label>
                    </div>
                    <div class="pic">
                      <img class="img-thumbnail" src="${(data.thumbnail_image_url || ((data.iiif_tilesource || "").replace("/info.json", "/full/!100,100/0/default.jpg")))}" />
                    </div>
                    <div class="main">
                      <div class="title card-title">${(data.full_title || data.title)}</div>
                      <div>${(data.slug || data.id)}</div>
                    </div>
                    <div class="remove float-right float-end">
                      <a data-item-grid-panel-remove="true" href="#">${i18n.t("blocks:resources:panel:remove")}</a>
                    </div>
                  </div>
                </div>
              </div>
            </li>`;

        var panel = $(markup);
        var context = this;

        $('.remove a', panel).on('click', function(e) {
          e.preventDefault();
          $(this).closest('.field').remove();
          context.afterPanelDelete();

        });

        this.afterPanelRender(data, panel);

        return panel;
      },

      item_options: function() { return `
      <label>
        <input type="hidden" name="display-item-counts" value="false" />
        <input type="checkbox" name="display-item-counts" value="true" checked />
        ${i18n.t("blocks:browse:item_counts")}
      </label>`
      },
    });

  })();

  /*
    Sir Trevor BrowseGroupCategories
  */

  SirTrevor.Blocks.BrowseGroupCategories = (function(){

    return Spotlight$1.Block.Resources.extend({
      type: "browse_group_categories",
      icon_name: "browse",
      bloodhoundOptions: function() {
        var that = this;
        return {
          prefetch: {
            url: this.autocomplete_url(),
            ttl: 0,
            filter: function(response) {
              // Let the dom know that the response has been returned
              $(that.inner).attr('data-browse-groups-fetched', true);
              return response;
            }
          }
        };
      },

      autocomplete_control: function() {
        return `<input type="text" class="st-input-string form-control item-input-field" data-twitter-typeahead="true" placeholder="${i18n.t("blocks:browse_group_categories:autocomplete")}"/>`
      },
      autocomplete_template: function(obj) {
        return `<div class="autocomplete-item${!obj.published ? ' blacklight-private' : ''}">
      <span class="autocomplete-title">${obj.title}</span><br/></div>`
      },

      autocomplete_url: function() { return $(this.inner).closest('form[data-autocomplete-exhibit-browse-groups-path]').data('autocomplete-exhibit-browse-groups-path').replace("%25QUERY", "%QUERY"); },
      _itemPanel: function(data) {
        var index = "item_" + this.globalIndex++;
        var checked;
        if (data.display == "true") {
          checked = "checked='checked'";
        } else {
          checked = "";
        }
        var resource_id = data.slug || data.id;
        var markup = `
        <li class="field form-inline dd-item dd3-item" data-resource-id="${resource_id}" data-id="${index}" id="${this.formId("item_" + data.id)}">
          <input type="hidden" name="item[${index}][id]" value="${resource_id}" />
          <input type="hidden" name="item[${index}][title]" value="${data.title}" />
          <input data-property="weight" type="hidden" name="item[${index}][weight]" value="${data.weight}" />
            <div class="card d-flex dd3-content">
              <div class="dd-handle dd3-handle">${i18n.t("blocks:resources:panel:drag")}</div>
              <div class="d-flex card-header item-grid justify-content-between">
                <div class="d-flex flex-grow-1">
                  <div class="checkbox">
                    <input name="item[${index}][display]" type="hidden" value="false" />
                    <input name="item[${index}][display]" id="${this.formId(this.display_checkbox + '_' + data.id)}" type="checkbox" ${checked} class="item-grid-checkbox" value="true"  />
                    <label class="sr-only visually-hidden" for="${this.formId(this.display_checkbox + '_' + data.id)}">${i18n.t("blocks:resources:panel:display")}</label>
                  </div>
                  <div class="main">
                    <div class="title card-title">${data.title}</div>
                  </div>
                </div>
                <div class="d-flex">
                  <a data-item-grid-panel-remove="true" href="#">${i18n.t("blocks:resources:panel:remove")}</a>
                </div>
              </div>
            </div>
          </li>`;

        const panel = $(markup);
        var context = this;

        $('a[data-item-grid-panel-remove]', panel).on('click', function(e) {
          e.preventDefault();
          $(this).closest('.field').remove();
          context.afterPanelDelete();

        });

        this.afterPanelRender(data, panel);

        return panel;
      },

      item_options: function() { return `
      <label>
        <input type="hidden" name="display-item-counts" value="false" />
        <input type="checkbox" name="display-item-counts" value="true" checked />
        ${i18n.t("blocks:browse_group_categories:item_counts")}
      </label>`
      },
    });
  })();

  /*
    Sir Trevor ItemText Block.
    This block takes an ID,
    fetches the record from solr,
    displays the image, title, 
    and any provided text
    and displays them.
  */

  SirTrevor.Blocks.Iframe = (function(){

    return SirTrevor.Block.extend({
      type: "Iframe",
      formable: true,
      
      title: function() { return i18n.t('blocks:iframe:title'); },
      description: function() { return i18n.t('blocks:iframe:description'); },

      icon_name: "iframe",
      
      editorHTML: function() {
        return `<div class="clearfix">
        <div class="widget-header">
          ${this.description()}
        </div>
        <textarea name="code" class="form-control" rows="5" placeholder="${i18n.t("blocks:iframe:placeholder")}"></textarea>
      </div>`;
      }
    });
  })();

  SirTrevor.Blocks.LinkToSearch = (function(){

    return SirTrevor.Blocks.Browse.extend({

      type: "link_to_search",

      icon_name: 'search_results',

      searches_key: "slug",
      view_key: "view",
      plustextable: false,

    });
  })();

  /*
    Sir Trevor ItemText Block.
    This block takes an ID,
    fetches the record from solr,
    displays the image, title, 
    and any provided text
    and displays them.
  */

  SirTrevor.Blocks.Oembed =  (function(){

    return Spotlight$1.Block.extend({
      plustextable: true,

      id_key:"url",

      type: "oembed",
      
      title: function() { return i18n.t('blocks:oembed:title'); },
      description: function() { return i18n.t('blocks:oembed:description'); },

      icon_name: "oembed",
      show_heading: false,

      editorHTML: function () {
        return `<div class="form oembed-text-admin clearfix">
      <div class="widget-header">
        ${this.description()}
      </div>
      <div class="row">
        <div class="form-group mb-3 col-md-8">
          <label for="${this.formId(this.id_key)}">${i18n.t("blocks:oembed:url")}</label>
          <input name="${this.id_key}" class="form-control col-md-6" type="text" id="${this.formId(this.id_key)}" />
        </div>
      </div>
      ${this.text_area()}
    </div>`
      }
    });
  })();

  SirTrevor.Blocks.FeaturedPages = (function(){

    return Spotlight$1.Block.Resources.extend({
      type: "featured_pages",

      icon_name: "pages",

      autocomplete_url: function() { return $(this.inner).closest('form[data-autocomplete-exhibit-pages-path]').data('autocomplete-exhibit-pages-path').replace("%25QUERY", "%QUERY"); },
      autocomplete_template: function(obj) {
        const thumbnail = obj.thumbnail_image_url ? `<div class="document-thumbnail"><img class="img-thumbnail" src="${obj.thumbnail_image_url}" /></div>` : '';
        return `<div class="autocomplete-item${!obj.published ? ' blacklight-private' : ''}">${thumbnail}
      <span class="autocomplete-title">${obj.title}</span><br/><small>&nbsp;&nbsp;${obj.description}</small></div>`
      },
      bloodhoundOptions: function() {
        return {
          prefetch: {
            url: this.autocomplete_url(),
            ttl: 0
          }
        };
      }
    });

  })();

  /*
    Sir Trevor ItemText Block.
    This block takes an ID,
    fetches the record from solr,
    displays the image, title, 
    and any provided text
    and displays them.
  */

  SirTrevor.Blocks.Rule = (function(){

    return SirTrevor.Block.extend({
      type: "rule",
      
      title: function() { return i18n.t('blocks:rule:title'); },

      icon_name: "rule",
      
      editorHTML: function() {
        return '<hr />'
      }
    });
  })();

  //= require spotlight/admin/blocks/browse_block

  SirTrevor.Blocks.SearchResults =  (function(){

    return SirTrevor.Blocks.Browse.extend({

      type: "search_results",

      icon_name: 'search_results',

      searches_key: "slug",
      view_key: "view",
      plustextable: false,

      content: function() {
        return this.items_selector()
      },

      item_options: function() {
        var block = this;
        var fields = $('[data-blacklight-configuration-search-views]').data('blacklight-configuration-search-views');

        return $.map(fields, function(field) {
          return `<div>
          <label for='${block.formId(block.view_key + field.key)}'>
            <input id='${block.formId(block.view_key + field.key)}' name='${block.view_key}[]' type='checkbox' value='${field.key}' />
          ${field.label}
          </label>
        </div>`
        }).join("\n");
      },

      afterPanelRender: function(data, panel) {
        $(this.inner).find('.item-input-field').attr("disabled", "disabled");
      },

      afterPanelDelete: function() {
        $(this.inner).find('.item-input-field').removeAttr("disabled");
      },

    });
  })();

  SirTrevor.Blocks.SolrDocumentsBase = (function(){

    return Spotlight$1.Block.Resources.extend({
      plustextable: true,
      autocomplete_url: function() { return this.$instance().closest('form[data-autocomplete-exhibit-catalog-path]').data('autocomplete-exhibit-catalog-path').replace("%25QUERY", "%QUERY"); },
      autocomplete_template: function(obj) {
        const thumbnail = obj.thumbnail ? `<div class="document-thumbnail"><img class="img-thumbnail" src="${obj.thumbnail}" /></div>` : '';
        return `<div class="autocomplete-item${obj.private ? ' blacklight-private' : ''}">${thumbnail}
      <span class="autocomplete-title">${obj.title}</span><br/><small>&nbsp;&nbsp;${obj.description}</small></div>`
      },
      transform_autocomplete_results: function(response) {
        return $.map(response['docs'], function(doc) {
          return doc;
        })
      },

      caption_option_values: function() {
        var fields = $('[data-blacklight-configuration-index-fields]').data('blacklight-configuration-index-fields');

        return $.map(fields, function(field) {
          return $('<option />').val(field.key).text(field.label)[0].outerHTML;
        }).join("\n");
      },

      item_options: function() { return this.caption_options(); },

      caption_options: function() { return `
      <div class="field-select primary-caption" data-behavior="item-caption-admin">
        <input name="${this.show_primary_field_key}" type="hidden" value="false" />
        <input data-input-select-target="#${this.formId(this.primary_field_key)}" name="${this.show_primary_field_key}" id="${this.formId(this.show_primary_field_key)}" type="checkbox" value="true" />
        <label for="${this.formId(this.show_primary_field_key)}">${i18n.t("blocks:solr_documents:caption:primary")}</label>
        <select data-input-select-target="#${this.formId(this.show_primary_field_key)}" name="${this.primary_field_key}" id="${this.formId(this.primary_field_key)}">
          <option value="">${i18n.t("blocks:solr_documents:caption:placeholder")}</option>
          ${this.caption_option_values()}
        </select>
      </div>
      <div class="field-select secondary-caption" data-behavior="item-caption-admin">
        <input name="${this.show_secondary_field_key}" type="hidden" value="false" />
        <input data-input-select-target="#${this.formId(this.secondary_field_key)}" name="${this.show_secondary_field_key}" id="${this.formId(this.show_secondary_field_key)}" type="checkbox" value="true" />
        <label for="${this.formId(this.show_secondary_field_key)}">${i18n.t("blocks:solr_documents:caption:secondary")}</label>
        <select data-input-select-target="#${this.formId(this.show_secondary_field_key)}" name="${this.secondary_field_key}" id="${this.formId(this.secondary_field_key)}">
        <option value="">${i18n.t("blocks:solr_documents:caption:placeholder")}</option>
          ${this.caption_option_values()}
        </select>
      </div>
    `},

      // Sets the first version of the IIIF information from autocomplete data.
      _itemPanelIiifFields: function(index, autocomplete_data) {
        return [
          // '<input type="hidden" name="item[' + index + '][iiif_region]" value="' + (data.iiif_region) + '"/>',
          // for legacy compatiblity:
          '<input type="hidden" name="item[' + index + '][thumbnail_image_url]" value="' + (autocomplete_data.thumbnail_image_url || autocomplete_data.thumbnail || "") + '"/>',
          '<input type="hidden" name="item[' + index + '][full_image_url]" value="' + (autocomplete_data.full_image_url || autocomplete_data.thumbnail_image_url || autocomplete_data.thumbnail || "") + '"/>',
          '<input type="hidden" name="item[' + index + '][iiif_tilesource]" value="' + (autocomplete_data.iiif_tilesource) + '"/>',
          '<input type="hidden" name="item[' + index + '][iiif_manifest_url]" value="' + (autocomplete_data.iiif_manifest_url) + '"/>',
          '<input type="hidden" name="item[' + index + '][iiif_canvas_id]" value="' + (autocomplete_data.iiif_canvas_id) + '"/>',
          '<input type="hidden" name="item[' + index + '][iiif_image_id]" value="' + (autocomplete_data.iiif_image_id) + '"/>',
        ].join("\n");
      },
      // Overwrites the hidden inputs from _itemPanelIiifFields with data from the
      // manifest. Called by afterPanelRender - the manifest_data here is built
      // from canvases in the manifest, transformed by spotlight/admin/iiif.js in
      // the #images method.
      setIiifFields: function(panel, manifest_data, initialize) {
        var legacyThumbnailField = $(panel).find('[name$="[thumbnail_image_url]"]');
        var legacyFullField = $(panel).find('[name$="[full_image_url]"]');

        if (initialize && legacyThumbnailField.val().length > 0) {
          return;
        }

        legacyThumbnailField.val("");
        legacyFullField.val("");
        $(panel).find('[name$="[iiif_image_id]"]').val(manifest_data.imageId);
        $(panel).find('[name$="[iiif_tilesource]"]').val(manifest_data.tilesource);
        $(panel).find('[name$="[iiif_manifest_url]"]').val(manifest_data.manifest);
        $(panel).find('[name$="[iiif_canvas_id]"]').val(manifest_data.canvasId);
        $(panel).find('img.img-thumbnail').attr('src', manifest_data.thumbnail_image_url || manifest_data.tilesource.replace("/info.json", "/full/100,100/0/default.jpg"));
      },
      afterPanelRender: function(data, panel) {
        var context = this;
        var manifestUrl = data.iiif_manifest || data.iiif_manifest_url;

        if (!manifestUrl) {
          $(panel).find('[name$="[thumbnail_image_url]"]').val(data.thumbnail_image_url || data.thumbnail);
          $(panel).find('[name$="[full_image_url]"]').val(data.full_image_url);

          return;
        }

        $.ajax(manifestUrl).done(
          function(manifest) {
            var iiifManifest = new Iiif(manifestUrl, manifest);

            var thumbs = iiifManifest.imagesArray();

            if (!data.iiif_image_id) {
              context.setIiifFields(panel, thumbs[0], !!data.iiif_manifest_url);
            }


            if(thumbs.length > 1) {
              panel.multiImageSelector(thumbs, function(selectorImage) {
                context.setIiifFields(panel, selectorImage, false);
              }, data.iiif_image_id);
            }
          }
        );
      }
    });

  })();

  //= require spotlight/admin/blocks/solr_documents_base_block

  SirTrevor.Blocks.SolrDocuments = (function(){

    return SirTrevor.Blocks.SolrDocumentsBase.extend({
      type: "solr_documents",

      icon_name: "items",

      item_options: function() { return this.caption_options() + this.zpr_option(); },

      zpr_option: function() {
        return `
        <div>
        <input name="${this.zpr_key}" type="hidden" value="false" />
        <input name="${this.zpr_key}" id="${this.formId(this.zpr_key)}" data-key="${this.zpr_key}" type="checkbox" value="true" />
        <label for="${this.formId(this.zpr_key)}">${i18n.t("blocks:solr_documents:zpr:title")}</label>
        </div>
      `
      },

      zpr_key: 'zpr_link'
    });

  })();

  //= require spotlight/admin/blocks/solr_documents_base_block

  SirTrevor.Blocks.SolrDocumentsCarousel = (function(){

    return SirTrevor.Blocks.SolrDocumentsBase.extend({
      plustextable: false,
      type: "solr_documents_carousel",

      icon_name: "item_carousel",

      auto_play_images_key: "auto-play-images",
      auto_play_images_interval_key: "auto-play-images-interval",
      max_height_key: "max-height",

      carouselCycleTimesInSeconds: {
        values: [ 3, 5, 8, 12, 20 ],
        selected: 5
      },

      carouselMaxHeights: {
        values: { 'Small': 'small', 'Medium': 'medium', 'Large': 'large' },
        selected: 'Medium'
      },

      item_options: function() {
        return `${this.caption_options()}
        <div class="field-select auto-cycle-images" data-behavior="auto-cycle-images">
          <input name="${this.auto_play_images_key}" type="hidden" value="false" />
          <input name="${this.auto_play_images_key}" id="${this.formId(this.auto_play_images_key)}" data-key="${this.auto_play_images_key}" type="checkbox" value="true" checked/>
          <label for="${this.formId(this.auto_play_images_key)}">${i18n.t("blocks:solr_documents_carousel:interval:title")}</label>
          <select name="${this.auto_play_images_interval_key}" id="${this.formId(this.auto_play_images_interval_key)}" data=key="${this.auto_play_images_interval_key}">
            <option value="">${i18n.t("blocks:solr_documents_carousel:interval:placeholder")}</option>
            ${this.addCarouselCycleOptions(this.carouselCycleTimesInSeconds)}
          </select>
        </div>
        <div class="field-select max-heights" data-behavior="max-heights">
          <label for="${this.formId(this.max_height_key)}">${i18n.t("blocks:solr_documents_carousel:height:title")}</label><br/>
          ${this.addCarouselMaxHeightOptions(this.carouselMaxHeights)}
        </div>`
      },

      addCarouselCycleOptions: function(options) {
        var html = '';

        $.each(options.values, function(index, interval) {
          var selected = (interval === options.selected) ? 'selected' : '',
              intervalInMilliSeconds = parseInt(interval, 10) * 1000;

          html += '<option value="' + intervalInMilliSeconds + '" ' + selected + '>' + interval + ' seconds</option>';
        });

        return html;
      },

      addCarouselMaxHeightOptions: function(options) {
        var html = '',
            _this = this;

        $.each(options.values, function(size, px) {
          var checked = (size === options.selected) ? 'checked' : '',
              id = _this.formId(_this.max_height_key);

          html += '<input data-key="' + _this.max_height_key + '" type="radio" name="' + id + '" value="' + px + '" id="' + id + '" ' + checked + '>';
          html += '<label class="carousel-size" for="' + id + '">' + size + '</label>';
        });

        return html;
      },

      afterPreviewLoad: function(options) {
        $(this.inner).find('.carousel').carousel();

        // the bootstrap carousel only initializes data-bs-slide widgets on page load, so we need
        // to initialize them ourselves..
        var clickHandler = function (e) {
          var href;
          var $this   = $(this);
          var $target = $($this.attr('data-target') || $this.attr('data-bs-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
          if (!$target.hasClass('carousel')) return
          var options = $.extend({}, $target.data(), $this.data());
          var slideIndex = $this.attr('data-slide-to') || $this.attr('data-bs-slide-to');
          if (slideIndex) options.interval = false;

          $.fn.carousel.call($target, options);

          if (slideIndex) {
            $target.data('bs.carousel').to(slideIndex);
          }

          e.preventDefault();
        };

        $(this.inner).find('.carousel')
          .on('click.bs.carousel.data-api', '[data-slide], [data-bs-slide]', clickHandler)
          .on('click.bs.carousel.data-api', '[data-slide-to], [data-bs-slide-to]', clickHandler);
      }

    });

  })();

  //= require spotlight/admin/blocks/solr_documents_base_block

  SirTrevor.Blocks.SolrDocumentsEmbed = (function(){

    return SirTrevor.Blocks.SolrDocumentsBase.extend({
      type: "solr_documents_embed",
      show_alt_text: false,
      icon_name: "item_embed",

      item_options: function() { return "" },

      afterPreviewLoad: function(options) {
        $(this.inner).find('picture[data-openseadragon]').openseadragon();
      }
    });

  })();

  //= require spotlight/admin/blocks/solr_documents_base_block

  SirTrevor.Blocks.SolrDocumentsFeatures = (function(){

    return SirTrevor.Blocks.SolrDocumentsBase.extend({
      plustextable: false,
      type: "solr_documents_features",

      icon_name: "item_features",

      afterPreviewLoad: function(options) {
        $(this.inner).find('.carousel').carousel();

        // the bootstrap carousel only initializes data-bs-slide widgets on page load, so we need
        // to initialize them ourselves..
        var clickHandler = function (e) {
          var href;
          var $this   = $(this);
          var $target = $($this.attr('data-target') || $this.attr('data-bs-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
          if (!$target.hasClass('carousel')) return
          var options = $.extend({}, $target.data(), $this.data());
          var slideIndex = $this.attr('data-slide-to') || $this.attr('data-bs-slide-to');
          if (slideIndex) options.interval = false;

          $.fn.carousel.call($target, options);

          if (slideIndex) {
            $target.data('bs.carousel').to(slideIndex);
          }

          e.preventDefault();
        };

        $(this.inner).find('.carousel')
          .on('click.bs.carousel.data-api', '[data-slide], [data-bs-slide]', clickHandler)
          .on('click.bs.carousel.data-api', '[data-slide-to], [data-bs-slide-to]', clickHandler);
      }

    });

  })();

  //= require spotlight/admin/blocks/solr_documents_base_block

  SirTrevor.Blocks.SolrDocumentsGrid = (function(){

    return SirTrevor.Blocks.SolrDocumentsBase.extend({
      type: "solr_documents_grid",

      icon_name: "item_grid",


      item_options: function() { return "" }
    });

  })();

  SirTrevor.Blocks.UploadedItems = (function(){
    return Spotlight$1.Block.Resources.extend({
      plustextable: true,
      uploadable: true,
      autocompleteable: false,

      id_key: 'file',

      type: 'uploaded_items',

      icon_name: 'items',

      blockGroup: 'undefined',

      // Clear out the default Uploadable upload options
      // since we will be using our own custom controls
      upload_options: { html: '' },

      fileInput: function() { return $(this.inner).find('input[type="file"]'); },

      onBlockRender: function(){
        Module.init($(this.inner).find('[data-behavior="nestable"]'));

        this.fileInput().on('change', (function(ev) {
          this.onDrop(ev.currentTarget);
        }).bind(this));
      },

      onDrop: function(transferData){
        var file = transferData.files[0];
            (typeof URL !== "undefined") ? URL : (typeof webkitURL !== "undefined") ? webkitURL : null;

        // Handle one upload at a time
        if (/image/.test(file.type)) {
          this.loading();

          this.uploader(
            file,
            function(data) {
              this.createItemPanel(data);
              this.fileInput().val('');
              this.ready();
            },
            function(error) {
              this.addMessage(i18n.t('blocks:image:upload_error'));
              this.ready();
            }
          );
        }
      },

      title: function() { return i18n.t('blocks:uploaded_items:title'); },
      description: function() { return i18n.t('blocks:uploaded_items:description'); },

      globalIndex: 0,

      _itemPanel: function(data) {
        var index = "file_" + this.globalIndex++;
        var checked = 'checked="checked"';

        if (data.display == 'false') {
          checked = '';
        }

        var dataId = data.id || data.uid;
        var dataTitle = data.title || data.name;
        var dataUrl = data.url || data.file.url;

        var markup = `
          <li class="field form-inline dd-item dd3-item" data-id="${index}" id="${this.formId("item_" + dataId)}">
            <input type="hidden" name="item[${index}][id]" value="${dataId}" />
            <input type="hidden" name="item[${index}][title]" value="${dataTitle}" />
            <input type="hidden" name="item[${index}][url]" data-item-grid-thumbnail="true"  value="${dataUrl}"/>
            <input data-property="weight" type="hidden" name="item[${index}][weight]" value="${data.weight}" />
            <div class="card d-flex dd3-content">
              <div class="dd-handle dd3-handle">${i18n.t("blocks:resources:panel:drag")}</div>
              <div class="card-header d-flex item-grid">
                <div class="checkbox">
                  <input name="item[${index}][display]" type="hidden" value="false" />
                  <input name="item[${index}][display]" id="${this.formId(this.display_checkbox + '_' + dataId)}" type="checkbox" ${checked} class="item-grid-checkbox" value="true"  />
                  <label class="sr-only visually-hidden" for="${this.formId(this.display_checkbox + '_' + dataId)}">${i18n.t("blocks:resources:panel:display")}</label>
                </div>
                <div class="pic">
                  <img class="img-thumbnail" src="${dataUrl}" />
                </div>
                <div class="main form-horizontal">
                  <div class="title card-title">${dataTitle}</div>
                  <div class="field row mr-3 me-3">
                    <label for="${this.formId('caption_' + dataId)}" class="col-form-label col-md-3">${i18n.t("blocks:uploaded_items:caption")}</label>
                    <input type="text" class="form-control col" id="${this.formId('caption_' + dataId)}" name="item[${index}][caption]" data-field="caption"/>
                  </div>
                  <div class="field row mr-3 me-3">
                    <label for="${this.formId('link_' + dataId)}" class="col-form-label col-md-3">${i18n.t("blocks:uploaded_items:link")}</label>
                    <input type="text" class="form-control col" id="${this.formId('link_' + dataId)}" name="item[${index}][link]" data-field="link"/>
                  </div>
                  ${this._altTextFieldsHTML(index, data)}
                </div>
                <div class="remove float-right float-end">
                  <a data-item-grid-panel-remove="true" href="#">${i18n.t("blocks:resources:panel:remove")}</a>
                </div>
              </div>
            </li>`;

        const panel = $(markup);
        panel.find('[data-field="caption"]').val(data.caption);
        panel.find('[data-field="link"]').val(data.link);
        var context = this;

        $('.remove a', panel).on('click', function(e) {
          e.preventDefault();
          $(this).closest('.field').remove();
          context.afterPanelDelete();
        });

        this.afterPanelRender(data, panel);

        return panel;
      },

      editorHTML: function() {
        return `<div class="form oembed-text-admin clearfix">
        <div class="widget-header">
          ${this.description()}
          ${this.alt_text_guidelines()}
          ${this.alt_text_guidelines_link()}
        </div>
        <div class="row">
          <div class="form-group mb-3 col-md-8">
            <div class="panels dd nestable-item-grid" data-behavior="nestable" data-max-depth="1">
              <ol class="dd-list">
              </ol>
            </div>
            <input type="file" id="uploaded_item_url" name="file[file_0][file_data]" />
          </div>
          <div class="col-md-4">
            <input name="${this.zpr_key}" type="hidden" value="false" />
            <input name="${this.zpr_key}" id="${this.formId(this.zpr_key)}" data-key=${this.zpr_key}" type="checkbox" value="true" />
            <label for="${this.formId(this.zpr_key)}">${ i18n.t("blocks:solr_documents:zpr:title")}</label>
          </div>
        </div>
        ${this.text_area()}
      </div>`
      },

      altTextHTML: function(index, data) {
        const { isDecorative, altText, altTextBackup, placeholderAttr, disabledAttr } = this._altTextData(data);
        return `
      <div class="field row mr-3 me-3">
        <div class="col-lg-3 ps-md-2 pl-md-2">
          <label class="col-form-label text-nowrap pb-0 pt-1 justify-content-md-start justify-content-lg-end d-flex" for="${this.formId(this.alt_text_textarea + '_' + data.id)}">${i18n.t("blocks:resources:alt_text:alternative_text")}</label>
          <div class="form-check d-flex justify-content-md-start justify-content-lg-end">
            <input class="form-check-input" type="checkbox" 
              id="${this.formId(this.decorative_checkbox + '_' + data.id)}" name="item[${index}][decorative]" ${isDecorative ? 'checked' : ''}>
            <label class="form-check-label" for="${this.formId(this.decorative_checkbox + '_' + data.id)}">${i18n.t("blocks:resources:alt_text:decorative")}</label>
          </div>
        </div>
        <input type="hidden" name="item[${index}][alt_text_backup]" value="${altTextBackup}" />
        <textarea class="col-lg-9" rows="2" ${placeholderAttr}
          id="${this.formId(this.alt_text_textarea + '_' + data.id)}" name="item[${index}][alt_text]" ${disabledAttr}>${altText}</textarea>
      </div>`
      },

      zpr_key: 'zpr_link'
    });
  })();

  (function() {
    var BLOCK_REPLACER_CONTROL_TEMPLATE = function(block) {
      var el = document.createElement('button');
      el.className = "st-block-controls__button";
      el.setAttribute('data-type', block.type);
      el.type = "button";

      var img = document.createElement('svg');
      img.className = "st-icon";
      img.setAttribute('role', 'img');

      var use = document.createElement('use');
      use.setAttributeNS('https://www.w3.org/1999/xlink', 'href', SirTrevor.config.defaults.iconUrl + "#" + block.icon_name);
      img.appendChild(use);
      el.appendChild(img);
      el.appendChild(document.createTextNode(block.title()));

      return el.outerHTML;
    };

    function generateBlocksHTML(Blocks, availableTypes) {
      var groups = {};
      for(var i in availableTypes) {
        var type = availableTypes[i];
        if (Blocks.hasOwnProperty(type) && Blocks[type].prototype.toolbarEnabled) {
          var blockGroup;

          if ($.isFunction(Blocks[type].prototype.blockGroup)) {
            blockGroup = Blocks[type].prototype.blockGroup();
          } else {
            blockGroup = Blocks[type].prototype.blockGroup;
          }

          if (blockGroup == 'undefined' || blockGroup === undefined) {
            blockGroup = i18n.t("blocks:group:undefined");
          }

          groups[blockGroup] = groups[blockGroup] || [];
          groups[blockGroup].push(BLOCK_REPLACER_CONTROL_TEMPLATE(Blocks[type].prototype));
        }
      }

      function generateBlock(groups, key) {
        var group   = groups[key];
        var groupEl = $("<div class='st-controls-group'><div class='st-group-col-form-label'>" + key + "</div></div>");
        var buttons = group.reduce(function(memo, btn) {
          return memo += btn;
        }, "");
        groupEl.append(buttons);
        return groupEl[0].outerHTML;
      }

      var standardWidgets = generateBlock(groups, i18n.t("blocks:group:undefined"));

      var exhibitWidgets = Object.keys(groups).map(function(key) {
        if (key !== i18n.t("blocks:group:undefined")) {
          return generateBlock(groups, key);
        }
      }).filter(function (element) {
        return element != null;
      });

      var blocks = [standardWidgets].concat(exhibitWidgets).join("<hr />");
      return blocks;
    }

    function render(Blocks, availableTypes) {
      var el = document.createElement('div');
      el.className = "st-block-controls__buttons";
      el.innerHTML = generateBlocksHTML.apply(null, arguments);

      var elButtons = document.createElement('div');
      elButtons.className = "spotlight-block-controls";
      elButtons.appendChild(el);
      return elButtons;
    }

    Spotlight$1.BlockControls = function() { };
    Spotlight$1.BlockControls.create = function(editor) {
      // REFACTOR - should probably not know about blockManager
      var el = render(SirTrevor.Blocks, editor.blockManager.blockTypes);

      function hide() {
        var parent = el.parentNode;
        if (!parent) { return; }
        parent.removeChild(el);
        parent.classList.remove("st-block--controls-active");
        return parent;
      }

      function destroy() {
        window.SirTrevor = null;
        el = null;
      }

      function insert(e) {
        e.stopPropagation();

        var parent = this.parentNode;
        if (!parent || hide() === parent) { return; }
        $('.st-block__inner', parent).after(el);
        parent.classList.add("st-block--controls-active");
      }

      $(editor.wrapper).delegate(".st-block-replacer", "click", insert);
      $(editor.wrapper).delegate(".st-block-controls__button", "click", insert);

      return {
        el: el,
        hide: hide,
        destroy: destroy
      };
    };
  })();

  Spotlight$1.BlockLimits = function(editor) {
    this.editor = editor;
  };

  Spotlight$1.BlockLimits.prototype.enforceLimits = function(editor) {
    this.addEditorCallbacks(editor);
    this.checkGlobalBlockTypeLimit()();
  };

  Spotlight$1.BlockLimits.prototype.addEditorCallbacks = function(editor) {
    SirTrevor.EventBus.on('block:create:new', this.checkBlockTypeLimitOnAdd());
    SirTrevor.EventBus.on('block:remove', this.checkGlobalBlockTypeLimit());
  };

  Spotlight$1.BlockLimits.prototype.checkBlockTypeLimitOnAdd = function() {
    var editor = this.editor;

    return function(block) {
      var control = $(".st-block-controls__button[data-type='" + block.type + "']", editor.blockControls.el);

      control.prop("disabled", !editor.blockManager.canCreateBlock(block.class()));
    };
  };

  Spotlight$1.BlockLimits.prototype.checkGlobalBlockTypeLimit = function() {
    // we don't know what type of block was created or removed.. So, try them all.
    var editor = this.editor;

    return function() {
      $.each(editor.blockManager.blockTypes, function(i, type) {
        var block_type = SirTrevor.Blocks[type].prototype;

        var control = $(editor.blockControls.el).find(".st-block-controls__button[data-type='" + block_type.type + "']");
        control.prop("disabled", !editor.blockManager.canCreateBlock(type));
      });
    };
  };

  SirTrevor.Locales.en.blocks = $.extend(SirTrevor.Locales.en.blocks, {
    autocompleteable: {
      placeholder: "Enter a title..."
    },

    browse: {
      title: "Browse Categories",
      description: "This widget highlights browse categories. Each highlighted category links to the corresponding browse category results page.",
      item_counts: "Include item counts?"
    },

    browse_group_categories: {
      autocomplete: "Enter a browse group title...",
      title: "Browse Group Categories",
      description: "This widget displays all browse categories associated with a selected browse group as a horizontally-scrolling row. Each selected browse group is displayed as a separate row. Each displayed category in a group links to the corresponding browse category results page.",
      item_counts: "Include category item counts?"
    },

    link_to_search: {
      title: "Saved Searches",
      description: "This widget highlights saved searches. Each highlighted saved search links to the search results page generated by the saved search parameters. Any saved search listed on the Curation > Browse categories page, whether published or not, can be highlighted as a saved search.",
      item_counts: "Include item counts?"
    },

    iframe: {
      title:  "IFrame",
      description: "This widget embeds iframe-based embed code into pages",
      placeholder: "Enter embed code here. It should begin with e.g. '<iframe'"
    },

    oembed: {
      title: "Embed + Text",
      description: "This widget embeds an oEmbed-supported web resource and a text block to the left or right of it. Examples of oEmbed-supported resources include those from YouTube, Twitter, Flickr, and SlideShare.",
      url: "URL",
    },

    uploaded_items: {
      title: "Uploaded Item Row",
      description: "This widget displays uploaded items in a horizontal row. Optionally, you can add a heading and/or text to be displayed adjacent to the items. The item caption and link URL fields are also optional.",
      caption: 'Caption',
      link: 'Link URL'
    },

    featured_pages: {
      title:  "Pages",
      description: "This widget highlights pages from this exhibit. Each highlighted item links to the corresponding page."
    },

    resources: {
      panel: {
        drag: "Drag",
        display: "Display?",
        remove: "Remove"
      },
      alt_text: {
        decorative: "Decorative",
        alternative_text: "Alternative text",
        placeholder: "Enter alt text for this item..."
      }
    },

    rule: {
      title: "Horizontal Rule"
    },

    search_results: {
      title: "Search Results",
      description: "This widget displays a set of search results on a page. Specify a search result set by selecting an existing browse category. You can also select the view types that are available to the user when viewing the result set."
    },

    solr_documents: {
      title: "Item Row",
      description: "This widget displays exhibit items in a horizontal row. Optionally, you can add a heading and/or text to be displayed adjacent to the items.",
      caption: {
        placeholder: "Select...",
        primary: "Primary caption",
        secondary: "Secondary caption"
      },
      zpr: {
        title: 'Offer "View larger" option'
      }
    },

    solr_documents_carousel: {
      title: "Item Carousel",
      description: "This widget displays exhibit items in a carousel. You can configure the item captions, how the images are cycled, and the size of the carousel.",
      interval: {
        title: "Automatically cycle images",
        placeholder: "Select..."
      },
      height: {
        title: "Maximum carousel height"
      }
    },

    solr_documents_embed: {
      title: "Item Embed",
      description: "This widget embeds an exhibit item in a viewer on a page. Optionally, you can add a heading to be displayed above the viewer and/or text to be displayed adjacent to the viewer.",
    },

    solr_documents_features: {
      title: "Item Slideshow",
      description: "This widget displays exhibit items in a static slideshow. The user will move between items in the slideshow using the field you select as the primary caption."
    },

    solr_documents_grid: {
      title: "Item Grid",
      description: "This widget displays exhibit items in a multi-row grid. Optionally, you can add a heading and/or text to be displayed adjacent to the items."
    },

    textable: {
      heading: "Heading",
      text: "Text",
      align: {
        title: "Display text on:",
        left: "Left",
        right: "Right"
      }
    },

    group: {
      undefined: "Standard widgets",
      items: "Exhibit item widgets"
    },

    alt_text_guidelines: {
      intro: 'For each item, please enter alternative text or appropriately check the decorative box. ',
      link_label: 'Guidelines for writing alt text.',
      link_url: 'https://www.w3.org/WAI/tutorials/images/' 
    }
  });

  // These scripts are in the vendor directory


  class AdminIndex {
    connect() {
      new AddAnother().connect();
      new AddNewButton().connect();
      new CopyEmailAddress().connect();
      new Croppable().connect();
      new EditInPlace().connect();
      new ExhibitTagAutocomplete().connect();
      new Exhibits().connect();
      new FormObserver().connect();
      new Locks().connect();
      new BlacklightConfiguration().connect();
      new Pages().connect();
      new ProgressMonitor().connect();
      new ReadonlyCheckbox().connect();
      new SelectRelatedInput().connect();
      new Tabs().connect();
      new TranslationProgress().connect();
      new Users().connect();
      addAutocompletetoFeaturedImage();
      Module.init();
    }
  }

  Spotlight$1.onLoad(() => {
    new UserIndex().connect();
    new AdminIndex().connect();
  });

  return Spotlight$1;

}));
//# sourceMappingURL=spotlight.js.map
